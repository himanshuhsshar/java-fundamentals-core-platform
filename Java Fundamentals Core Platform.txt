Course Overview
Hi everyone. My name is Jim Wilson. Welcome to my course, Java Fundamentals: The Core Platform. I'm president of JW Hedgehog, Inc., and I've had the good fortune to have been a professional software developer now for over 30 years. Did you know that Java is the most in‑demand programming language skill among software developers? In addition, a recent survey also listed Java as one of the five most important skills for big data specialists. Java is supported on everything from smartphones, to servers, to many of the special‑purpose devices that make up the Internet of Things. Although some Java environments may offer specialized features or capabilities, virtually all Java environments rely on the features and capabilities of the cor Java platform known as the Java Runtime Environment, or JRE. In this course, we're going to teach everything you need to know to get started working in this core Java platform known as the Java Runtime Environment. So the major topics we cover include working with collections, streams, files in the file system, configuring application execution and environment, multi‑threading and concurrency, runtime type information, and reflection. By the end of this course, you'll be ready to begin working in any of the many environments that rely on Java. To get the most out of this course, you should already be familiar with the basics of the Java programming language. I hope you'll join me as we learn the Java Runtime Environment with the course, Java Fundamentals: The Core Platform, at Pluralsight.

Introduction
Introduction
Welcome to the introductory module of the Pluralsight course, Java Fundamentals: The Core Platform. My name is Jim Wilson. In this module, we're going to take a look at a few key points. First of all, we're going to look at this idea of Java having dual identities, of it being both a language and an environment. We'll then take a look at the idea of Java having a core environment and how that relates to other job environments.

The Role of the Java Core Platform
So when we use the term Java, what exactly are we talking about? Well, as I mentioned, Java has kind of two identities. It's a programming language, and it's a runtime environment. When we think of the aspect of being a programming language, we're thinking of things like data types, arrays, the fact that its object oriented, that has classes, right, those sorts of things. In order to get the most out of this course, it's important that you already have a solid understanding of the language aspects of Java. If you're not already familiar with the language aspects of Java, I encourage you to check out the course, Java Fundamentals: The Java Language, where we actually really dig into those language aspects. Because our focus in this course is going to be on the environment, the Java Runtime Environment. And that Java Runtime Environment is really the core platform of Java. Now when we're talking about the Java Runtime Environment, what we're talking about is the environment that most people think of when we just say Java. In fact, it's commonly just referred to as the JRE or Java SE as Java Standard Edition. Even when it comes to the Java Rruntime Environment, there's often a lot of confusion because there are a number of Java technologies, so it's important that we understand how they relate to the Java Runtime Environment, or commonly called the JRE. Now one technology is Java FX. And the Java FX is a Java technology we use to create rich client applications. Now there was a time where Java FX applications required you using a scripting environment, but now Java FX is just a library of classes, and when you use it, you actually write JRE programs and just call into those classes provided by Java FX. Now, an area where there's a lot of confusion is Java EE, or it's called Java Enterprise Edition. And that's the Java environment we use for creating highly scalable applications, what are often referred to as enterprise class applications. It's important to understand that Java EE builds on top of the JRE. It's a series of services to provide these enterprise features, but you're still using the JRE for the classes and the behaviors. And then there's something referred to as the Java Micro Edition, or Java ME. Now, Java Micro Edition is a subset of the JRE intended for embedded systems. Now it's widely used in things like, called the Internet of Things. And the Internet of Things is just his term for the idea of autonomous or semiautonomous systems that are connected by the internet. Java ME plays a really important part in those technologies. But even though Java ME is a separate platform from the JRE, it's heavily based on the JRE, so it's essential that you understand the JRE in order to work effectively in Java Micro Edition. Now all these technologies come from Oracle. Now, they originally were created by Sun, but now when Oracle bought Sun, Oracle owns all those technologies, and they're all very closely related. But there's one important outlier, and that's the Android environment. Now, Android is a Java‑based environment, but it's provided by Google and is developed separately from the other Java environments. Now, from a programming language standpoint, Android uses Java. All the aspects of the Java language are available there. But from a runtime standpoint, there are a number of differences, as well as similarities. From a similarity standpoint., you know, things like collections and a lot of those core classes are the same in Android as they are in the JRE. But there's other aspects that are a little bit more confusing, like things like threading, where threading a model in Android, it starts out kind of similar to the JRE, but then there's a bunch of other behaviors you need to understand to use them effectively. Then there are even other technologies that are really different. Things like the configuration system of Android is very different from the JRE. So having a solid understanding of the JRE is really helpful for working in Android, but there's a lot of other things you need to understand to really work effectively in Android. But when it comes to the Oracle‑based technologies, the Java EE, Java FX, and Java ME, understanding the Java Runtime Environment is really, really central to working effectively. It is the core platform for those Java environments and the focus of this course.

Input and Output with Streams and Files
Introduction
Welcome to the next module of the Java Fundamentals course, The Core Platform. In this module, we look at input and output with streams and files. My name is Jim Wilson. In this module, we're first going to take a look at working with streams. Then we're going to look how we deal with stream errors and cleaning up streams. Going to look at how we can make streams work together by chaining streams. Going to look at a number of specialized stream classes, including the file and buffered streams. Then we're going to look at the package java.nio.file, which gives us just a number of classes for working with files, performing file operations, and those sort of things. Take a look at the idea of working with file systems and different types of file systems. And then we'll finish up by taking a look at working with ZIP file systems.

Streams Overview
Streams in Java represent an ordered sequence of data. Now, what that really means is that they provide a common input/output model that we use throughout much of Java. The power of stream comes from the fact that they provide an abstraction. So whether you're using memory, disk‑based storage, or networking, the underlying source or destination, those details are abstracted away so you can think in terms of a common model, this idea of a ordered sequence of data. Now, any given stream is unidirectional. And so what that means is that when you create an instance of a stream, you're either going to use it to read from, or you're going to write to it. No single stream does both. As we work with streams, streams are broken out into two categories. Streams are either byte streams, which give us a binary representation of the data, or they are text streams, which give us a character‑based representation of the data. So when you're dealing with a stream, you're really either working at the kind of more raw data level or a little bit higher level at the character level. But whichever kind of stream you're working with, the interaction model is very similar in both cases. So in the next clip, we're going to take a look at just the details of reading from and writing to streams.

Reading and Writing with Streams
As we mentioned, each stream is used to either read from or write to. Let's first look at what it's like to read from a stream. Now remember that we have streams that work with binary data. Now the base class for reading from binary data is a class called InputStream. We also have streams for working with text data. So the base class to read text data from a stream is the Reader class. Now these two classes are very similar in terms of their interaction. So if I want to read an individual byte, I call the read method. I want to read an individual character, I call the read method on the Reader class. Now notice though that each of these methods return back an int. Now, an int is a 32‑bit value, whereas the InputStream works with bytes, which is 8 bits, and a Reader works with Unicode characters, which is 16 bits. So let's see what it's like to work with these. So let's look first at reading from our byte stream one byte at a time. So, of course, we go off, and we have to create our InputStream. We'll put that in a variable we call input. We'll declare a variable intVal to receive that int back. And then we can go ahead and read inside of a while loop. And so we'll call our input.read, putting the value into our intVal variable. Now notice that we're comparing the result to be greater than or equal to 0 because the way this read will indicate the end of the stream is by returning a ‑1. So as long as the value is 0 or greater, that means we actually got back a valid byte. So we do that comparison as an int just to make sure that we actually have something valid, but then when we're ready to actually use the byte, all we do is cast that int value into a byte, and that then gives us the actual byte value that was inside of there. And what we work with, of course, then is that byte value. Now reading from a character stream is very, very similar. So we go out and we create our Reader instance. We're going to go ahead and again declare a variable, intVal. It receives the individual character. And again, our while loop, we assign the read into the int, again compare it to be greater than or equal 0 so we know we're not at the end of the stream. But then we're ready to work with the individual character, we have to cast that int into the char, into the char value, and then that's what we actually work with. So we read these as ints, use that for the end of stream comparison, but then when we're ready to work with the actual data, we then cast it into the appropriate type, a byte for byte stream or a char for a character stream. So now we don't have to read individual values at a time. There's also read methods that allow us to work with arrays. And so on our input stream, there is a read that accepts a byte array. It'll read all the bytes that'll fit into that array. On the character side, there's a read that accepts a char array. That, again, will read all the characters we'll fit into that array. Notice that these reads also return an int. But in this case, the int returned is the number of characters actually read. The read method will read up to the number of values that will fit in the array, but if the stream doesn't have that many values, it may not be able to read that many. So the return value of read tells you exactly how many values were actually read. So again, if we look at our byte stream, again, we create our InputStream. We're going to go and have an integer variable, but this is going to be for the length, and then we have a variable that will be the array that we want to read into. So in this case, it's our byteBuff. It's declared hold up to 10 bytes. So now when we do our read, we assign it into the length, and again, notice that we're comparing to greater than or equal to 0 because the stream will indicate the end of stream by returning back a ‑1. So we've got our values in the byteBuff, but we cannot assume that the byteBuff is full. If we want to walk through the individual bytes inside of here, what we need to do is loop up to the length. The length tells us the actual number of bytes read so that we can get to the values byte by byte and then do something with them. Now, reading from the character stream will be very much the same. Declare our Reader. We'll have our integer variable to hold the length, an array to hold the actual characters. Again, we have our while loop assigning the return value of the function into length, making sure it's greater than or equal to 0, telling us we actually got some data back. We're now at the end of the stream. And then we actually use the length value to tell you how much we actually read, and then we can use that to get to the individual characters and then work with them. So now let's look at writing to a stream. Now, the write methods are a little bit less ambiguous than the read methods. If we look, we have our OutputStream for our byte streams. It has a write method that accepts an int, which is an individual byte that you want to write. And it has a write method that accepts an array. And of course, it accepts an int because that's the same thing that the byte by byte read returns. But we can go ahead and just pass a byte into that. Whereas if we go ahead and write to our bytes, we'll declare OutputStream. If I want to write an individual byte value, I declare it as a byte, and I can just write it out. Because remember that in Java, if you're doing a widening conversion from an 8‑bit value to a 32‑bit value, the compiler can take care of that for us. So it can go ahead and just pass in a byte, and it'll go ahead and convert it into the int for us. Writing out the array is really straightforward. We have the array. We just pass that in. When it comes to the character streams, we have a Writer class, which allows us to write an individual character. Allows us to write an array of characters, and it also allows us to write a string. But again, writing is really straightforward. We create our Writer instance. If we want to write a character value, we just pass it to write. Want to write an array of characters, we just take the array, pass it to write. Want to write a String, we just take the string and pass it to write. So, as you can see, it's much less ambiguous on the write side than it kind of was on the read side. So in the next clip, let's take a look at some of the common stream classes that inherit from these base stream classes.

Common Stream Classes
Now, we've talked about our InputStream class, which is a stream that allows to read binary data, and our OutputStream class, which is a stream that allows to write binary data. Now these are both base classes, and they're abstract base classes. So there are a number of classes that inherit from these to provide us concrete implementations of binary streams. We'll just look at some of the common ones here. Now we have things like the ByteArrayInputStream and the ByteArrayOutputStream, which allows to create a stream over a byte array. So in other words, we can create managed memory and then use that as a way to use streams. So we also have something called a PipedInputStream and a PipedOutputStream. And this is a powerful concept because it works really well for this idea of a producer‑consumer relationship where one part of your program can use the PipedOutputStream and write content into it. A different part of your program can use the PipedInputStream and then read that content back out, and the stream classes take care of coordinating what's been read and where things have been written. So it works really well for that producer‑consumer concept. Now, one of the ones we commonly work with are the FileInputStream and the FileOutputStream. And these allows to create streams over files. And we'll talk much more about those later in this module. Now, on the text content side, we know the Reader class is a stream that allows us to read text content. The Writer class is a stream that allows us to write text content. Again, these are abstract bases, and there are number of concrete classes that inherit from them. So we have the CharArrayReader and a CharArrayWriter, which allows us to, again, create a character array and to put streams over top of them. We also have a StringReader and a StringWriter, which allows us to work with string buffer and put streams over top of them. We have the PipedReader and the PipedWriter, which, again, gives us that producer‑consumer relationship over text content. We can use the PipedWriter to produce content in one part of a program, the PipedReader to consume that content. Then we have a couple of interesting ones. We have the InputStreamReader and the OutputStreamWriter. What these allow us to do is create a reader over an input stream or a writer over an output stream. So, in other words, we can have an input stream, which is binary stream, and then by putting the InputStreamReader over top of it, we can consume it as a text stream. So we're kind of layering streams together. We'll talk a little bit more about that concept just shortly here in this module that often we produce higher‑level functionalities by layering one stream over another. And classes that inherit from these two are FileReader and FileWriter, which allow us to have file‑based content with a reader and writer over top of those. So it's these concrete classes that actually give us the stream functionality. Now the next clip, we're going to take a look at some of the issues and some of the realities we have to deal with when working with streams.

Stream Errors and Cleanup
So far, we've been looking at the general features of streams, but we haven't considered all the realities of working with streams. And one of those realities is error handling. It's possible for a stream to encounter errors, and it's going to indicate those errors by throwing exceptions, so we have to deal with those exceptions. Also, there's the issue of cleaning up streams. We cannot always rely on Java's resource recovery to clean up streams. Now the issue is that streams are backed by physical storage. Very often that storage exists outside the Java Runtime, things like files or network connections. So in those cases, the Java resource recovery, the garbage collector, can't really be relied on to clean those things up in a timely fashion. So we need to address that. We need to somehow provide some kind of reliable cleanup. And what that really means is that we need some concept of closing down a stream when we're done with it. Now, to deal with that, the stream classes implement the closable interface. And that's nice because it has one method on it, which is the close method. So we're basically responsible to call this close method. Now let's look at the code to interact with this close method. So I've got some code here. It's just a very simple usage of a reader stream. So we have our reader declared, and then inside of the try block we go ahead and open the reader, and we do something with the reader. We have a catch block in there to handle the I/O exceptions, and then we have a finally to call close. So the finally will make sure the close gets called. But it turns out this issue of calling close isn't quite as simple as we're showing it here. For example, what happens if in the process of opening the reader that actually throws an exception? Well, if that's the case, we may never actually create the reader, so the reader reference might be null. So that simple call to close really needs to expand out here into a check to make sure reader is non‑null, and if it's non‑null, call close. Well, it gets even more complicated than that. If we were to look at the declaration of close, close can actually throw exceptions. So our cal to close also has to have a try catch to deal with that. So that little bit of code to simply close it suddenly gets very involved. And this is something we have to do frequently, not just which streams, but in many cases. So what we'd like to do is identify a way that we can automate cleanup. And we do that through what's called the AutoClosable interface. Now, the AutoClosable interface is, again, a very simple interface. It has one method, close. Decoration is really straightforward, right, interface AutoClosable. The method close can throw an exception. Now, this is the base interface of the interface Closable. All right, so we see that Closable extends AutoClosable, has that one method, and it basically specifically throws the IOException. So what happens is that by a type implementing the AutoClosable interface, it provides support for this try‑with‑resources. Now we know that streams implement the Closable interface, which means that they also implement the AutoClosable interface. So this thing, try‑with‑resources, what is that? Well, try‑with‑resources is a way to automate the process of cleaning up one or more resources. Now, the question is, what's a resource? Well, a resource is any type that implements AutoClosable. So it gives us a way that a type could say, hey, I support this auto‑closing by implementing this interface. Try‑with‑resources is a statement structure that we have in Java that allows us to automate that process of calling close. Now the syntax for try‑with‑resources is very similar to a traditional try statement, and it can even have catch blocks in it. Now, the neat thing about the catch blocks is that obviously we use those to handle the errors, and it would handle any errors that occur inside the try block of try‑with‑resources, but it'll also handle the errors that are thrown and a call to close. What this means is that with try‑with‑resources the catch blocks can handle errors on code that we explicitly call, but they can also handle errors on code that we did not explicitly call, which is the close method, which is called first automatically. So in the next clip, let's take a look at some actual code examples of working with try‑with‑resources.

Demo: Working with Try-with-resources Part 1
Let's take a look now at what it's like to work with our try‑with‑resources in code. So what we'll do here is that we've got the simple file here. I'm just calling it file1.txt. If we open it up, it's just got the characters A through Z inside of it. So we'll just write some code to exercise just kind of reading through that. Now what I have in place here is this initial function here. I've got dotryCatchFinally. And this shows kind of the longhand way of managing closing up our streams. And so we've got our variable declarations at the top, including the reader that we're going to actually use to read. Now when we open the reader, we do that inside of of our try block here. And I've got this Helper function which handles the detail of opening the file. We'll actually take a look a little later in this module at exactly what it's like to work with files directly. But for now, we'll just use this Helper method. Inside the try block, we just go ahead and read through the content, and then printing out the length of how many characters to read each time, and then loop through the characters. We've got a catch block in place here for IOException, and then our finally is kind of really where we're doing all this extra work. We have the close we want to call, but we have to check to see if it's null. We have to have a separate try‑catch inside of there. And so what we're looking for is to use to try‑with‑resources to really get rid of that finally block. So what I'm going to do is scroll down to this other method I have down here. This is called doTryWithResources. Now, currently, this is the exact same code we just went through. But what we want to do now is change this code so that it uses the try‑with‑resources. Now one of the key things is try‑with‑resources, we have to identify the resource, and the resource basically exists for the life of the try statement. So what I'm going to do here is put parentheses after the try. It's inside of there where we actually declare our resource. Now our resource is a reader. So I'll go ahead and put a Reader declaration here. And what we want to do is go ahead and open up our reader. So what we're going to do is take this statement we have here separately where we go ahead and open the reader, and we're going to put that inside the parentheses. I'm going to go ahead and cut that, and then we'll paste it inside the parentheses here. So now with that, we're going to go ahead and get rid of the original declaration. So I'll go ahead and delete that away. Delete this blank line away. And so now we're creating the reader within the try statement. And the key thing is that that really takes care of identifying that we want to have this automatically closed. So we can get rid, this whole finally block here, we can get rid of this. Just go ahead and delete all this away. And with that, we're really done. What's happened is that because we used the try‑with‑resources syntax, all of that work to call in the close is just done for us. We simply went ahead and created the instance inside of the parentheses by the try, do our try block as we normally do, and do our catch block as we normally do. So if we go ahead and run this, we should see the number of characters read each time and each of the characters, so let's go ahead and do that. And so if we look here, we'll see that initially it reads in 8 characters, which is A through H, then 8 characters, which is the I through P, then 8 characters, Q through X, and then it gets the last 2 characters, it reads the 2, Y and Z. Now one of the powers of the try‑with‑resources is that it can actually work on multiple resources. So what I'm going to do is scroll down to this next method here, doTryWithResourcesMulti. Now this is the same code we finished writing, and what we want to do is go ahead and update this. Rather than just reading through one file and reading the characters out, let's go ahead and use this to go ahead and copy the contents of one file into another file. And to do that's actually really straightforward. Inside of our parentheses here, we can actually declare multiple resources. So I've already got my reader in place. So I'm going to put a semicolon, and then I can go ahead and create another resource here. So what I'm going to do is go ahead and create a writer as well. So I'll declare a Writer called writer. And then I'm going to use my helper function to go ahead and open up a writer of our file2.txt. So now we have our two resources, the reader and the writer. Then what I'll do here is that here we'll actually loop through and print the characters out to the screen. What we'll do now is change that to write out to the writer. So what I'm going to do is take my writer and calls its write method. Now remember that we can call writer passing in an actual array, and we can also go beyond that and actually pass in an array of the starting index and the number of characters we want to write. So what we're going to is go ahead and write out buff, but we're going to say we want to start at position 0, and we're going to want to write length of characters because remember that we know that we don't necessarily read in the full space of the buffer. In fact, we saw last time, we read in the full eight three times, but the last time, we only read in two. So we only want to write out the useful parts of the buffer. So that's why we write out length because length tell us how many characters are actually read into the buffer. So then we go ahead and write out only that many characters back out. So now if I scroll up to the top of my code here, get back to my Main function, now I'll change this to go ahead and call that doTryWithResourcesMulti. So I'll comment out this first one, uncomment out the next one. So now when we run it, we only see the number of characters that we read each time, which, again, is the 8, 8, 8, and 2. But if I return back to the file system, notice that there now is a file2.txt. If I open that up, that has all the characters inside of it. So we successfully copied the contents from one file to another. And the key thing is that if we go back to our try‑with‑resources here, let me just scroll back down to the bottom, it took care of closing up not just one resource, but two. And we can put as many resources inside of these parentheses as we need to.

Demo: Working with Try-with-resources Part 2
Now, I've got one last method here. It's called just doCloseThing. You notice it's using this class called MyAutoClosable, and that's a simple class that I've written. If we take a look at that class, notice that implements AutoClosable, and it has a method on here, saySomething, that prints out the word Something, and then it has the close method that prints out the word close. And what I want to do is just going to demonstrate so we can see exactly what's happening here. Again, we have this try‑with‑resources where we create MyAutoClosable. We call to saySomething. We have a catch block, but there is no call to close. But if we head back up top here, I'm going to go ahead and comment out the the line to our doTryWithResourcesMulti, then uncomment out the doCloseThing. So now we run our code, let's see what we print out. So I'm scrolling back down here. Let's run it. And you notice it prints out Something, and it prints out close. And what that does is that proves to us that even though there's no explicit call to close in our code, close is indeed getting called. All right, now let's see what happens if we start throwing exceptions inside of here. So we go back to MyAutoClosable, and let's change this down here where we call close to actually throw an exception. So I'm going to go ahead and throw a new IOException. So I go ahead and throw that exception. I'll go ahead and comment this line out. So let's go back to our Main. Now remember, we don't actually call close anywhere here explicitly. Let's go ahead and run it. And notice what happens. We get the IOException ‑ Exception from close. So what that proves to us is that the catch block handles the call to close. So even though we never explicitly call close, the catch block we put in place still handles the exception that's being thrown by close. Now, let's look at one other situation. What happens is that in addition to close throwing an exception, what if I also throw an exception here from saySomething? So let's go ahead and throw an IOException from here. So we have that exception. I'll go ahead and comment out this next line. So what that means then is that when we run our code, we're going to actually end up with two exceptions, one from saySomething and one from close. When we run this, let's see what happens. Now notice that we see the exception from saySomething, but we don't see any exception from close. Now, does that mean we lost it? And the answer is no, we have it. What's happening is we have this catch block, and we're only printing out the one exception. But what happens is that if multiple exceptions occur, Java keeps track of those as suppressed exceptions. So what I'm going to do, I'm just going to add a new line here. We've got our exception, e, and there's a method on here, getSuppressed. And what that does is that will give me back any exceptions that have been suppressed because it only shows that initial one, but the other ones are captured in this collection for suppressed. So what I can do is I can put a for loop around this, say, Throwable t, and I get everything that's in getSuppressed, and that will go ahead and give me each of the exceptions that were suppressed. So inside of here I can go ahead and write out the suppressed exception. So now, in addition to writing out the one exception when we explicitly call it, we're actually writing out any suppressed exceptions. So let's going to run that. And so now we see that we got the IOException from saySomething, but also in that Suppressed collection we got the Exception from close. So what this shows us is that when we're working with try‑with‑resources, in order to get the full story, we have to look at not only the exception we actually catch, but any exceptions that might have been suppressed by calling this getSuppressed method.

Chaining Streams
When working with streams, we often chain streams together. And what we mean by that is that we have one stream instance leverage another stream instance. And we do that in general to create higher levels of functionality, so that we can have one stream take care of maybe accessing the data, and then have another stream take the results of that and then provide some greater functionality, do some processing with it and then present the data that way. This is a powerful part of reusability, because that way each layer is specialized on a certain job. But it doesn't worry about how the layer before it got to the data. Now the way we chain streams together is really just by using the constructor. When we construct the higher level instance of the stream, we pass in an instance of the lower level instance of the stream. Now, a good example of where chaining comes in is a class like InputStreamReader that's based on chaining. Basically, it provides reader behavior over an InputStream. In other words, it allows us to have data that comes in in a binary format and allows us to process it as character data. So Let's take a look at what it's like to work with streaming by taking a look at the InputStreamReader. So, if I go in here, let's say I have a function, I'm going to call it just doChain, and it accepts in an instance of an InputStream. All right, so it accepts an instance of a binary stream. And I want to do some character‑based work with it. So what I'll do is I'll declare the variables I need to work with a character‑based stream, with a reader. I'll have a length variable because the length of value coming back, and a character buffer. Well, now when I go and I create my InputStreamReader, notice that when I construct it, I'm passing in the reference to the InputStream. So I'm passing the reference to the binary stream into InputStreamReader. Now InputStreamReader doesn't care whether that InputStream is backed by a file, by the network, or anything else. It just knows that binary data is coming in, and it will convert it so I can work with it as character data. So in my program, I go ahead and just work with it like I would with any other reader. All right, just call read, passing in a character buffer, get the length back, and then work with that buffer. All right, so that's just this really powerful concept of chaining, is that we're just building one layer on top of another. Now one thing to note in the case here of InputStreamReader, we're using this in a try‑with‑resources. Well remember that try‑with‑resources automatically calls close on the resource. So it automatically calls close on reader. The thing to keep in mind is that the InputStreamReader class is defined so that when close is called on it, it also closes InputStream. So the InputStream itself is no longer open once the InputStreamReader is closed. And that's a common scenario when changing streams together, that closing the higher level stream closes the contained streams as well. Now this idea of chaining is very powerful, and so you should keep it in mind because we can create our own high level streams. Now, something to keep in mind is that InputStreamReader is kind of interesting because it takes a stream of one type, a binary stream, an input stream, and converts it to a stream of another type, right, a character stream or a reader stream. Most commonly when we chain streams together, they are streams of a common type. In other words, you chain one reader over another reader or you chain a writer over a writer. Because this pattern is so common, Java provides classes that simplify this process of creating specialized streams. The classes are FilterReader, FilterWriter, FilterInputStream, and FilterOutputStream. And what they are is that they are abstract classes that make it easy for us to provide specialization because they accept in a reference to another stream, and then all the methods on these classes simply call the contained streams methods. All right, so if you call close on a FilterReader derived class, it automatically calls close on whatever stream it's wrapping. What that allows us to do is focus on the customization that we want to provide. So we only have to override those methods where we want to do something different than the contained stream does. And so this is something we want to keep in mind is that as you're working with streams to get to your data and you provide your functionality, look for opportunities to creature your own customized stream to provide that higher level functionality, because it allows you to use that functionally easily in your program and also reapply it to data that comes from other stream sources. Now, one of the most commonly typed streams we work with are file‑based streams. And one of the most common type of chaining we use is buffered streams. So in the next clip, we're going to take a look at using file streams with buffered streams.

File and Buffered Streams
One of the most common uses of streams is interacting with files. We commonly want to read content from files or store content in the files. Now the java.io package has classes for each of the different stream types, a FileReader, FileWriter, a FileInputStream, and a FileOutputStream. Now it's important to understand that these javo.io classes are now deprecated, but we're going to touch on them just briefly because they're still very widely used in code. Just little bit later in this module, I'll show you the new way of interacting with the files, but let's just look quickly at using these javo.io package file streams. Now one of things we find though is that when we're interacting with files we generally don't want to interact with them directly. Often we want to go ahead and do something that's more efficient because interacting with files can be inefficient, particularly if you're interacting with that physical storage. So that's where the buffered streams come in. The buffered streams can improve efficiency of interacting with files because they buffer the content in memory. What that allows to have happen is, you can read content in large chunks, write content in large chunks, and that reduces the interaction with the underlying stream. Now we use the buffered streams most often with file‑based streams, but they're not limited to that use. That's one of the neat ideas of layer streams is, that you can buffer any kind of stream you want to. It's just files that where we most commonly see it. Now there are buffering streams available again for all four stream types, Reader, Writer, InputStream, and OutputStream, and working with them is really straightforward. If we take a look at some code, so let's say I want to go ahead and buffer around a file reader. So I'll go ahead and create an instance of the FileReader. I'm just passing in the file name that I want to interact with. And then I go ahead and just create a BufferedReader and pass the FileReader as a construction parameter. From there, I use the BufferedReader just like any other reader stream. So I'm going to go ahead and read it character by character. I have an integer value to receive the value of the read. I go ahead and do the read in a while loop. And then inside of there, I just get to the character values. There's no extra work from my standpoint, in terms of using the buffered streams. It's just important to go ahead use them especially with files to improve that efficiency. Now buffered streams are useful beyond just their buffering. Buffered streams are also intelligent about dealing with line breaks. And this is important because line breaks vary across platforms. On the Unix platform a line break is just a newline character, whereas on the Windows platform, a line break is actually a combination of a carriage return and a new line. If we had to do that on our own, we'd have to actually manage those characters individually in our own code. So the way buffered streams add line break support is, they do it by knowing what the correct value for the current platform is. So the BufferedWriter class has a method called newLine. When you call that method, it will write the appropriate new line for the platform. So in Unix we'd write just a newline character. On Windows we'd write both the carriage return and the new line. The BufferedReader understands the new line characters, and that allows you to read entire lines at one time with the readLine method, and it will pass the line back to you in a string. So we see how we use these. So we have some code here. And let's say we have a method here called writeData. WriteData accepts in an array, we're calling the data, that's just an array of string values. So it's got line 1, line 2 2, line 3 3 3, and so on. So what we want to do is go ahead and write that out to a file with each of those values on an individual line. So we go ahead and create our BufferedWriter, and then we go ahead and just loop through the values. And now if we just say bw.write, passing in that output string, what would happen is that we'd end up with all the values on a single line. So the deal with that, we could write the individual character out, the newLine character, but that would work well in Unix, but not on Windows, because on Windows we have to write both the carriage return and the new line, but then that would break the code of around Unix. So we address that by simply calling newline and then it writes the appropriate line break character for the platform. So with that, we then get each individual value on its own line. Now, once we have our content on individual lines, reading it back in is really simple. So we have a method here called readData. We go ahead and create an instance of our BufferedReader. We go ahead and declare variable to receive the line, and notice that this variable is a string, so we're reading the entire line as a string. So we have our while loop, and we call br.readLine. And that'll read the entire line, putting the value into the string. And notice that when using readLine it indicates the end of file by returning null, so we keep reading until we find null. So if we had our code just go ahead and print out each line that it read each pass through this loop, it would write the first line, second line, third line, fourth, and then fifth. All right, so this line‑level behavior is one of the real values of the BufferedReader. Beyond the actual value it provides by buffering, it lets us work at this line level, which is often very effective for the kind of things we'd want to do in a lot of applications. Now in the next clip, we're going to take a look at the new file I/O classes.

Accessing Files with the java.nio.file Package
Now we've touched on how to interact with files using types in the java.io package, but in any new code you write, you want to use the file types to come from java .nio.file package, because the ones that we touched on, the file reader, file writer, file input stream, file output stream, those are all deprecated now. I touched on them, because you will still find them in a lot of code, but anything you write it to do, you want to use these new types we're going to talk about in this clip. And the reason is that these new types provide a lot of benefits over the file types that are in the java.io package. Now thing I want to be very clear about. The only thing that's deprecated are the file types, right? Things like file reader, file writer and so forth. The general stream types like input stream, output stream, reader, writer, buffered reader, buffered writer, those are all still widely used. It's only the file types that are deprecated, and the reason is that these new ones again provide a lot of benefits. They provide much better error reporting. They also deal with large files and large file systems much more effectively. They have greater support for features of new file systems, things like extended security and file attributes, and they simplify a lot of the common tasks that are out there. Now, when we deal with these new packages, obviously we're going to have new types. Now the most fundamental type is the path type. That's used to locate something in a file system, and that can be a file or a directory, so that's kind of the programming object that represents those things that are in our file system. Now the way we get a path is by using the Paths class. The Paths class gets static methods for translating from the common representations of a file like the hierarchical path string or a URI into a path object. So say, for example, I have a file path like \\documents\\data\\foo.txt. I simply past that to the Paths.get method, and the reference I get back in this case, p1, is the representation of that file. Now what's interesting is that this get method, you can pass it a single string, like I have there, or you can actually pass it multiple strings with each of the file parts. So both of these Paths.get examples, one with a complete string and one with each part being a separate string, will actually referenc the same file system object. Now once you have a path, we can use those files typed to interact with those things. So basically a files type provides static methods for interacting with files. Alright? So you can do things like create a file, copy it, delete it, all those kind of things you want to do. And when it comes to interacting with streams, the files type actually gives us the ability to open up the file streams. So you can open a newBufferedReader over a file, or a newBufferedWriter, a newInputStream, a newOutputStream. And you notice that there's kind of a fundamental difference in behavior. In the java.io package, we actually created a file reader or a file writer. Here we're using much more of a factory method. We're actually using the files type and saying, hey, I need a buffered reader over this file, you get that back. Now it also provides convenience methods that let us do things like read or write a file in a single statement. So the readAllLines method will actually open a file, read all the lines in it, and then close it. The write method will open a file, write all the content out to it, and close it. Now, working with the new types is really quite simple. And so if I want to create a buffered reader over a file, alright? So I've got some method here; I want to go ahead and read through it, I go ahead and use my try with resources and notice what I do is I pass in the Paths.get over data.txt, otherwise, this gives me back the path that represents that file in the current directory. Files.newBufferedReader simply opens a buffered reader over it. So my br variable now give me the ability to read through it. And now I read through it, just as we've talked about, right? So I want to get back line by line, declare a variable. I have a while loop where I just keep calling readLine until we get a null back, where that liner read goes into that inValue, and then I can do something with it. But as I mentioned, there's also these convenience methods out there that allow us to work with files kind of in one step. So if I were to read all the lines in a file, I have some method to do that. Well, I could declare a variable here called lines, which is a generic type List over String. So in other words, it's a collection of string values, right? So if I simply say Files.readAllLines path into Paths.get, over data.txt, over to pass in a path that represents that file, that one statement opens the file, reads all those lines, closes it, and then passes it back into my lines variable, and I can then walk through that and do something with it. Of course, you want to make sure that it's not a huge file you're working with, because the file contents will actually have to fit in memory, but it very much simplifies that process of doing something we do all the time, which is open a file and read through it. Again, there's the write method that works very much the same. So in any new file system work we do, we want to use these new types here. Now, in the next clip, we'll see how we can use these new types to work with specialized file systems like you might find inside of a zip file.

Using Default File System and Zip File Systems
When we work with files from our Java program, those files are, of course, contained within a file system. Now, most commonly when we work with files we're working with a computer's default file system. But Java also supports the concept of specialized file systems, and as we work with specialized file systems they can be very different depending on what providers might exist, but probably one of the most common ones we see is the ZIP file system. The ZIP file system is the ability to create and read files contained within a compressed zip file. Now when we have a path instance, that path instance identifies a file and it's tied to a particular file system. Now the Paths class that we talked about earlier for creating path instances only works for the default file system. So we have to have some more general way of interacting with file systems and getting access to path instances within a file system. Now there's a couple of key types we use to do that. One is the file system type that represents an individual file system, and it contains the factory methods for creating path instances within that file system. Now the way we get a file system is by using the FileSystem class. It provides static factory methods for creating a file system, common when we open or create a file system, and the method we most commonly use for that is the newFileSystem method. But of course, we need some way to identify a file system. Now the way we identify a file system is by using URIs, Universal Resource Identifiers. And that's kind of this generalized way of identifying different resources, HTTP‑based URLs are one type of URI. Now the specifics of a URI for a particular file system vary greatly between different file system providers. One of the most common ones we work with is for the ZIP file system. Those were identified by the URI scheme jar:file. So if we look at this URI, jar:file:/jimwilson/data/bar.zip, that means that bar.zip is a file system contained within a directory, data, under the directory jimwilson. When we interact with a file system, each file system supports custom properties. Again, the specific properties vary depending on the file system provider. But there are a few common examples we see. Things like, well, when I access the file system, if it doesn't exist, should I create it? And when I'm interacting with it, what kind of stringing coding is being used in that file system? Now to get a sense of what it's like to work with special file systems, what we'll do in the next clip is programmatically create a ZIP file and then interact with files contained in that zip file.

Demo: Creating a Zip File System
Here in our program, in this program, we'll go ahead and create a ZIP file. Now a ZIP file is kind of interesting because the ZIP file itself is just a file in the default file system, but the contents of the ZIP file is a separate file system, it's a ZIP file system. So what we want to do is go ahead and programmatically go ahead and construct all that. Now one of the first things we have to do is specify the file that will actually be the ZIP file, there's, in other words, the file that we create in the default file system. Now all the work that we're going to do to create the ZIP file is in this method called openzip that I have stubbed out here. Now what we want to do is we're going to go ahead and call that from Main. So now to set that up, the first thing I'll do is declare variable called zipFs of type fileSystem, and then I'm going to ahead and call openZip, and I have to specify the path of the ZIP file itself. Again, the ZIP file is created in the default file system, so I'm just going to use Paths.get to do that. So now that Paths.get specifies a file called myData.zip in the default file system. Now, there's nothing special about that file until I go out and construct it as a ZIP file system. Alright, so what I'm going to do is go here to my openZip method, let's scroll down here, and in here we'll actually create it as a ZIP file system. Now remember that whenever we construct a file system, we can specify provider‑specific properties for that file system, so we'll do that here. Now the way we do that is by using a map, and the map is simply name value pairs. So let's go ahead and declare a map with a name of type string and a value of type string. We'll call it providerProps, and we'll implement it as a regular HashMap. So basically, we simply have a way now to store name value pairs. Now the only property we need here is a create property that we'll set with a value of true to say that basically if it doesn't already exist, go ahead and create it. So we'll do that by simply calling providerProps.put, and we're going to specify create as the name and true as the value. So now we have our properties. Now remember that when we set up our file systems, we do that using URIs. So let's create a URI variable named zipUri, and we'll go ahead and new up a URI. Now one of the things we have to specify is the scheme, remember, we said that with ZIP files, the scheme is jar:file. So we've got that scheme, and now we want to give it the fully‑qualified path. Now we had the path passed in in this variable called zipPath. So what we'll do now is take our zipPath, and we want to make sure that's fully qualified and formatted correctly for use in a URI. So what we'll do is we'll call zipPath, convert that to a URI, so we now have the path as a URI, and then we get the path back from that. Again, all we did there was say take the path that I was passed in, make sure it's formatted correctly as a URI with a fully‑qualified path, and for this last parameter, we'll pass null. So that now gives us the URI for a ZIP file system. So now the only thing left for us to do is go ahead and create the ZIP file system. So I'll declare a variable called zipFs of type FileSystem, and then we'll go ahead and take our FileSystems type and call newFileSystem. And then we pass in the URI and the properties. And then the last thing we have to do is simply return back the file system. So that does all the work to create the ZIP file system. We simply specified the properties that we wanted, got the URI for the ZIP file system, and then created it. So now in order to actually do the creation, up here in our Main, where we call openZip, whenever we open up a file system, we want to close that file system as well. We also, of course, need to handle any exceptions. So now we handle exceptions with a try block, and because we want to open and close it, we're going to use a try with resources. So I'm just going to wrap this in a try, and then we'll simply make it a try with resources there by putting it inside the parentheses. We'll go ahead and just catch all the exceptions for here, and then we'll simply write out the exception. So we have that there now. We go ahead, and we go ahead and call in to openZip, which will create our ZIP file system, go ahead and close it automatically, and we have our catch block there. So I'll just take a look at the file system where we're going to create this, and notice that right now we don't have a ZIP file in here. Right now, all I want to do is go back to the program. Let's put a breakpoint here right after we create the URI, and let's go ahead and run it. And so when we get here to the point where we're about to create the new file system, you can see here down in the variables, zipUri, it specifies jar:file, and then that fully‑qualified path all the way down to myData.zip in the default file system. Alright, so we'll go ahead and let this finish, and when we do, if we go here and take a look inside of our file system, we now have a ZIP file. Alright, so we've successfully constructed a ZIP file. So in the next clip, we'll take a look at how we can copy files into that ZIP file and create files directly within the ZIP file.

Demo: Copying and Writing Files to Zip File System
So now we know how to create our zip file, so let's look now at how we can actually first copy a file into the zip file. So I've got this file here, file1.txt. If I open that up, it's simply the letters A through Z. So let's go ahead and delete our zip file, go back to our program here, and what we want to do now is that we've got this method here copyToZip stubbed out that accepts the zip file system. So up here in our Main, we'll go ahead and call copyToZip, passing in the zipFS. So we have that there. So now let's go down here and copyToZip and we want to actually do the copies. Now, what we're doing is we're copying that file1.txt from the default file system. So, we'll first just get our paths for that. We'll declare a variable called sourceFile of type Path, and then what we want to do is take our Paths.get for file1.txt. So that gives us a path to file1.txt in the default file system. Now, what we also want to do now is get a path for a destination file. So this will be a path that points to the contents, or I should say, points within the zip file. So I want to declare a variable called destFile of type Path, and what we want to do here is go to the zip file system and get a path through the zip file system. So I'm going to say zipFS.getPath, and then this will be the path name within the zip file. So what I'm going to do here is say, I want to add the root, so I'll put a slash, I'm just going to say file1Copied.txt. Now, of course, I could name it anything I want, including file1.txt, but I just wanted to give it a different name so you could see that we could name it whatever we want to. So now one thing to notice here is that we're using paths to get things in the default file system, but for other file systems, we have to use the file system itself. Well, it turns out that's because paths is just a shortcut. Another way that I could actually get a path within the default file system is to actually use the default file system. So I want to go ahead and comment out this source file here. I'm going to declare another Path sourceFile, and what I can do here is I can actually say FileSystems.getDefault, and then now I've got a file system that represents a default file system, so from there, I could call getPath and pass in file1.txt. So that's kind of the longhand way of getting a path within the default file system. That Paths class simply gives us a shortcut, or I should say a shorthand for doing that. So I'm going to go ahead and comment out this one and go ahead and use the one we normally use. So now I've got both paths, the file that I want to copy, which is my sourceFile, which is in the default file system, and then a path for a file within the zip file system. So all I need to do now is go to the Files class, call the Copy method, pass in my sourceFile and my destFile, and then I have to pass in some options telling them what to do. And when I pass in an option, it simply says that, well, if there's already an existing destination file, replace it. So now if we head back up here to Main, all we're doing is creating the file system and then copying a file into it. All right, so if I go ahead and run this, and I go look at my file system, notice I've got my myData.zip, if I open that guy up, notice there's a file1Copied.txt, double‑click, and I've copied the file into there. So we see how easy it is to copy a file into the other file system. Now let's go ahead and delete our zip file again. Now, in addition to copying files into it, we can actually create files directly into the file system. So I've got a couple of methods stubbed out down here. Let me scroll down here. We've got a writeToFileInZip1 and writeToFileInZip2. Notice they take the zip file system and then a String array. If we go back up here to Main, I've got that String array. So what I'm going to do here in my try with resources is call each of those Write methods. All right, let's go down there and actually write out to the files. Now, so first in the writeToFileInZip1, let's go ahead and use just a regular BufferedWriter to do this. So we'll create a BufferedWriter within the zip file system. So I'm going to put a try with resources here, I'm going declare a BufferedWriter named writer, and then I'm going to my Files.newBufferedWriter, and then I'm going to pass in a path that points to a file within the zip file system. So I'll use my zipFS.getPath. So you notice that I'm not doing anything special to write into this alternate file system other than get a path within the file system. So I've got that all set up there. So I've got my try with resources, and so now I just want to iterate through the array, and then for each element in the array, I'm going to write it out and then put a new line after each one. So that's the way we've been writing out the files kind of up to now throughout this module, so kind of iterating through things and writing them out one by one. And you can see that works just fine with any of these file systems. But also, let me go down here to this writeToZipFile2, or I should say writeToFileInZip2. We can actually use one of the file classes to simplify that. Remember we said that the Files class has a Write method, so let's go ahead and call that. Now it wants the path, so we'll go ahead and put a path inside the zip file system. So we've got that path. We want write out the contents of the array called data, so we'll put that there. Then we have to give it some other information. We'll tell it what character set to use, we want to use the default character set, and also, we want to give it some options on what to do, so we're going to go ahead and say I want to use a StandardOpenOption of CREATE. So we want to say go ahead and create that file. Now, you'll notice that as we pass this in, we're actually getting an error. That's because the value that's written out has to implement the interface iterable, and the string array doesn't do that, but we can convert that string array to a list, which would then implement the interface. I'm going to call the Arrays class .asList method. And so that now converts that array of strings into a list of strings, which implements the required interface. All right, so we can write to the file using the traditional BufferedWriter, as we did into writeToFileInZip1, or we can take advantage of this Files.write method that does all the work of opening up the file, writing out the contents, putting the new lines in, and closing it. So we scroll back up here to Main, so we call each of our methods now, we go ahead and create the zip file, copy into it, and then write into it the traditional way and then write into it the new way. Let's go ahead and run this. All right, it completes. We look at our file system. So we go into our zip file. We've already seen the file that was copied, but let's look at our new file1.txt. All right, create it using a BufferedWriter, as we've talked about before, or a newFile2.txt, created using the Files.write. So we can see there that using the zip file system, we can do all the things we can do with the standard file system.

Summary
To wrap up, some of the key things we want to remember from this module, remember, we first looked at the java.io package, and that held all of our stream‑based I/O types, and it also had a legacy file and filesystem types. And those are the streams that were very tied to files themselves. We don't want to use those in our new code, but you want to be aware of them because there's still a lot of code out there that uses them. Then we looked at the java.nio.file package, and that had our current file and filesystem types. We saw a lot of examples of working with those. We talked a lot about working with streams. Remember that streams are an ordered sequence of data. Any given stream is unidirectional. It's either for reading from or writing to. Remember that streams are broken out into two general categories, either binary, or date oriented, and then character based, or Unicode oriented. Working with them tends to be very much the same. In other words, they have very much the same operations. They just interact with the content at different levels. Remember that streams can be chained together so that you can actually have one stream do some basic level of work and then chain it with another stream to add some higher level of work with it. We talked about try‑with‑resources. Remember that try‑with‑resources automates resource cleanup. It takes care of closing it down, and it works with any type that implements the AutoCloseable interface. We talked about a lot in terms of streams themselves, but a lot of different types work with try‑with‑resources. Then remember some of the key types we talked about. Remember, we had the Path type that locates a file system item, like a file or a directory. Remember that a path instance actually includes the file system. So when you get a path, it references none of the items within a file system, but the file system itself. So it's just the default file system or a zip file system. We had the Paths type, and that was really a convenience class. We had factory methods for creating path instances from the default file system. It just saves us from going through the kind of the overhead of kind of getting to the default file system and then getting to a path. Really about convenience. And then we had the Files type, and that provided methods for interacting with files. So we could create files, we could write to files, we could copy files, those sorts of things. And then the last types which we looked at were related to the file systems. So we had the FileSystem type, which represents a file system. And, of course, that can be the default file system. Or it can be a specialized file system, such as the zip file system. Remember, the file systems are identified by URIs. For example, the zip file system is represented by URIs with the scheme jar:file. And then, finally, we had the FileSystems type, which are just methods for creating and opening file systems. That's it for this module. In the next module, we're going to take a look at string formatting and regular expressions.

String Formatting and Regular Expressions
Introduction
Welcome to the next module of the Pluralsight Java Fundamentals: The Core Platform course. This module covers string formatting and regular expressions. My name is Jim Wilson. In this module, we'll start out by looking at the need to move beyond simple string concatenation to build strings. We'll then look at how we can easily combine sequences of values using the StringJunior class. We'll then look at the power of creating strings using format specifiers. We'll look at how we can use format specifiers to write formatted content directly to streams. We'll then talk about using regular expressions for pattern matching. We'll look at the regular expression capabilities of the string class, and then we'll finish up by looking at those classes that are dedicated to regular expressions.

More Powerful Solutions to Creating String Representations
Strings give us a universal way to represent information. If we can assemble things into strings, we can do things like display them in web pages, send them out across the network to communicate between apps, display them inside of our apps. So we very often need to take multiple values or individual values and then assemble them into a string somehow. And, of course, we know that the Java language itself allows us to do that using things like concatenation and so forth. But often we need more powerful ways to create strings than just simple string concatenation because concatenation itself is really not enough. First of all, it's very focused on creation details. You basically have to kind of do every step to put things together. Also, numeric conversions can be really awkward,putting separators inside of numbers, representing currency, dealing with numbers with decimal places. Those things are kind of pretty awkward to do if you have to do them manually. And even the StringBuilder class doesn't really help with those issues. There might be certain efficiencies with the StringBuilder, but it doesn't make these details of creation any easier. So we need something that's more powerful, and we're going to talk about two options for creating string representations throughout this module. In the next clip, the one we'll look at what's called StringJoiner. StringJoiner is designed to simplify the concept of creating sequences of values and then representing them as a string. And then after that, we're going to look at string formatting, the idea of using format specifiers to actually closely control the way data is represented. And this is really powerful because it allows us to focus on how we want things to look without dealing with all the creation details.

Joining Sequences of Values with StringJoiner
The StringJoiner class has a very specific purpose in life, and basically, it's designed to simplify the process of creating a string that's comprised of a sequence of values. And it's really easy to work with. The first thing we do is we go ahead and construct our StringJoiner, and this is really where all the setup occurs. You basically give it what the value is you want to use to separate your individual values, and you can actually optionally specify a starting and ending value as well. Once you've done that, now you just go ahead and add your values and then finally just retrieve back the resulting string. All right, so take a look at this in code. We'll go and create a StringJoiner, and we're going to specify that we want our separator to be a comma and a space. We then go through an add our values in, so we add in the value alpha, the value theta, the value gamma, go ahead and call toString, and then the resulting string is alpha, comma, space, theta, comma, space, gamma. Now, in order to make it easy to work with when we're dealing with sequences, we can also chain method calls when we're dealing with the StringJoiner. And this is a very common pattern we see in Java. All right, so we go and we create our StringJoiner instance. And if I want to say sj.add("alpha"), and I want to go ahead right away and add another value, well, add returns back a reference to the StringJoiner. So I can say .add("theta").add("gamma"). And then go ahead and get my result string back, and I get the same results. So any time you're dealing with a sequence of calls like that, we can chain them very easily. As we mentioned, the StringJoiner also allows us to specify starting and ending values. So if I go ahead and create my StringJoiner, of course, I pass in my comma space as the separator, I can also say that I want a curly brace to be the opening value and then a closing curly brace to be the ending value. I can then go in and add in all the values, and when I call toString, I get back the string. But now it has the opening curly brace, each the values separated by comma space, and then that closing brace. And this allows us to do some really powerful stuff. If we get creative and we kind of start thinking about the opportunity here, think of a case like this where we want to have all the values with each value enclosed in square brackets and then a comma space between them. Well, if we look at it as a closing square brace, comma, space, and then opening square brace are the separators, so we'll go ahead and create it with those as the separators, and then our opening value is the first opening square brace, so we go ahead and specify that, and our ending value is the last closing square brace. When can go ahead and specify that. And then from there, we go ahead and add in all of our values, and then we called toString, we get our string back. So it allows us to really handle most situations we're likely to encounter when we're trying to just build a string composed of a sequence of values like this.

StringJoiner Edge Case Handling
Now StringJoiner also does a really good job of handling what we'll call the edge cases. So what about the case when there's only one value added? Well, if you only add one value, if you constructed it with a separator only, then you'll get back just the value added. If you construct it with a separator and starting and ending values and you add just that one value, you'll get back a string with that single value enclosed in the starting and ending strings. All right, so if we look at that in code, basically, we go ahead and construct our StringJoiner. In this case, we have just a separator. It's a comma space. We add just alpha. When we called toString, we get back the string alpha. Now, if we construct our joiner with the separator comma space, plus opening and closing curly braces, if I add just that one value, I get back that one value enclosed in the opening and closing curly braces. But now, what about the edge case where there are no values added? Well, if we construct it with a separator only, what we will get back is an empty string. If we constructed our joiner with starting and ending strings included, then what we'll get back is a string containing just the starting and ending values. So to see that in code, so I'll go ahead and construct my joiner with just a comma space separator. When I call toString, I get back the empty string. Construct it with the separator and opening and closing values, when I called to string, I get back a string with just the opening and closing values. Now, often that may be exact behavior you want, but there might be other cases where you want to do something special in the case of no values. And you can actually do that. You can customize the empty case handling. So what we can do is we can specify a special string to return in the empty case. We do that by simply calling setEmptyValue and specifying that string. The thing that's important understand though is that in the case of the StringJoiner, a joiner is considered empty only if the add method has never been called. So let's see what this means in code. So let's go in here first, and we'll go ahead and construct our StringJoiner with a comma space separator. I want to set my empty value to be all capitals the word EMPTY. Well, when I call toString without adding anything, I get back that string, EMPTY. Now if I construct a StringJoiner with opening and closing values, and I set the EMPTY value, and then I called toString without adding anything, it's the exact same behavior. So the setEmptyValue specifies the exact value to return if nothing has been added. It doesn't matter if you specify opening and closing values or not. But to reinforce what I mean by empty, or I should say to reinforce what StringJoiner considers to be empty, that's only if add is never called. So if I construct my StringJoiner here to have the comma space separator, I setEmptyValue to be the word EMPTY, but then I call add with the empty string, so just quote, quote with nothing in between. If I call toString, I get back what was added, which is an empty string. So that means the StringJoiner is not considered empty. It had a value which was the empty string. So now if I construct my joiner to include starting and ending values, I set an empty value, and then, again, I call add with the empty string, when I call toString, I will now get the opening and closing values with an empty string between them, basically nothing between them. So it's important to understand that StringJoiner allows us to specify a special value in the empty case, but the empty case means add was never called. So if you want to exclude empty strings, you want to make sure you actually do that in your code and and not add them in the first place. All right, so we can see the StringJoiner is pretty powerful when it comes to this idea of composing strings made up of a sequence of values. But in many cases we need more sophisticated string construction capabilities in that, and that's where format specifiers come in, and we'll start talking about those in the next clip.

Constructing String with Format Specifiers
When we construct a string using format specifiers, our focus is on describing the desired result. We focus on what we want things to look like. We're not concerned with the details of how we actually construct those values to appear that way. And format specifiers give us a lot of control over how things appear. We can control positioning of how a value is displayed, how many decimal places are shown, even the representation. So if you have an integer value, do you want show that as a decimal value, as an oct value, or as a hex decimal value? Or if you have a floating point value, do you want to see it as traditional floating point format or do you want to use something like scientific notation? So it gives us a lot of control. And format specifiers are pretty widely supported. There are a number of different methods that support them. The one we use most commonly is the format method on the string class. But we can even do things like system.out.printf. It allows to write to the console using format specifiers. There's even a Formatter class that allows us to apply formatting to other types of media. And we'll see an example of that a little bit later in this module. So let's see an example of using format specifiers. Let's say that I've got a little program I'm going to write, and I want to display the ages of my nephews. So I've got four integers declared here to show the ages of each of my nephews. And the string I want to display is My nephews are 13, 11, 4, and 2 years old. So I want to have this string, and I want display the value of each integer field there within that string. Now I can, of course, do this with string concatenation. So I declare a string and I start out with "My nephews are " space inside the quotes there. Then I concatenate David's age onto the end, and then I concatenate comma, space, then I concatenate Dawson's age, then comma space, concatenate Dillon's age, along with space, comma, and, space, and then, finally, Gordon's age and years old. That will give me that string. But you can see as something gets more complicated or as the values we're building get more complicated, we're kind of really trapped in working with all these details. We want to think at a higher level than that. Using string formatting, we can do a much better job here. I'll go ahead and clear my string. I'm going to call the String.format method, and I'm going to give it a single string value that is the model or the formatting information for the output string I want to create. My nephews are, then I have these %ds there for each of the values I want to substitute. So I can lay out the entire string, but then have placeholders for the values I want to substitute. And then I can simply list each of those variables, David, Dawson, Dillon, and Gordon. And that will give me that same string. So it allows me to focus again on what I want to produce, not the details of how I produced it. And in addition to that, formatting gives me more control. So I've got these same four integer variables, but say I want to go one step further. I'm going to calculate out the average age difference for each one of them. So I find the difference between each of the variables and I divide by three and that gives me the average age difference. So now using string concatenation, this is pretty simple. I'll clear my string. So "The average age between each is " with a space there. I then concatenate on the value of avgDiff and then years onto the end. Now that was really simple to write, but what's my output look like? Well, the average age between each is 3.6666...5 years. Now that is a correct answer, but that's generally not how we want things to appear. We only want to show kind of enough decimal places to provide reasonable information. So if I use formatting, so I'll call String.format, I'll say, The average age between each is, and I now use this %.1f years, so now using format specifier and identifying how many decimal places I want to show. So I go ahead and put a avgDiff there. And so the output value now is The average age between each is 3.7 years. So I've got something more reasonable. I'm explaining information in a way that's useful. So if we look at these format specifiers, and we saw kind of two examples here, one where we said My nephews are and we listed each of the ages with the %d, and then The average age between each is, and we put a format specifier with the years. And so if we look at each one of these, the first one, the %d, that's kind of really the minimum format specifier. All format specifiers start with a percent sign and then they have what we call the conversion. It identifies how we want the value to be shown. But we know that we can have more than that. Obviously, we've seen that. So if we look at the other example, we saw that we had that percent sign to say we had the format specifier start. Our conversion, in this case, is f for a floating point value, but we could also include information on how many decimal places to display. So with that in mind, let's see what all of our options for what we can put in format specifiers are. And as we mentioned, the minimum format specifier is a percent sign to start it and then the conversion you want to apply, but then there's a number of other things we can actually mix into this to provide further information. As we saw, we can put the precision, which identified the number of decimal places we wanted to display. But something else we could put in there that we haven't seen an example of yet is the width. The width identifies the minimum characters to display. So if you say I want to give this four characters of width and I only have two characters to display, then it will actually space pad it with the value right‑justified. But we can go even further in terms of controlling the display. There are things called flags that'll also specify further rules. And then something called an argument index that identifies how we want to associate format specifiers with the individual values. And we'll go into each of these in more detail in the upcoming clips, starting with conversion in our next clip.

Common Format Conversions
Let's take a look at some of the most common format conversions we have available. Now one we've seen already, which is the d conversion, which is called a decimal conversion, and that works with integral types. That means things like the int or integer or short. And so if I have an integer with a value of 32 and I apply the %d as part of a format conversion, I'll get back a value of 32. That certainly makes sense. Now, another one we have is o for octal. Again, it's an integral type. And so if I have a format that uses the o conversion, so format %o, and I have an integer with a value of 32, it'll display the value 40, indicating that 40 is the octal representation of the decimal value 32. We have a hex conversion, which can be a lowercase or uppercase X. A little bit later in the course we'll see the difference between using lowercase of uppercase. Again, it's integral, so I have a value of 32, and I show that with a %x, I'll see the value 20 because the decimal value 32 is 20 in hex. So now we have f, which is decimal conversion for floating‑point values. And so I have a floating‑point value 123.0, 123, will display as 123. and then all the zeros after it. And it can work, of course, with the float type double, that sort of thing. We also have another floating point we see here, the e lowercase or uppercase, which is scientific notation. So the value 123.0 is shown as 1.23, bunch of zeros, e+02. What that means is 1.23 times 10 to the second power. Basically, move the decimal place two places to the right. And the last one we'll look at here is s, which is our string conversion. It's type is general, which means it can be applied to a number of different types. And so, of course, if I have a string, Hello, well, the result is going to be Hello. That's simple enough. But the s conversion is actually pretty powerful because I can also pass object instances into it that are not strings. So if I pass an object instance and associate that with a %s, if that class implements the interface Formattable, well, what happened is the Formattable.format method will be called, and whatever value that returns will appear in the resulting string. Now, if you pass an object instance that does not implement the Formattable interface, well, then I'll just call the toString method on it. So you can see that these conversions can be quite rich in terms of their behavior. Now the ones we've just going over, as I mentioned, are some of the most common ones. There's a longer list in this available. A little bit later in this course I'll give you some URLs. We can get more information and get that complete list. But in the next clip, we'll take a look at the flags that are available for formatting.

Format Flags
Flags allows to enable specific formatting behaviors, and we'll look at each of the flags. The first we'll look at is the hashtag. The hashtag, it simply says that we want to include the radix when we display the value. In other words, we want to display something that indicates the base of the number being displayed. All right, so if we look at values here when we format them, %d for value 32, of course, is 32. %o for octal means that when you display 32 in octal you get the value 40. And then %x, when you display the value 32, well, in hex, that's the value 20. Problem here is that there's nothing to tells you that that 40 is octal or that 20 is hex when you see this written out, and that's where its use will be able to display the radix, an indication of the base. So if I display with the format %#o, I said I want to show that in octal showing its radix. And the standard way we do that is we lead it with a 0, so 040 indicates that it's the octal value 40 versus the decimal value 40. If I use the %#x for 32, I want to show the radix in that, so I use 0x20 because that's the standard indicator we use for hex values. Now remember I mentioned earlier that for hex values we can use lowercase x or uppercase X, so if I do the same thing then with uppercase X, the difference is the displayed value uses an uppercase X and the radix. So we're simply using the same case as the case of the format conversion that we used. So now some other flags we have, 0 says to zero pad the value and hyphen says to left justify the value. These two flags, 0 and hyphen come into effect when we specify the width of a value we'd like to display. So I go out here and I have a format string that I use a label like W:, just characters we're as a label, with %d X: and %d. When I write that out, of course, the labels W: I've written out literally. But then as I format them, I get my values 5 and 235. Now let's say I have a series of values like this and I'm using fixed‑width font. Well, if I now print out 2 more values, like 41 and 12 with their own labels, the alignment's all messed up because the number of characters being used to display this are changing based on the length of the number itself. So that's where specifying the width comes in. So now when I write these out, I use %4d. What that says is that I want to use a with of four characters. ao the output comes out W: 5, and then the x is X: 235. So when I write out the next values, they align up correctly on the right, and that works well by just specifying the width. But maybe I don't want everything to have spaces on the left. Maybe what I want to do instead is have everything have all zeros. For example when I'm printing out a code, and I want to show all the digits. Well, by using the flag 0, When I write those out, I now get W:0005 X:0235. When I print out the next values, again everything lines up with zeros on the left. Now maybe I want everything to line up correctly when I'm using a fixed‑width font, but I have the values directly against the colon. What I can format with is %‑4d, says that I want the width to be 4, but I want to value to be left justified. So when I get done, I get my W:5, the spaces, X:235. When I get the next values, everything lines up, but they're now left justified within their fields. So now one of the important ones that often comes up is including a group separator whenever we have numbers. And that's where the comma flag comes in. All right, so if we look at something like here where we print out %d for this number 1234567, well, if I just print that out, well, if this is actually a numeric value, we're used to seeing these things grouped. So if I use % , d when I write that out, I'll now get 1 , 234 , 567. Of course. I can do that with floating point values as well, so if I print that out, the floating point values are grouped, and I can specify the precision, the decimal places. There's a version of the format method allows you to indicate you want localization to be applied. To use that version, you can still use the comma flag to indicate formatting, but it will use the appropriate grouping for the localization value you have. All right now the last set of flags we'll look at have to do with working with positive and negative numbers. So the first flag is the space flag, which says that, well, when I write out a positive number, I want to leave a space for where the sign would be. If I use the plus flag, it says to always show the sign, so a minus for negative, plus for positive. If I use the left paren flag, it says to show negative values within parentheses. So to see how this all works for us, if I print out the value 123 with simply %d, I get 123. If I print out ‑456 with that same format, I get ‑456, but of course, the issue is that they're being kind of pushed to the left here, so that the numbers don't really line up properly. So if I was using a fixed‑width font, I'd probably want the right edge of these numbers to line up. So that's where I use the space flag, so % d. So in the positive number, it writes out an initial space where the sign would be, then 123. But when I write out a negative number, writes out just as it did before, but now they line up correctly. If I want to always see the sign, I use %+d, so the positive numbers +123, the negative numbers just like it was before, ‑456. But now the left paren flag, well, positive number is unchanged, so 123, but of course, my negative number is enclosed in parentheses. But now here's interesting situation is that the values don't really line up quite right. I'd really like to have the 3 still line up over the 6. Well, I can then combine the flags. So I use the format % (d. Well, space says leave a space where the plus sign would be for positive numbers, but then enclose negative values in parens because of the paren flag, so that now lines them up correctly. The space flag applied to the positive number. The paren flag applied to the negative number. So now in the next clip, we'll look at the last part of format specifiers, which is the argument index.

Argument Index
The last one of the format specifiers is the argument index. The argument index allows you to identify which argument value you want a particular format specifier to be associated with. Now, the argument index that I use most often is no argument index it all. Basically, that means that the format specifiers correspond sequentially to the argument values. The format specifier goes with the first argument value, second with second, and so forth. You can specify a specific argument index. If you use the dollar sign and an index value, that now says that that format specifier goes with the corresponding value. And you can also use a less than symbol as the argument index which says that I want this format specifier to correspond to the same value that the previous format specifier did. All right, so let's see what this looks like in code. So I've got a format string here where I just say %d, space, %d, space, %d. There's no explicit argument index. So the first %d goes with the first value, second %d goes with second value, the third %d goes with the third value. So I get out 100, space. 200, space, 300. Far and away, this is the way I most commonly write format strings. But I can put that explicit index in. So if you notice here, I've got %3$d, which says the first format specifier goes with the third argument value. So the next one, first value, and the one after that, of course, goes with second value. So I would actually get out 300 100 200. Now, obviously, this can be misused and abused to make code really hard to read. Where it does come in handy is when you have really long, really complex format strings where it's not easy to see which format goes with which value. So it's available to you. Just be careful how you use it. And the last one, you see we've got a %$2d, which says I want the first format specifier to go with second value, to the one after that %<04d. It says I want this to be applied to the same value that the previous one was. So the output here is 200 0200 100. The first format specifier explicitly said it wanted to go with the second argument value to 200. The one after that says I want to use the same one, so it still used the 200. The less than symbol is useful when you have a single value that you want to write out multiple times, generally with different formats. So that's there if you need it. All right, so that really wraps up the details of the format specifiers. In the next clip, we'll finish up our discussion on formatting and using format specifiers by looking at how we can use the Formatter class the write formatted content to a string.

Writing Formatted Content to a Stream
To wrap up our discussion of formatting, let's look at how we can use these formatting capabilities to move beyond simply building formatted strings to actually writing formatted content directly out to a stream. There is a class called the Formatter class and the Formatter class provides formatting capabilities, it uses the same specifiers as string.format does, in fact, it actually is the class that string.format uses under the covers. What the Formatter class lets us do is write formatted content to any type that implements the appendable interface. Now one class of that implements the appendable interface is the String Builder class, but another important class that implements the appendable interface is the Writer Stream class. Since that implements the appendable interface, we can actually use a Formatter class to write formatted content directly out to any class inherited from the Writer class. So we take a look at that in code. Say I have a method here called DoWrite and we want to actually write this formatted content based on the ages of my nephews out to a stream. So what I'll do is I'll go ahead and create a regular BufferedWriter, right, I create it just as I normally do, and what I can do now is create a formatter over that writer. And so, anything I write to the Formatter class will go out to that stream. So if I do things like write my nephews ages out using an f. format or write their average age out using again the f. format, that all gets written directly into that file. Now a couple things to notice here, I've got my formatter created inside of a try with resources, which means that the formatter will automatically be closed at the end. Notice that the BufferedWriter is not in the try with resources, that writer still gets closed because the formatter automatically closes whatever it's wrapping, as long as that class implements the closable interface. So we have here now is the ability to bring formatted content out to the stream, as well as have that stream onEvent could close when we're done with the formatter. Now, in this case were using a file stream, but this, again, will work with any writer stream. So imagine if you had a network‑based stream. You could actually be writing HTML content directly out to that stream using the formatter and get all the advantages of these format specifiers. To finish up, to get some more information on formatting the place we'll really get the details on the formatting specifiers is actually the Formatter class. That gives us the detailed specification of all the format specifiers. There is a URL to find information on that. Another thing you want to be aware of is that Java 8 introduced some interesting date formatting capabilities. So if you want to check out more on date and time formatting, check out the Pluralsight course, What's New in Java 8, and it goes over that in detail. Alright, so now in our next clip, we'll start looking at using regular expressions to actually find content inside of strings.

String Matching with Regular Expressions
Let's take a look now at regular expressions. Now, regular expressions are a very powerful pattern matching syntax. Now the topic of regular expressions is a very big topic and well beyond the scope of this course, but a little bit later in this module I'll actually give you some pointers to some places you can learn about regular expressions. They're very well covered from a lot of different resources. The main thing to understand is that regular expressions provide a way for us to find or exclude groups of characters. They can be things very simple, like the regular expression a, well, that matches the letter a. The regular expression xyz matches the sequence xyz. But they can be more involved than that, like the regular expression \w+. Well, \w says match any word character, which is a letter, digit, or underscore, and the plus says match one or more occurrences of it. Things like \b says match on a word break. And it can go way, way beyond this. And again, if you want to do a lot of work with regular expressions, you want to look at other resources for how to use those. The thing we want to focus on here is what is Java's support for regular expressions? And there's really kind of two levels to that. One is that there are some methods on the String class that work with regular expressions, but there's also some dedicated classes for working with regular expressions. In the next clip, we'll look first at the methods on the String class.

String Class Support for Regular Expressions
The string class provides several methods that support regular expressions. We have replaceFirst and replaceAll, and those methods basically allow you to return a new, updated string based on an existing string. In that case, we give it a pattern, and that pattern identifies what parts of the string you want to change. The split method allows you to split a string into an array of strings. In that case, we provide a regular expression pattern to identify what separator we want to use between the values, in other words identifying how we want to split the string up using a regular expression. And then we have the match method, which identifies if a string matches a particular pattern. So let's take a look at these guys in code and see what they're like to work with. So first, let's take a look at replaceAll. Let's say we have a string here that simply says apple comma space apple space and space orange space please. And let's say we want to do something like change the word apple to the word apricot. Well, we know apple ends in p‑l‑e, so what we might do is do a replaceAll of p‑l‑e with r‑i‑c‑o‑t. Replace that with r‑i‑c‑o‑t to create apricot. Now s1 would be unchanged, but s2 we get to change string. So now when we call replaceAll, the regular expression will change the two apples to apricot, but, of course, the word please also starts with p‑l‑e, so we end up with that kind of weird word at the end there. So we really want to do is change the occurrences of p‑l‑e that occur at the end of a word or just before a word break. So we can use a regular expression like this where we replaceAll ple. From a regular expression standpoint, we want to say \b to indicate word break, but because in Java the slash is an escape character, we're going to have to say \\b. So that's the regular expression, ple\\b. In other words, change all occurrences of p‑l‑e that occur just before a word break to r‑i‑c‑o‑t. That then gives us apricot, apricot and orange please. If I look at the other methods on the string, we'll look at split and match, let's take that same string, and what we want to do now is just print out all the words inside of that string. So the first thing we want to do is break it up into all of its parts. So what we'll do is we'll create an array of strings using the split. So what we want do is we want to create an array of strings based on word breaks. So what will happen now is that the first word break is dealing with the word apple. So as we build the array called parts, the first entry is apple. The next word break is just before apple, so it adds the comma space to the array. Then we get apple space and space orange space, and then please, right. The word breaks for the split. And so we got all the all the words and all the characters between the words. So now to print out the words, we want to walk through this and just find just those that are words, right. So we'll go ahead and loop through the array, and what we'll do is we'll use the matches method. So what this will say, now the matches of \w+, again, we're saying slash slash because in Java, again, slash is an escape character, \w says a word character, plus says one or more occurrences. So basically, if this string is composed of one more occurrences of word characters, then will be a match, and in that case we'll print it out. Right, well, the first characters are apple a‑p‑p‑l‑e. Those are all word characters. So we'll go ahead and print out apple. The next spring has characters comma space, they're not word characters, so we skip to the next one. Again, we know apple matches. Space is not a word character, so we don't print that one out, and matches we print it out. Space, no. Orange, yes. Space, no. And then, please, yes. All right so we get those characters out. So you see how that these regular expressions allow us to do things that would be kind of hard to do manually in strings. Let's do it now just by specifying what we want to have happen, or I should say what patterns we want a match on. Okay, now the next clip, we'll take a look at some of the dedicated regular expression classes.

Dedicated Regular Expression Classes
Something that's important to keep in mind when working with regular expressions is that the compilation of a regular expression can be very processing intensive. What I mean by compilation is when the system has to determine how to apply a particular regular expression because regular expressions can+ be very, very involved in some cases. And, of course, the concern is that we're using the toString method where we kind of use a regular expression that just gives results back, that compilation has to be done each time you call the method with a regular expression. You're going to do a lot of work with particular regular expression, particularly complex one, it'd be nice if we could leverage that compilation work that we've done once over and over again. And that's where the dedicated regular expression classes come in. We've got the Pattern class that allows us to compile a regular expression, and then it will create an instance what's called a Matcher class based on that pattern. What the Matcher class will then do is apply that compiled expression to a particular string. Alright, to see what that's like to work with, let's save some code here, and let's use that same string we were working with in a previous clip, and we want to do again is print the words out. Well, what we can do here is take our Pattern class, has a static method called compile, we pass it the regular expression that gives us back an instance of the Pattern class that has the compiled information about that regular expression. Now we can use that Pattern class to then create a Matcher that now there's how a Matcher gets its strings. What this says is create a match er that uses that compiled regular expression information to do work on the contents of value1 string, and I can create multiple matchers from this 1 pattern instance. So now to print out the words, what I can do now is I can say match er, I want you to find the first grouping that matches that pattern. Well, we're using \w+, which is a sequence of one or more word characters, so it finds apple, that's the grouping, and then we can call the group method to get back those characters. So when we print out matcher.group, we get apple. When we call find again, it will match the next set of matching word characters, which is the next apple so we print that out. We call find again, the next grouping of one or more word characters is the and, print that out, then orange, print that out, and then please, and print that out. And so these classes allows you can do that competition once, and then leverage that work over and over again. For more information on working with the regular expression syntax, a couple ways you can start is the documentation for the Java Pattern class. It actually provides a good overview of the regular expression syntax and there's a URL there for where you can find that. The Java documentation also includes a tutorial on regular expressions. I give you the URL for that there. And also, there's a lot of information out there on regular expressions. You can just Google regular expressions. You'll find lots of other matches as well, as well as a number of good books. Now, like anything now is that the only real way to know something works well is to be able to test it. So there is an interactive regular expression console available at this URL, and basically it allows you to type in your regular expression, give some examples strings, I should say, give some test strings, and it'll tell you what it matches or not. That slide also includes a quick reference on the regular expressions syntax.

Summary
To wrap up, some of the key things you want to remember. Remember we started talking about the StringJoiner class, and that simplifies the idea of combining a sequence of values. Now it's really easy to use, construct an instance of it, identifying your value separator. You can optionally include starting and ending strings to go around that resulting string as well. And then from there you simply add all the values you want to add and retrieve back the string that's produced. Remember that you can specify a special value for when it's an empty StringJoiner, but remember that empty means that no values were added, adding an empty string is actually considered adding a value. Just remember to keep that in mind. Then we looked at format specifiers. Remember, format specifiers allows to focus on describing the desired result, not how we get there. Format specifiers are made of multiple parts. You have the percent sign, which indicates that you're starting a format specifier, you have the conversion you want to perform, which are things like do I want it to be decimal value and octal, do I want it to be a floating point with decimal values. Those two parts are required, the percent sign and the conversion. Then we have some optional parts with precision, which is how many decimal places you want to show. Flags allow you to customize aspects of the display, like do you want to use number grouping, do you want to left justify things. And then you also have an argument index, which will allow you to control which format specifier goes with which value. Now the string class supports format specifiers through the format method. But remember, there's also the Formatter class that allows you to write formatted content to any class that implements the Appendable interface. And then we finished up with regular expressions. Remember that regular expressions are a powerful pattern matching syntax. Now the String class has support for regular expressions, so you have to replaceFirst and replaceAll methods that lets you create a new string based on matching a pattern. The Split method allows you to display a string into an array of strings based on the pattern. And then the Match method will tell you if a given string instance matches the pattern. But, keep in mind that we also have the dedicated regular expression classes, because remember that the idea of compiling a regular expression can be expensive, so it's nice that we can reuse that compilation effort if we need to. So that's where the Pattern class comes in, and it allows us to compile a regular expression. And then we have the Matcher class, which allows us then to apply that compiled pattern against a string value. Okay, that's it for this module. In the next module, we'll talk about Java collections.

Working with Collections
Introduction
Welcome to the next module of the Pluralsight course Java Fundamentals: The Core Platform. In this module, we're going to talk about working with collections. My name is Jim Wilson. Now, in this model, we've got a lot of great stuff to cover. We'll first take a look at the role of collections in our applications. We'll talk about the issue of collections and ensuring type safety. Look at some of the most commonly used collection methods. Take a look at how the issue of equality of the entries in collection is handled. We'll take a look at some of the features that were added to collections as part of Java 8. We'll look at how we can convert between collections and arrays. Look at some of the most commonly used collection interfaces and classes. We'll then look at how certain collections deal with sorting behavior. And then finally, we'll wrap up by talking about map collections, also known as dictionaries. Okay, so let's get started.

A First Look at Collections
When we build our applications, something that we very commonly have to do is manage groups of data. Imagine if you're building an application to manage passengers on a flight, well you'd have to have a group of passengers for that flight. Or if you're building a social media app, you're going to have to have groups of messages. So we need a way to store these groups of commonly typed data. The most basic way to do that is to use arrays. And arrays work well for simple cases, but arrays do have some limitations. Probably one of the biggest ones we encounter is that arrays are statically sized. So when we create an array, we have to make sure we have enough room for everything we want to store in it. Or if we do run out of room, we end up having to do the work to create another larger array and copy things over. Also, arrays rely on explicit position management. In other words, if you put something into position 0, when you go back to position 0, what's going to be there is whatever you put there. If you want to any kind of higher‑level stuff like sorting or other things, you have to kind of do that more explicitly. So what it comes down to is that arrays are really little more than a bunch of values. Now that doesn't make arrays bad. It just means that they're limited in their usage. And sometimes we need something more powerful than arrays, and that's where collections come in. Collections provide a more powerful option for managing groups of data than is available with arrays. Now, basically, all a collection is is something that can hold and organize values. And so fundamentally, they are conceptually very much like arrays. They're iterable. So you can actually walk through what's in a collection. Collections can provide type safety. So just like you can you have an array of a particular type, you can have a collection of a particular type. But probably one of the most fundamental benefits of collections is that they tend to dynamically size. So you can just keep adding things to them, and they'll get bigger as they need to. Now there are a wide variety of collections available. Now most simply, a collection can be just a list of values. So again, kind of think of it as an array that just gets bigger as you need it to, and that alone is certainly valuable. But collections can provide a lot of optimization or sophistication because there's a lot of different kinds of collections. So some collection types provide ordering. They may automatically sort things for you. Some collection types will prevent duplicates. Some collection types allow you to manage things as name/value pairs. So you can put things in there and then go back and get them back by their name, a concept often known as maps or dictionaries. So collections are kind of this generalized concept with lots of different specific types of collections. Now look at some really simple code that uses a collection. Let's say we're going to have a simple collection here. It's just a collection of objects. So I'm going to declare a collection called an ArrayList. And as its name sounds, it basically acts like an array. But it is a collection, so it gets bigger. Now notice as we declare this ArrayList, we're not saying anything about the type that holds, which makes this an ArrayList that holds the type object, which is pretty much all class types inside of Java. So I can do things like just add in the string Foo, add in the string Bar. And notice when I declared the ArrayList, I said nothing about size. So the ArrayList is getting bigger as it needs to. At any point, I can ask the ArrayList how many elements are inside of it by calling the size method. So this would tell me there are two elements inside of there. As I mentioned, it's iterable. So I can do a for loop over it and then write them out. But a couple things. Because this ArrayList doesn't have a type associated with it, it's an ArrayList of objects. So the return type here is Object. And so if I want to get to the string value inside of it, I'm calling the toString method on there. Now just as a note here. The call to a println would call toString for me automatically. I'm just kind of putting that in there to show it explicitly. But if I do want to get the value out as a string, I can get to the value by calling the get method on the collection, but notice that would come back as an object. So I have to explicitly cast it to be a string. Now let's say I go out and I just create an instance of some class I've just made up, some arbitrary class. Because I am restricted to the type of my ArrayList, I can also just add that right into that same collection. Now there may be times I want to do that, but generally I don't. So if we look at what we've seen in this collection code we have here, we've seen the fact that I can add things to it and it'll grow dynamically. We can iterate over it in. In general, we're probably going to want to restrict the types that we put inside of a given collection. So in the next clip, let's take a look at how we can actually restrict a given collection to a specific type.

Collections and Type Safety
As we saw in the previous clip, when we worked with our collection and we didn't associate with any given type, that collection operated on the Object types. So what that meant was any return values that we got back from the collection were of type Object, which meant we had to actually convert them to our desired type. And the collection didn't restrict what types we could add to the collection. So in general, we want to go ahead and associate our collections with a particular type. We want to restrict the type that they operate on. Collections use the Java concept called generics to do that. And conceptually, generics are kind of simple. It basically means that when we create our collection, we specify what types that collection can operate on. Now generics are a very big and powerful concept. You want to know more about them. Later in the course, I'll give you some pointers to where you can learn more about them. But for our purposes, just understand that generics allow us restrict the types the collection operates on. And that type restriction is pervasive so that when you associate a collection with a particular type, the return values that you get back from that collection will be typed appropriately. They'll be typed based on what you've associated the collection with. And the collection will enforce those types when you add things to it. So the compiler will check to make sure that anything you're adding to collection is compatible with the type associated with the collection. So let's take a look at the code that we wrote earlier, but let's go ahead and type our collection this time. So we'll have our ArrayList, but notice now after the collection ArayList, we actually have the less than the type String, then the greater than before we give the variable name. Well, this says that this is an ArrayList that holds the type String, and this can be any of our classes. So if we create our own custom class, our arrayList can be types associated with that. So now when we set up the ArrayList and we say its variable name is list, when we new up the ArrayList, we go ahead and we're typing the ArrayList again here. So we're saying that our ArrayList, it holds strings, the variable's called list, and we create an array list to hold strings. Now for convenience, on the right‑hand side of the equals sign, we can take that second occurrence of String and just remove that and just put the less than and greater than. So the compiler will go ahead and set that up appropriately for us. So we're still creating a list that holds strings. So we'll go ahead and add our string values, just as we did before. And we of course can ask the collection how big it is by calling list.size. And we can of course iterate through the collection. Now remember, though, this time, since we actually associated the string type with the collection, here in the for statement, rather than getting objects back each time, we will actually get strings back. And since they are strings we don't need to call toString on the instance; we'll just get the string value directly from the variable because it is a string. And when we call the get method to actually get an individual value out of the collection. Previously, we had to cast the string, but now since our ArrayList is associated with the type string, the get will actually return the values as strings. And again as we said, that enforces that so that we have some type here, SomeClassIMadeUp and this variable c, if we go ahead and try to add that to the collection, well, now the compiler will say, well, wait a minute, SomeClassIMadeUp is not compatible with type String. Therefore, you can't add that to this collection. So you see we're getting a lot of power now. Our collection is strongly typed. It's limited to holding just things that are strings, and we get this dynamic growth. And as we'll see, there's a lot more that we get with collections. So in the next clip, we'll take a look at the collection interface and those features that are common across collections.

Collection Interface
Java provides a number of different collection types, and each of those collections have their own features. But many of the features are common across collections. Now these common features mostly come from the collection interface, and most collections implement that interface. Now, a notable exception are the map collections. They don't implement the collection interface. We'll talk more about them a little bit later in this module. Collection interface extends the Iterable interface, which is why we can use things like forEach to walk through collections. But of course the collection interface provides a number of methods that are specific to collections. And if we look at some of the most common ones, things like the size method, which we've already seen in code, tells us the number of elements inside a collection. The clear method will remove all elements in a collection. IsEmpty returns true if the collection has no elements in it. We've seen add before where we can add a member to a collection, and we have addAll, which allows us to add all the members from one collection into another. So let's take a look at using addAll. So we declare an ArrayList here to hold strings, and we add a couple members to it. Now let's use another collection type called a LinkedList, which also holds strings, and we'll add some members to that. Now these are two different types of collections, but they both implement the collection interface, so we can do things like call addAll, so we'll addAll the members from list2 in to list1. Now this doesn't change list2, right, list2 will still have exactly what it had before. But now if we iterate over list1, we'll have the original members that we added directly to list1, as well as the members we added from list2. Now many of the methods of the collection interface rely on equality tests, so things like contains will return true if the collection contains a particular element. ContainsAll returns true if the collection contains all the elements in another collection. Remove allows you to remove a single element. RemoveAll removes all the elements from one collection from the current collection. And retainAll removes all the elements from the current collection that are not in another collection. The thing is though, each one of these require some kind of equality test, and that equality test is based on the class's equals method. Right, so it doesn't do a reference equals, _____ it's the exact same object. It uses to return value of the equals method. So let's see how that affects our applications. So let's say I have a class here we're going to call MyClass, and it has two member fields, label and value, it has a constructor that accepts the label and value and puts them into the member fields, and we override the equals method. So what we do then is we accept an object, cast it to our type, and then we do an equalsIgnoreCase on the value. So notice that our definition of equals is simply if the value fields match, we don't look at the label fields. And so now we have some code that uses this. We'll have our ArrayList as our collection. We'll go ahead and create an instance of MyClass, which has a label v1 and the value abc. Another instance, the labels v2, values abc. And another instance, labels v3 and the values abc. We add those three to the collection. So now we say remove v3. Now, you might think that's going to remove the one we added, v3. But remember, we're not doing a reference equals, we're using the value of the equals method, so basically it will walk through, in this case, in the first member it finds it matches or returns back and equals of true is removed. So if I go ahead and print this out now, I will get back v2 and v3. And this is because all three members had the exact same value and our equals test was only on the value. So just be aware of that as you're working with these methods. Okay, in the next clip we'll take a look at some of the features of the collection interface that rely on capabilities introduced in Java 8.

Java 8 Collection Features
Java 8 introduced a number of new features to the Java environment. One of those features is something called lambda expressions. Now, lambda expressions are a fairly involved concept overall, but fundamentally, what they do is they make it easy for us to pass code as arguments. Now the concept of lambda expressions are beyond the scope of this particular course, so we're just going to touch on them here, but a little bit later on, I'll give you a pointer to another Pluralsight course that digs into them in much more detail. The thing we want to understand is that collections have the ability to leverage lambda expressions to run code across its members. Now, one of the methods we'll look at here is what's called the forEach method, and that's actually inherited from the iterable interface. And what that allows us to do is simply pass in a block of code and have that code just be run for each member in the collection. Now, another method we'll look at here is what's called the removeIf method, and that takes a particular type of lambda expression called a predicate. Predicates resolve to either true or false. So what happens is that we can pass in that code, and then for every member for which that code resolves to true, that member is removed. Let's take a look first here at using our forEach method. So let's go ahead and create an array list that holds the MyClass type we created just a little bit earlier. We'll create three instances in MyClass, one with a label of v1 and a value of abc, another with the label of v2, value of xyz, and the last one with a label of v3, again, a value of abc. We'll go ahead and add each one of those to the collection. And so let's go ahead here and say we want to just go ahead and print the labels out for each one of these. Now we could write an explicit for loop, or we could use the forEach method, and we're going to pass it in the lambda expression. Now, the format of a lambda expression is first provide a parameter name, and that name could be anything you want; I'm just using the name m here. And then we use the arrow symbol, which is hyphen greater than. So we're basically saying we're passing m into this code, and that m will represent the current member in the collection, so m will represent each member in the collection once. And then the code we want to run is this System.out.println and then m.getLabel. So what that means is that this method, System.out.println will be called once forEach member, and for that member we'll call it getLabel, which then, in turn, will print out the value of the label. So, it prints the first member's label, second member's label, and the third member's label. Right, so that was a really simple lambda expression. It's important to note that lambda expressions can be much more involved than that, but fundamentally, it's always the same. It's just kind of running the blocks of code once for each member. So let's take a look at using removeIf. So let's go ahead and create that same array list we did before holding the MyClass. We'll create those same three members we created earlier, and we'll go ahead and add each one to the collection, and let's say that we want to go ahead and remove each one that has a value of abc. So what we'll do is we'll go to our list, we'll call removeIf, again, we're using a lambda expression. So we'll have a parameter name, again, I'm going to call it m, I could call it anything I want to, the arrow symbol, and then the code. Now, remember, this code is a predicate, so it has to resolve to true or false. So, first I'm going to say m.getValue, so for each member we'll call getValue and we'll do an equals comparison to abc. So, it'll walk through the first one and look, it'll get that value abc. That is equal, so that one's removed. Second one has a value of xyz. That's not equal, so it's not removed. Third one, again, has abc, so that one is removed. So now if we go through and run through the code and the collection we write out everybody who now remains in the collection, the only one left is that second member, v2. All right, so the idea is lambda expressions make it just really easy for us to run blocks of code across members of our collections. Okay, now in the next clip, we're going to take a look at converting between collections and arrays.

Converting Between Collections and Arrays
Now there are times in our code where we need to be able to convert between collections and arrays, and what it comes down to is just very often maybe dealing with a particular API that requires an array even though you may be working in a collection. And also that's because you're dealing with legacy code or just some library code that you don't control. Now thanks to the methods on the collection interface, we can easily get an array from our collections. Now we use the toArray method. Now there's one version of toArray that takes no parameters. If you use that version, you'll get back an array of type Object containing the members from the collection. There's another version of toArray that accepts an array as a parameter, and that version of toArray will return back an array of the same type as the array passed in. Now it's also worth noting, though, is that if you have an array and you need it as a collection, the Arrays class has a static method called asList that will give us a collection containing the members of a particular array. Let's take a look at some code here. So first let's go ahead and get our collection as an array. So we'll go ahead and create an ArrayList again to continue as members of type MyClass. We'll go ahead and add three members to it. So now if I call list.toArray passing no parameters, what I'll get back is an array of objects with each member being the three MyClass instances from my collection. Now that's useful, it's powerful, but often we want typed arrays, not just arrays of Object. So what we can do right there is call list.toArray, but what we do now is pass in a typed array. Now a common technique we use here is we create up an instance of the MyClass array with 0 members, with a 0 size array. So this array we're passing in here is just used to indicate the type of the array we'd like back. So what toArray will do now is create a brand‑new array containing MyClass members and return that back. So a1 is a newly created array containing references to the three MyClass instances that were inside of the collection. Now, if I go out here and I create an array that actually has room for the members, so a2 is a brand‑new array that has three elements inside of it, and I pass that array into toArray, toArray will return back a reference to the same array I passed in. In other words, if I pass an array into toArray that has room for the members in the collection, toArray will go ahead and use that array. So in this case, the variables a2 and a3 point to the exact same array. The toArray method used the array that I passed in because there was room to hold the members from the collection. Now there are cases where I may have code that has an array, and maybe I want a collection. So let's say I have an array here of type MyClass. We have three members inside of it. If I need to get that as a collection, I can call the Arrays class's static method asList, pass that array in, and that will then go ahead and I'll get out a collection that has references to the members that were in the array. And that's a full‑blown collection, so I can go ahead and now use that as a collection, so in this case I'm calling the forEach method and running code across the members in it. So you see, Java makes it very easy for us to move between collections and arrays. Okay, now in the next clip let's take a look at some of the common collection types that we have available to us in Java.

Collection Types
Now, as I've mentioned, Java provides a wide variety of collections, and the reason is is that they each have their own specific behaviors. Now, the types of associated with collections are interfaces and, of course, actual classes. Now, the interfaces, those define the contracts for a particular collection's behavior, and then the classes, well, they're the actual implementations of the collection. And each of the collection classes implement one or more collection interfaces. Now, if we take a look at some of the commonly used collection interfaces, well, one we're familiar with is the Collection interface itself. We've been talking about that one a bunch throughout this module. And that provides our basic collection operations. Another interface is the List interface, and that is used by collections that maintain some concept of order, whatever that might mean. There's the Queue interface, and that for collections that have a concept of order and a specific head element, kind of the one that's kind of next, in a sense, Then we have the Set interface, and that's for collections that have no duplicates, so you know that each value inside of there is unique. And then there's the SortedSet interface, and so that's for sets, meaning that there are no duplicates, and its members are sorted. So these are the contracts for behavior. Some of the types that implement those interfaces are things like the ArrayList. We've been talking about that guy a lot. So, an ArrayList is a list that's backed by a resizable array. Now it's efficient for random access, and what we mean by that is that it's very efficient to go I want the 7th element, the 200th element, the 15th element. But it's inefficient for random inserts. So if you've got a large ArrayList and you want to insert something between the 200th and 201st element, that can be expensive in an ArrayList. Now there's the LinkedList class, which is a list and queue backed by a doubly linked list. Now it's efficient for random inserts. So inserting a new member between two of the existing members is actually very efficient. But it's inefficient to do random access, so things like jumping to the 150th element, the 300th, the 15th. That's inefficient in a LinkedList. Now the HashSet, okay, that's a set that's implemented as a hash table. So it uses each object instance's hash value, and it's a good kind of general purpose hash table. Then there's the TreeSet, which is a SortedSet that's implemented as a balanced binary tree. So, it's a set, so each of the members are unique, and it tends to be inefficient as you're modifying it or you're searching through it, but it makes it easy to access the members in a sorted order. So there's lots of these collection types available. They each have their own individual benefits. So as you're working through your applications, take a look at what your individual needs are, and pick the right collection class for you. Now, in the next clip, I'm gong to talk a little bit about how those collections that rely on sorting actually handle sorting the members.

Sorting
Now as we've seen, some collections rely on types being sortable. Now there are two ways for us to specify sort behavior. One is to use the comparable interface. Now that's implemented by the type to be sorted, and basically what that means is that a type is able to specify its own sort behavior. Now something to be aware of is that if a type implements the comparable interface, the behavior of the comparable interface should be consistent with the implementation of its equals method. In other words, if comparing two instances of the type using equals returns true, comparing those same two instances using the comparable interface should also indicate that they're equal, in other words, the types should behave consistently when compared for equality. Now there's another interface called comparator, and that's implimented by a type that performs a sort. In other words, it allows one type to specify the sort behavior for another type. This interface is useful for cases where maybe you want to sort a type that doesn't implement the comparable interface, or you have situations where you want to provide an alternate sort than that provided by the comparable interface. So let's take a look at these guys in code. So let's first look at using the comparable interface. So remember we've got this class, MyClass, and it has two fields, the label and a value field. Let's go ahead and add a toString method to it, so it just returns about the concatenations of the lable, and vertical bar, and value. And remember earlier when we implemented this class, we implimented the equals method. Alright, and the equals method relied on comparing the value fields of two instances. So since that's what our equals method uses, if we go ahead and impliment the comparable interface on this type, the comparable interface should provide the same behavior. So now the comparable interface has one method, compareTo, and again it receives one value, other, and this method is responsible to indicate whether the current instance is less than, equal to, or greater than the other instance. And it does that by returning a negative, zero, or a positive value. So again we want to use the value field in the compareTo because that's when we also use an equals. So we'll just add the value.CompareToIgnoreCase to the other. So now we have the ability to sort instances of my class, and those sorts will be depended upon the value field. So now if we want to go ahead and use this with a collection that does sorting, we'll use it with a TreeSet, we'll go ahead and add three instances of MyClass to the TreeSet. Alright, the first has a label of 2222 with a value of ghi, next is a label of 3333 with a value of abc, and the last one has a label of 1111 with a value of def. So remember that the TreeSet maintains sorting. So if we go ahead to the TreeSet, and we walk through them one by one, and we print them out, we will now get them back based on the implementation of the comparable interface. So the first one will come back as the value abc, so the next one comes back with the value def, and the last one comes back as the one with the value ghi. In other words, TreeSet used the sort behavior provided by the comparable interface. Now let's say we want to implement an alternate sort, and so we'll use the comparator to do that. So we'll create a new class, I'm just going to call it MyComparator, and it implements the Comparator interface. So this class is responsible for providing sort behavior for another class, in this case it'll be the MyClass. It has one method, compare, and it accepts two instances. So it's responsible to indicate how those two instances compare to each other, basically, how the first one compares to the second one. So if it returns back a negative value, the the first one is considered less than the second one, 0 says they're equal, positive values says the first one is greater than the second one. So in this case, we'll provide a sort based on the label. So the Comparator sorts them based on the label fields of each instance. So we can also use this in a TreeSet. So we'll go ahead and create an instance of our TreeSet class, but when we construct this one, we're going to pass in an instance of our comparator. We'll go ahead and add instances that have the same labels and values as we had last time. But now remember this is using the sort provided by my comparator. So now when we loop through them, we'll now get the values back sorted by their label. So we'll come back with the first one labeled 1111, next will be labeled 2222, and the last one will be labeled 3333. So again, we were able provide sorting on the type itself with the comparable interface or sorting from an alternate type with the comparator interface. In the next clip, we'll take a look at working with map collections.

Map Collections
Let's look now at map collections. Now map collections are a little different because in a map collection, each entry is composed of two parts, a key and a value. People often refer to these as dictionaries as well, and the idea is that the key is used to identify or locate the value. Now in a map collection, each key is unique, but the values can be duplicated. So multiple keys can point to the same value if that makes sense in the problem that you're solving. Values can even be null. Now there are a few basic types that we associate with maps. First, let's look at the interfaces. Now there's the Map interface, and that provides your basic map operations. There's also a SortedMap interface. Now that extends the Map interface, and it's used for maps that have an idea of their keys actually being sorted. Now in terms of classes that implement these interfaces, one is HashMap, and that's just an efficient general purpose implementation of the Map interface. There's also a TreeMap, which is an implantation of a SortedMap interface. This is a self‑balancing tree. And so, in this case, the keys are sorted, and sorting can be handled either using the Comparable interface, in other words a type can have its own sorting, or the Comparator interface where one type sorts for another, just like we saw when we we're looking at the tree set. Now the Map interface has a number of methods on it, but let's look at some of the more commonly used ones. One is the put method. That's how we actually add a key and value to the map. There's a putIfAbsent method. What that says is I want to provide a key and a value, and I only want you to use this value if the key doesn't already have a value. So in other words, the key is not in there at all or the key is there, but the associative value is null. There's a get method where I provide a key and I get back the value. If that key is not found, it returns back a null. There's also a getOrDefault where I provide the key. If it's found, the value comes back. If the key is not found, then the value returns whatever I provided as my default. The values method allows me get back a collection containing all the values in that map. The keySet method gives me back a set containing all the keys in the map. Now map collections also support the idea of lambda expressions. So there is a forEach method that allows me to provide a lambda expression and perform the associated action for each entry in the map. And there's a replaceAll method that allows me to actually provide a lambda expression and modify the values associated with each key. So let's see these guys in code. So let's set something up here. We'll go ahead and we'll declare a map, and we'll go ahead and create an instance of the HashMap. Now when we declare a map, we have to provide two type specifiers. The first one is the type of the key. So I'm going to say I have a map here whose key is a String. And then I have to provide the type of the value. I'm going to say that's also a String. Now they don't have to be the same. It can be any type I want them to be. But in this case for simplicity, we'll do a key and a value that are strings. So I want to go ahead and start putting some entries inside of here. So I'll say map.put, and it says that I'm putting an entry in whose key is 2222 whose value is ghi. I'll put another one in whose key is 3333 whose value is abc. And the last one we'll put in is 1111 for the key. The value is def. So accessing the members is really straightforward. So if I say get 3333, that will give me back to value associated with that key, so s1 would have the value abc in it. Now if I call map.get, passing in this key 9999, which is not in my map, well s2 would get back a null. But if I use getOrDefault and I say I want the key 9999, but I want the value to default to xyz, well if that key was there, I would get the actual value. But since there is no key 9999 inside my map, I then get back the xyz. Pretty straightforward. Now let's look a little bit at working with the lambda expressions. So let's go ahead and create an instance of our HashMap again. We'll add those same three entries. So now if I want to go ahead and call this forEach method, so I'm going to go through and iterate over the whole collection. Now as I specify this lambda expression, I'm going to have to provide the parameters. But in this case, the lambda expression is what's called a biconsumer. And basically what it means is that it accepts two parameters. Now the parameter name can be any name I want. So I'll use k for the key and v for the value. So for each entry, it's going to call into this expression, passing in the key and the value for that entry. I'll go ahead and use the arrow notation. And then the code I want to execute is the System.out.println. And I concatenate the key, a vertical bar. and then value. So basically now that'll output out 2222 vertical bar ghi, then the next entry, and then the next entry, so really straightforward. But now let's say I want to go through and I want to apply some logic to modify all the values inside the map. So what I'll do is I'll use this replaceAll method. Now again, this uses a lambda expression, but it uses one called a bifunction. Now a bifunction accepts two parameters, but also returns back a value. So what'll happen is that the code that I provide will run, receive the key and the value, and I'm returning back what I want the new value to be. So I'm going to have the same parameters, the key and the value, the arrow. But now what I'm going to say here is v.toUpperCase. Now what this is implying is that it's returning back v.toUpperCase. In other words, it calls toUpperCase on each value, takes a result of that, returns that back, and then the map applies that as the new value for that entry. So after I run this replaceAll, if I then do a forEach again and print them out, it'll print each of the entries out, but now the values are all uppercase. This replaceAll method allowed me to provide the lambda expression that was then executed across all the entries in the map. and it allowed me to modify all those values using whatever logic I desire. Okay, now in the next clip, let's take a look at working with sorted maps.

Sorted Map Collections
Let's look now at some of the commonly used methods on the SortedMap interface. Now remember the SortedMap interface extends the Map interface, so it has all those methods, as well as some additional ones. So one it has is firstKey, which will give me back the first key in sort order that's inside of this map. LastKey gives you back the last key that's in sort order in this map. The method headMap, this will give me back another map that contains all the entries that have keys whose values are less than some specified key I pass in. TailMap kind of does the opposite. It gives me back a map that has all the entries whose keys are greater than or equal to the specified key I pass in. So that's important to note that headMap is exclusive of the key I pass. In other words, it doesn't include it, where tailMap is inclusive of the key I pass, so it does include it. There's also a subMap method where I actually provide a starting and ending key. So that would produce a map that contains all the entries whose keys are greater than or equal to the starting key I pass and less than the ending key I pass. So let's take a look now at working with our sortedMap. So I'll go ahead and declare a SortedMap here, but I'll go ahead and instantiate this as a TreeMap because a TreeMap implements SortedMap. So this one, again, will have string keys and string values. I add entries to a using put just as I did with the regular map. But let's go ahead and put a bunch more entries in here. So we're going to go ahead and add six total entries in here, and they're in no particular order. As I mentioned, SortedMap extends the Map interface, so I can call methods that are on the Map interface, like forEach. But now when I call forEach on this TreeMap, because it is a SortedMap as it displays the values out, notice the values come back in order by the key. So it takes care of managing that sort for me, and that's one of the real powers of the TreeMap is that it manages the sorting for us. But now let's look at some of the features that are specific to a SortedMap. So I'll go ahead and create my TreeMap again. And we'll go ahead and add those same six key value pairs we did on the last slide. But let's use the headMap method. We're going to pass in the key 3333. So what happens now is a hMap contains a map that contains all the entries whose key is the last end 3333 So if I'm now on hMap, call forEach, and write all the entries out, I'll get the ones with keys 1111 and 2222. Again, it does not include the key I passed in. But now if I use tailMap, passing in the key 3333, and I go ahead and write out all the entries in the map produced from that, it will start with 33 through the end of the map. So again, it's just an important thing to understand is that headMap is exclusive of the key passed, tailMap is inclusive of the key passed.

Summary
To wrap up, here are some of the key things you want to remember. Remember that collections hold and organize values. Collections are iterable, and they tend to dynamically size. There are a number of different types of collections, but different collections can provide optimizations or certain sophistication. Now, by default, a collection will hold its entries as object, but collections can be type restricted, and we just use the Java generic syntax to do that. We associate a type with our collection, it will take care of returning our values appropriately typed, and that will enforce typing on any values that are added. Remember that we can convert between collections and arrays. That's useful because you may be working with a collection, but then need to interact with an API that expects an array, or vice versa. Remember that the Collections interface provides the toArray method. You can get back the array as an array of object or as a typed array? And if you have an array and you want to do collection operations on it, you can use the Arrays class toList method. Remember that some collections provide sorting, and these collections can do it either using the Comparable interface, which allows a type to define its own sort, or using the Comparator interface, which allows a type to specify a sort for another type. Now remember the last collection we looked at was the map collections, and those store key value pairs. In a map, the keys are unique, although the values can be duplicated if need be. Remember that some maps support sorting their keys. Okay, so that wraps up our discussion of collections. In the next module, we'll look at how we can configure application execution and configure application environment.

Controlling App Execution and Environment
Introduction
Welcome to the next module of the Pluralsight course, Java Fundamentals: The Core Platform. In this module, we're going to talk about controlling app execution and the app environment. My name is Jim Wilson. So as we go through this module, there are just a number of things we're going to look at that allow us to affect the execution of an application. The first thing that we'll look at is command line arguments, how do we pass the information into the application from the command line. Managing app and user properties, in other words, tracking the simple aspect of state for the application and user selections. How do we persist and restore those properties between application runs? Then we'll look at deploying property defaults in a package. What we mean by that is actually setting up our application so as part of the package, all of the initial default values for our properties are established and loaded directly from the package, but then easily updated and changed based on application behavior or user selections. We'll then look at default class loading behavior, in other words, what's the default behavior of a Java environment in terms of locating and loading classes that we use? Working with class paths so we can use that to actually tell Java where we want to find the classes we'd like to use. And then we'll finish up with how to access execution environment information.

Command-line Arguments
One way we can pass information into our applications is to use the command line. And the command line really is one of the easiest ways to pass startup information into an application. So this is great for things like specifying the target of your app's processing, so that will be things like, you know, input/output files or URLs you want to work on. It's also a great way to provide behavioral options, kind of like command switches, that sort of thing. Now the command line arguments are passed as a string array, and they're received by our app's main function. And each argument is a separate element in the array. Arguments are separated by whatever the operating system's whitespace is. Normally that would include a space. Any concept of quoting is honored. So like in Windows you can quote a file name with a space, so that sort of thing is honored. So we'll go ahead and create a simple application that uses this. So we'll have a package set up, and we have our Main class. We'll have our main entry function. So now when I run this, I'm going to obviously use Java and then the package name .Main. I'll go ahead and pass in one, two, three command line arguments, Hello there world, each separated by space. So those will be received as a parameter into our main function, again received as a string array. So this array would have three elements in it, one for each command line argument. And it's just a regular string array. So if I want to make sure I have any arguments, I'll just check the length of the array. If it was less than 1, I would say, well, there are no arguments; otherwise, I know I have some arguments, so I'll just loop through them and print them out. So if I run this, I'll get the first thing is Hello, there, and then world. So it's really straightforward. Now one of the things that comes up is that when we're working with our IDEs, our development environments, we often want to be able to test things inside of there, we want to be able to test with our command line arguments, and IDEs make this fairly easy. Most of the IDEs provide some way for you to configure the command line arguments you want to test with, and those arguments will be passed into your application, just like they were specified on the command line. Now each IDE is going to do this differently. So if I want to provide here first a URL that shows how to do it with IntelliJ, and here's another URL that shows how to do it in NetBeans. All right, so in our next clip what we'll do, let's take a look at another program that accepts command line arguments, and that one will accept a file name to process, and we'll show what it's like to work with a file name that includes spaces, and we'll show how to set all that up inside of an IDE.

Demo: Filenames with Spaces and Passing Args to an IDE
We have this program here that's been stubbed out to basically process a file, and processing a file in this case simply means printing out the contents of the file. So now the work to do that is in this method here called showFileLines. You can see it accepts a filename parameter. And all it does is open it up with a BufferedReader, loop through it, and print the contents out. Now what we want to do is get that filename from the command line. Now if you scroll down here a little bit, you see there's another method here called showUsage. Basically, it just says hey, please provide the filename to process on the command line. So we'll use that as a way just display a message to the user if they don't give us a filename. So what we want to do here is up here in our Main function, so remember that we're going to get our filename from the command line, so that's going to come from our args parameter here. So first what we want to do is make sure that we did at least get some kind of command line. So we do that by checking the length of our args array. So we'll first just make sure that we have something in our args array. Well if that length is 0, we know that the user did not provide any command line arguments. So we want to go ahead and print out the message on how to use the program, so we'll call our showUsage method. And then we'll simply return, which will exit our program. So that's our first thing, just make sure we have some kind of arguments. Now the filename will be the first argument on the command line. So what we'll do is have a local variable here called filenames type String. And what we'll do is we'll assign that to a value of args sub 0. And so that's our first command line argument. So we'll just pass that into our showFileLines method. So that does the work to get our filename from the command line, pass it into our showFileLines method, which will then go through and print out the contents. But now that assumes that the file itself actually even exists. So whenever you're receiving something through the command line, you always want to do good error checking. And so one of most fundamental error checks we could do on a filename is to make sure that it actually exists. So what we'll want to do here is first call Files.exists to see if the file actually exists. So we're calling that Files.exists. And we have to get the path for this. We'll just do a Paths.get, and we'll pass in filename. So basically, that's a simple check to say well, if that file doesn't exist, well something's wrong. So we'll want to go ahead and print out a message that just says the file doesn't exist. So we simply print out a new line, the message file not found, and then the name of the file. And so again, through here, we'll just return to exit the program. So let's go ahead and run it and see what happens. So of course we get the message, please provide the filename to process on the command line because I haven't provided any command line arguments. Well the IDE I'm using here is IntelliJ. So I want to go ahead and configure the project to pass in command line arguments. So the way I do that in IntelliJ is go over to the Run menu, say Edit Configurations. You'll notice you bring up this dialog here, and this dialog sets up your execution environment. Notice one of the things we have here is the working directory. So in other words, our application will behave as if it's being run from that directory. Well if I look in that directory, notice I have a filename here called file1.txt. So we'll go ahead and want to pass that into our application. So it's going to put on my Program arguments box here, put file1.txt. And so now what'll happen is that my program will execute as if it was inside of the directory specified here in working directory, and I passed in file1.txt on the command line. I go ahead and say OK. And now when I run it, notice that, I'm going to scroll up here, it actually read through the contents of the file. And for each line in the file, it wrote that line out. So it worked correctly. I was able to pass the filename on the command line and see the contents printed out. And I was able to do that very easily from inside of my IDE. Now notice here I also another file inside that same directory here called multiple part file name.txt. So now let's say I want to go ahead and process that file. I'll go back into my project, go to my Edit Configuration, and remember that I can pass the filename on the command line. So I've provided the filename on the command line. I'll say OK. And so now let's go ahead and run it. And notice the error message I get, File not found: multiple. Well remember that whitespace separates a command line argument. So our filename contains whitespace in it. So what I want to do is go ahead and quote the command line argument. So go back here to my configurations, and all I'll do is put a quote around the filename, so now that's a quoted filename. And so now this will be passed to my program as one argument. And this is true whether I'm doing it from inside the IDE or if I was actually running it from the command line because the operating system allows quoting of filenames. These quoted filenames will be passed as a single argument. So now as I go ahead and run it, I now get this is the contents of that file. So now it worked. So now we've seen as we pass these arguments into our programs, we can easily set up inside the IDE. And again, as we mentioned, Java respects the quoting of command line arguments, so things like filenames with spaces in them can be processed correctly.

Managing Persistable Key/Value Pairs
You recall in the previous module when we were talking about collections, we discussed something called a hash table. A hash table allows to have key value pairs within our application, and we know that's just helpful to be able to have these key value pairs. We just have a number of keys and their associated values. The issue with the hash table is that it only exists for the lifetime of our application. There are times where we want to have key value pairs that can exist beyond any given execution of the application. We want to be able to persist these key value pairs, and this comes in handy for a number of reasons. One is just the idea of storing app configuration information, maybe the directories where you find certain files, that sort of thing. Or you want to track aspects of the application state. Has the user already seen a given tutorial screen or what screams user looking at when they last exit the application? Are things like user preferences just certain things you just want to set up to personalize the application? These are all cases where having persistable value pairs is helpful. Now we need an easy way to manage these key value pairs. Now obviously, we need to be able to set and retrieve the values for each key, but we got that with the hash table, but to go beyond that. Well, if they're persistable, we need to have a way to store and load those key value pairs between app executions. And we'll have an easy way to provide default values for the keys that have not yet been set. And that's where the Properties class from the java.util package comes in. Now if we look at our Properties class, it's pretty straightforward. Now it inherits from hash table. Remember that hash table could actually be set to use whatever data type for the key you want, whatever data type for the values you want. In the case of the Properties class, both keys and values are strings. Now in terms of working with properties itself, we have a setProperty method, and that's used to set the current value for a key. And it does the right thing in terms of creating a new key if it doesn't already exist or updating it if you're providing a new value for an existing key. Then we have the getProperty method, and that returns a current value for a key. If you request a value for a key that does not exist, you'll get a null back, but getProperty optionally accepts a default value that would be returned if that key doesn't already exist. So let's look at some simple code to use the Properties class. So we'll go ahead and create an instance of our Properties class. Let's go ahead and set a new property that has the key displayName and a value of Jim Wilson. When we want to go ahead and get that value back, we just call, getProperty, passing in our key, displayName. So when we do that, the variable name would get the value Jim Wilson. But now if I call getProperty, passing in the key accountNumber, which has never been set, well then that acctNum field will get a null value. And if I call getProperty, passing in a key of position with a default value of 1, because I've never set a position, I'll get that default value back of 1. So as we can see, working with the Properties class in terms of getting and setting properties is very much like working with the hash table, but in the next clip, we'll take a look at how we can actually store and load those property values so they can exist beyond an application execution.

Store and Load Property Values
Now, as we mentioned, one of the values of the properties class is that it can be persisted. It can live beyond any given execution of an application. So you can actually persist out to and read from a stream. You're can optionally include comments as you persist it. And it supports two formats, a simple text format, as well as XML. All right, so take a look this first, working with the simple text format. So when we persist a simple text, we use the store and load methods. Store saves it. Load brings it back in. So we can either work with OutputStreams and InputStreams, or a writer and a reader. If we're persisting out to a file, we normally end the file name with a .properties suffix. And the way it formats the files is it writes one key value pair per line. So now the key and value are normally separated by either an equal sign or colon. Any whitespace that surrounds the equal or the colon is ignored. Now, if any white space occurs that doesn't include an equal sign or a colon, the whitespace itself becomes a separator. And we'll see an example of that in just a moment. If you have a key that needs to include a space, an equals, or a colon, you can simply precede it by the backslash and then it will actually be escaped, in other words it will become part of the key name. In order to create comments in a file, start the line with either a hash character or the bang or exclamation point. And any blank lines in the final are ignored. All right, so let's see what it's like to work with this now. So we want to go ahead and store property out as a simple text format. So we'll create our properties instance. We'll go ahead and set a couple properties. We'll set a property with the key display name of value of Jim Wilson and another one with the key account number with the value 123‑45‑6789. So in order to actually put this out, we'll use a writer. So we'll go ahead and create a newBufferedWriter, just as we normally do. And we simply called props.store, passing in the writer, and then any comment we want to put inside of that file. If we don't want a comment, we can simply pass null as the second argument. So what that would do now is that since we named our file xyz.properties, we'll create that file, of course, the first line will be whatever comment we provided. The simple text format also adds a comment with a date timestamp. And then we simply have our key equals values, so our first key, displayName equals Jim Wilson. And then our next key equals value, accountNumber equals 123‑45‑6789. All right, so that's really straightforward. Now we can, of course, load in a file that was created with the store method. We can also manually type up our file as well. So let's say I want to go ahead and type a file myapp.properties, the first entry will be val1=hello world. Now let's put another entry in where we actually say val2 space equals space goodnight moon. Then we'll do another entry, val3 colon, a series of spaces, hi noon. And our last entry will be val4 space night space bobbi space sue. So notice that last one has no equal or colon in it. Let's see what happens if we load this in. So we'll go in here, we'll create our properties instance. We're going to go ahead and load it with a reader, so we'll create a newBufferedReader, just as we normally do. We'll call props.load against the reader, and that will now populate our props instance. So if I now say val1 equals getProperty of val1, well that one's really straightforward. Of course, val1 will get hello world. But now if we get the property of val2, remember that any whitespace surrounding the equal sign is ignored. So we simply get back goodnight moon. Right, the space before and after the equals was just ignored. If we get val3, right, we got val3 colon and a whole bunch of white spaces. Well, it's still whitespace surrounding, the colon is ignored, so we get back simply hi noon. And now this last entry, val4, remember, we said that when whitespace occurs that does not encounter an equals or colon, the whitespace becomes the separator. So we actually gets back to val4, we get back night bobbi sue. Now, I wouldn't encourage you to do this this way, in terms of using the whitespace as a separator. But just be aware that this is actually how it works. It's much better, of course, to use the explicit equals or the colon. Okay now in our next clip, let's take a look at working with the XML file format.

Properties Persisted as XML
To persist our properties instance using an XML format, we can simply use the storeToXML and loadFromXML methods. These support the OutputStream and InputStream, respectively. Now, because it's XML, if you go ahead and persist it to an XML file, you'll follow the standard of just putting a .xml suffix on the file name. Now when we use the XML format, it's one key value pair per XML element. So they're stored in an element named entry. The key is stored as the key attribute. The value is stored as the value of the element itself. And if you want to have comments, you use an element named comment. So now to do this in code, we'll go and create our Properties instance, and we'll go ahead and set the same properties we set before, displayName and accountNumber. So to go ahead and store this, we'll create an OutputStream. We'll do it to a file called props.xml, and all we do is say props.storeToXML. We pass in the OutputStream, and then in this case you're going to want to comment, I'm just putting in My comment. So now let's see what this looks like. Now remember, it's an XML file. So when it creates an XML file, it puts the standard XML header in. It also puts in a doc type entry, right. It basically just simply says that this XML file conforms to the document type definition identified by that that URI. So now the property's are contained under a root element named properties. Our comment goes into an element named comment. Now the XML format does not automatically put a date timestamp into the file as the simple format did. So now, for each of our entries, we get an entry element. Again, the key is identified by an attributed named key. So key = displayName, so this is the key display name, and the value is the value of the element. So we put our other entry in. All right, so again, key = accountNumber, and then we have the value of the accountNumber property. Loading them in is straightforward. Create our Properties instance. We'll go ahead and create an InputStream over that XML file. Simply say props.loadFromXML, passing in the InputStream, and then we have our properties back. So our properties remain available as if the program had never stopped running. Okay, now in the next clip, we'll see how we can actually initialize the properties instance to include a series of default values.

Providing Default Properties
Now it's often useful to provide default values for our properties. Alright, think of things like configuration, we can provide our default configuration, but then later update it with whatever values we need at runtime, or the idea of user preferences, we can provide default preferences, but allow the user to update those at runtime. Now we know that our getProperty method call allows us to pass a default value for each individual key, but having to do that for each and every call to getProperty is cumbersome. We like to have a more general idea of defaults, and we what we'd really like to be able to do is create our properties instance with defaults, and we can do that by simply creating our properties instance and passing another properties instance to the constructor. And then the way that works is that whenever we call getProperty, if the key that we're searching for is not found in the properties instance we just created, the one that was passed as a construct will be searched. Now this doesn't prevent you from passing a default value with getProperty calls, but just keep in mind that that the default properties passed to the constructor will take precedent over the default value you passed to the getProperty method. Alright, so now to see this used in code, it's pretty straightforward. We'll go ahead and create a properties instance we'll call defaults. We'll set a property in there called position with a value of 1. We'll then create another properties instance called props, and we'll pass in defaults to the constructor. So now if we call props.getProperty on position, well, props doesn't contain a key position, but defaults does, so we'll get back the value that was in defaults, which is 1. We can now go off and do some work with that, so we'll go ahead and parse it from a string into an integer, do whatever we were going to do with that integer. And so now we'll go ahead and increment it by 1 and store it into props. So now after we go off and do some other work, if we now call props.getProperty on position, we'll now get the value that was stored in our props properties. Alright, and the key here is that whether we were relying on the default value or relying on the value that's actually stored into our props properties instance, we made the exact same getProperty call. We didn't have to worry about passing the default to the getProperty method call because that had been provided at the time that we constructed our props properties instance. Now if we think about this idea of having a series of default values, that's something we'd probably want to decide and create at the time we're creating our application. And so what we'd like to be able to do is create the file that contains our default property values, and make that part of the package that contains our application classes. And we can do that. So basically at development time, we can type up our .properties file, and then during the build process, include that .properties file in the package that contains our classes. So then at runtime, what we can do is we can then load that file from the package, and we do that by taking advantage of the Java resource system. The Java resource system allows us to use a method called getResourceAsStream, and what that will then do is give us back a stream over the properties file that we built into the package. Now we get to the getResourcesStream method by using any class in the package. In Java, each class actually has the concept of a class descriptor that we can get to by either using the ClassName.class or the class reference .getClass. Now we'll talk a lot more about this idea of having class descriptors later in the course when we talk about reflection. The key thing here is that just understanding that we can use the class information to get access to a stream that provides your default property information. So now in the next clip, we'll walk through some code where we actually provide this default property file and get access to it from our package at runtime.

Demo: Loading Default Properties from a Package
Let's go ahead and create some code now. We'll have properties that we provide the default values as part of our package. But then at runtime we'll allow the application to update the property values with what might be user‑specific values. Now to do that, we're going to have to make our properties default file part of the package itself. Now each IDE does this differently, but they all do it pretty easily. Now here inside of IntelliJ, all I need to do is right‑click on the package name, say New, and then File, and I can name the file anything I want. I'll go ahead and call this one MyDefaultValues. And then I'm going to use an XML format to store the property value, so I'll put a .xml on the end. And we'll go ahead and create that file. So we've created the file, pretty straightforward. I'm going to go ahead and paste some starting values inside of here. So these now are my three entries I want to use as my default property values. So I have three properties, isFirstRun, welcomeMessage, and farewellMessage. So what we want to do then is go back inside of our program and we're going to load those in. So we'll first create a properties instance called defaultProps. So we have that, and what we want to do is load it from that XML file that we've put inside the package. So let's go ahead and create a try with resources that has an InputStream inside of it. But now this InputStream we don't want to create from a file in the file system; we want to create it as a stream from the resource system. So remember we said the way we do that is, we can go to any class inside the package, so we'll go to our Main class, go to its class field, and then call getResourceAsStream. So all we have to do here is put the name of the resource file, and then once we have that, we'll go ahead and just put the code inside to load up the XML. So now at this point, we have our defaultProps loaded with the properties we put inside that MyDefaultValues.xml file. So from there, we're now just working with the properties system. So what I'll do now is go ahead and create a properties instance called userProps, but when I create this instance, I'm going to go ahead and pass defaultProps to the constructor. So, of course, that means now that any properties not found in userProps will then search defaultProps for them. So what we'll do from here is, we're going to call a method I wrote here called loadUserProps and pass in userProps. So now if we scroll down to this method loadUserProps, you'll notice all we do here is that, we first check and make sure a file called userValues.xml exists, and if it does, we go ahead and read it in. Now we haven't created that file yet, so it's not going to find anything. So what that means is that the only properties that will exist at this point are ones are found inside the default system. All right, so knowing that, let's go inside of here and let's go ahead and access the properties for welcomeMessage and farewellMessage. So now we get the values for those properties, and then once we have those, we can go ahead and print those guys out. Okay, so let's go ahead and run this now, so I'm going to just run it, and we see, so I'll scroll down here and kind of move us up so we can see a little better. Notice we get the Hello newcomer as our welcome message, and It'll all be different soon as our farewell message. Of course, if I run this again, we get those same messages, and that's going to keep being true because we never update them. So what we want to do now is go ahead and provide user‑specific values, or I'll say in this case, kind of, application having run specific values. So what we can do here is, let's add a little code at the bottom, and what we can do now is just check and see if the application's ever been run before. So I'm going to put an if statement here, and I'm just going to check the property isFirstRun, and I'm going to check if it has the value Y. If it does have the value Y, I'm going to say that, well, this is the first time this application's ever been run, so I want to go ahead and update the values of some of those properties in the userProps instance. So let's go ahead and get this bottom window out of the way here so we can see a little better. So let's go ahead and update the welcomeMessage and the farewellMessage. And then we'll go ahead and set our isFirstRun to the value N. And the once we set all these properties, we're going to call another method I wrote called saveUserProps, passing in userProps. If we scroll down here and take a look at that save userProps method, all that does is create an OutputStream and save the contents of userProps out to a file called userValues.xml, the same file we read in in our loadUserProps. So now if we go up here now and we run this guy again, now the first time we run it, of course we get that. Hello Newcomer It'll all be different soon messages. But now, the next time we run it, we get our Welcome back and Things will be familiar now. And that'll be true from now on out. So what that happened there is that initially we loaded in the default values that we provided as part of our package, and so when we got the values for welcomeMessage and farewellMessage, they were the ones that were defaults. But at the end of that first run we saved new values out to our file so the next time when we went ahead and created our userProps, we now had the values from the last execution of the program. And this is a very common technique for working inside of our applications so we can have those initial values we want to have for any application messages or application behaviors. Then as the application runs, we update them to either be things that are specific to the app having run or maybe user‑specific preferences. And now in our next clip, we're going to take a look at how we can use configuration information to affect how our applications find classes.

Default Class Loading
Let's take a look now at how Java handles loading classes in. Now, the thing is that most applications do not stand alone. They're going to rely on classes that are contained in packages other than the main entry point of the application. Now we do a lot of work with packages, or I should say classes that are contained in packages from the JDK, and generally, we don't have to worry about those; those are located automatically. There are some kind of certain scenarios where you may want to control that, but overwhelmingly, we just kind of let the runtime locate those JDK classes. But what happens when we need to use classes that are contained in packages that are not part of the JDK? Maybe things that our team has written, or maybe libraries we've got for some third party developer. So we have to have a way to identify how to locate those packages. Now, at development time, the way you locate dependent packages is going to depend a lot on your specific IDE. So I've provided here a link to the way IntelliJ sets up referencing packages and the way NetBeans does. We're not going to focus on those. What we're going to focus on is how it works at runtime with Java. And there's actually a number of options that are available to us. Now, first off, let's look at the way just default class loading works, if you haven't done anything special at all. Well, by default, Java just searches the current directory. Now, when you're using this default mechanism, all your classes have to be in .class files, in other words, they can't be in JAR files, and they have to be in a directory structure that corresponds to the packages. So if we take a look at how that works inside of an application, or I should say, when we're working with an application, let's say we go here and create application, it's in a package, com.pluralsight.training, we've got our main entry point. I want to use another class called Student that's in that same package, so we'll use that in our code. And so we have another class called Other that's in a separate package, so we'll import that package. We can go ahead and use that class Other, and then our application does whatever work it's going to do. So our application now relies on two packages, right? The com.pluralsight.training and com.jwhh.support. Well, if we're going to run that in a directory called mydir, the way mydir has to be structured is underneath the mydir, we'll need the directory hierarchy that conforms to the com.pluralsight.training package and the class files from that, and then we'll also need the same hierarchy for the com.jwhh.support and its class files. And then with that in place, if we're in that directory, my dir, we could simply say java com.pluralsight.training.Main, and then we'll run our application. So as long as everything's in this one directory, this will work just fine. But in many cases, having everything in one directory may not be practical. So in the next clip, let's take a look at how we could control the way classes are located.

Specifying Class Path
In many cases, we'll want to actually specify where we want our classes to be loaded from. So we can do that by providing a list of paths to search. Now, when we set up the list of paths, there are multiple paths in that list that are searched in the order that they appear, so it consistently goes through them one by one, trying to find the classes that we're referencing. One thing it's important to notice is that when we specify the paths to search, the current directory is no longer used automatically. If you want the current directory where your application is running to be used, you have to actually put it in the path. Now, there are two options for specifying the class paths. One is to use an environment variable; another is to actually use a Java command option. So let's first look at using the environment variable. So now, when we want to set up an environment variable, the environment variable's name is CLASSPATH. And what happens is that if we set the environment variable CLASSPATH with the list of paths we want to search, that becomes a default path. What that means is that it's used by any job application that does not specify a specific path to use. And we'll see some examples of how that all works. So now you want to use CLASSPATH with caution because what happens is that because you're setting it at the environment level, if one program changes it, any other program that's relying on it is affected. So let's see an example of what that looks like. So let's say now we've got our my directory again, or mydir, and I set the CLASSPATH environment variable to point to otherdir. So I want to go ahead and run my Java program. So if I run a Java program, com.pluralsight.training.Main, well, what that means is that it will look for all the classes that it's using in otherdir. So that'll be our com.pluralsight.training, and then also our com.jwhh.support. So let's say we also run an accounting program, so we have this com.pluralsight.accounting.Main. Well, it's going to rely on that same environment variable, so it's also going to look for any classes that it happens to use in that otherdir. But now let's say that the accounting guys decide that, well, rather than having classes in otherdir, they want to change that to be in a directory called diffdir. Well, now the accounting package program will use diffdir, but now also our com.pluralsight.training.Main will use it. So what that means is that that training program that was running fine before could suddenly start breaking because the accounting guys changed the environment variable. So in the next clip, let's see a safer way to set our CLASSPATH.

Class Path Structure
Let's take a look now how our class path values are structured, and the structure we're going to talk about in this clip applies both to the class path environment variables, as well as the ‑cp option on the Java command. Now, remember that paths can have multiple folder names or multiple directory names inside of there. So we have to have some way of delimiting each of those values, and the way we delimit each value depends on what platform you're running on. If you're on a Windows platform, then we use the semicolon to separate the values. If we're on the Unix platforms, we use just a regular colon to separate the values. Now if a class path has multiple folder names inside of it, the folder is simply searched in order. So when Java is looking for a particular class, it'll first look in the folder that appears first in the path value. If it doesn't find it there, it checks the second one, then the third, and so on. Now if you're referencing a class that's in a .class file, the value we put in the class path is the path to the folder containing the root of the package. But if the class in a jar file, the value we put in is the path to the jar file, including the jar file name. So let's see some examples now. So let's start here, and so we have a folder, psdir. And underneath this is the structure for our package, com.pluralsight.training, along with classes. We have another folder here, libdir. Underneath that is the structure for the package, com.jwhh.support, and that has the class, Other.class. And I want to run my program from mydir. So now if I'm on the Windows platform, I'll say java, then ‑cp. So my class path is \psdir, notice the semicolon, and then \libdir. So it says that \psdir is to be searched first. If things aren't found there, then look in lib.dir. And then we just give it the name of the class we want to run. So when we run this, it'll find our com.pluralsight.training.main under psdir in that package, or the main class also uses the Student.class it'll find under psdir as well, and the main class uses that Other.class. It'll first search under psdir, it won't find it there, but then will find it under libdir. Now if we're running on Unix platforms, it's very similar. We say java, but when we give the ‑cp for class path, first of all, we're using a regular slash because that's what Unix platforms use, but the main key difference here is we use a full colon as a separator. So we first look in /psdir, then a colon says after that, look in /libdir. And then we give it the name of the class we want to run. Now looking at another example, say that under libdir, things are still the same. So it contains the class file for our package, com.jwhh.support, but let's enter psdir. We have actually a jar file, training.jar. And within training.jar is the package, com.pluralsight.training. So at the file system level, all we can see is training.jar. Inside the training.jar is the actual classes that we want. And again, we're going to run our program from mydir. Well, if I'm on Windows, I'll say java. But now when I give the class paths, when I say \psdir, I include \training.jar, which says, actually, look inside that jar file. Then we put the semicolon as a separator and then \libdir. So it says under libdir, we're looking for class files, and then we give our entry point, com.pluralsight.training.main. On the Unix platforms, java ‑cp, again, the same thing except we're using the regular slash. We name the jar file, We use the full colon as a separator, and then we give our entry point. So using these class paths, we can access classes that are in .class files in the file system or can access classes that are actually contained in jar files. In the next clip. we're going to take a look at how using the ‑jar option with the Java command changes the way classes are loaded from using the ‑cp option.

Class Loading with -jar Option
As we've seen in the previous clips, using the class path environment variable, or the ‑cp Java command option, we can access classes that are inside of jar files. Alright, in those cases, jar files were just another place to find the classes that we need. Java provides another way to use a jar file, which is the ‑jar option. And when you use the ‑jar option, what this does is this really locks down class loading. What you're saying is that you want class loading to be totally controlled by the jar file. You don't want any other sources to be involved in how you load your classes. So this jar option is really a way to deploy applications in a controlled way, or I should say a very controlled way. So we see how this works, let's say that I've got mydir, and inside of mydir, I've got a jar file, ourapp.jar, and when I run the jar file, I'm going to say java, and I'm going to just say ‑jar ourapp.jar, and that's it. And so basically what I'm saying now is that I want to do whatever ourapp.jar says to do. So jar files can have a Manifest, so inside the Manifest, it identifies that our main entry point is com.pluralsight.training.Main. So inside of our jar file will contain that package. So we'll have our Main.class, as well as any other class from the package that I need, which is our Student.class, and our Main.class also relies on that com.jwhh.support package, so that's inside here too. So what we have now is a way to just send out this jar file to be installed, and we run it, we simply say java ‑jar ourapp.jar, and now we've got just close control over how our application starts up and what classes it relies on.

Execution Environment Information
Oftentimes an application needs information about its environment. That might be things about the user, like their username or directories that relate to the user, information about the system that the app is running on, information about the Java configuration, and in some cases, we might even want to pass in application‑specific information from the environment. Now, Java provides two common solutions to getting the environment‑based information. One is what's called system properties, the other is what's called environment variables. Now, when it comes to working with system properties, this is information that Java provides about the environment. And we get to it with the System class's getProperty method. And the information that comes in from here, again, is provided by Java, and it's fairly limited in scope, but it's some basic information about the user, basic information about the job installation, and some basic information about the operating system configuration. Now, each of these values is accessed with a string name. Now, there are a number of properties we can access. The URL I provided there gives you a list of some of the most commonly used ones. Now to see this in code, we'll see that it's actually really simple to work with. For example, if I want to get the username, well, I can just call System.getProperty and pass in a string, user.name, and on my system my username is Jim. If I want to get the user's home directory, there's a property user.home. My home directory, you can see there, is \Users\Jim. Things like the operating system architecture, well, it tells me this is an amd64. And if I want to know the vendor for my Java installation on my machine, that's the Oracle Corporation. And there's other things you can get, like you can get access to the Java class path, right, that sort of information. Now, another solution we have are what are called environment variables. Now, environment variables are something that's provided by the operating system. Most operating systems have this idea of environment variables, and it's intended to provide configuration information. Now, most operating system will automatically set some environment variables, but you can also provide app‑specific environment variables. That's kind of a key thing here is that where system properties were provided by Java, environment variables are a combination of information provided by the operating system, as well as maybe app‑specific information. Now, there will be some overlap sometimes between environment variables and system properties, but there also will be a lot of things that are different. Now, apps can access environment variables using this System.getenv method. Now, if you call getenv passing no arguments, what you'll do is you'll get back a map containing all the environment variables. So it's great to see what environment variables are set, that sort of thing. But if you know which environment variable you want, you can call getenv passing in the name of that variable and you'll get back that variable's specific value. All right, so look at this in code. So let's say we stub out here a basic application, and I'm running on Windows so I know one of the environment variables available is COMPUTERNAME. So I'll go ahead and get that by just passing COMPUTERNAME as the variable name. I'll also go ahead and get SystemRoot. Now, pretty much every operating system that I'm aware of, environment variables are case sensitive, so you want to make sure you do match the case correctly. So now if we go and just print these guys out, I can go ahead and run my application, so let's go ahead and launch it, and for COMPUTERNAME, in my case, I get JIM_Y50 and my SystemRoot is Windows. As we said, environment variables are extensible. So let's say I add a line of code here, it says get the environment variable COURSE_AUTHOR, right? So that's not one that's pre‑defined by the operating system. I want that to be one I want to use specific to my application. So I want to go ahead and print that out. Now, at this point, if I go ahead and run my application, of course I'll still get my COMPUTERNAME and my SystemRoot, but I've never set that environment variable, so it comes back as null. Right? So if I'm working with application‑specific environment variables, what I need to do is make sure I set them. So before I run this application, I'll do a set COURSE_AUTHOR=Jim Wilson. So now as I go ahead and run it, in addition to the built‑in environment variables, I can now get access to my app‑specific environment variable. So again, these environment variables allow me to get information about the system that the system provides, as well as just another way to pass information into my application to help my application configure its behavior.

Summary
To wrap up, remember the key thing we were talking about throughout this module is that apps are more than just code, an application's behavior is affected by many factors. The first thing we looked at was command line arguments, the ability to pass on information as part of launching the application. Anything we pass in as a command line argument is received as a parameter to the application's main method. Remember we also had that properties class, which allowed us to have name/value pairs. The key thing is that the properties class can have its instance persisted and restored across application executions. So it's great for things like user preferences or keeping track of civil aspects of application state. Remember, the properties class made it easy to provide default values. All right, we could actually just provide a default on each property access. But even better than that, we could create an instance to the property class, which had our defaults, and then pass that to another instance when we created it. And those defaults could actually including our application packages. So it made it very easy for us to set up our default values included with our app, and deploy them as part of the app package We talked about how we can control how Java locates the classes that our application uses. We do that using the class path. And we could set the class path in a couple of ways. One was we actually used the CLASSPATH environment variable. Now you want to use caution when you do that, though, because remember that that CLASSPATH environment variable can actually affect multiple applications, so changes made to it for one application could break another. So in general, it's better to provide the CLASSPATH using the ‑cp option on Java. That way you're specifically setting your CLASSPATH for each application execution. And then we finished up talking about environment information and how we could access that. So we had two general mechanisms for that, one was what Java provides, which is our system properties. But then we also had access to the operating systems environment variable capabilities, which gave us access to all the environment variables that the operating system sets, but it also made it easy for us to provide app specific variables to get passed into our application. Okay, now in our next module, we're going to take a look at how we can track application activity and behavior using the Java logging system.

Capturing Application Activity with the Java Log System
Introduction
Welcome to the next module of the Pluralsight course Java Fundamentals: The Core platform. In this module, we talk about capturing application activity with the Java log system. My name is Jim Wilson. As we go through this module, we're going to look at a number of topics. We'll start out by looking at log system management. We'll then look at making individual log calls. We'll look at indicating the relative importance of each log message using log levels. We'll look at the variety of log methods available to us. We'll then dig in a little deeper to the log system and realize that the log system is not one component, but actually a series of components. So we'll talk about how to create and add those components. We'll then take a closer look at some of the built‑in handlers and formatters that are available to us. We'll then move over from doing all of our setup in application code to using the log configuration files, and then we finish up specifically talking about logger naming and the hierarchy. But what that does for us is actually really shows us how the pull together everything else we've talked about throughout this module and shows us how to really make the most out of the log system.

Log System Management
Before we get into the details of working with the log system, the first thing we want to address is that why do we need a long system at all? And what it comes down to is that we just need a way to capture application activity. There's a number of reason this comes up. One is that you just want to capture any unusual circumstances that are going on or maybe errors that are happening. Other times you want to just track usage info, just get general information about what's going on with the app. And then sometimes debugging, so debugging that may be not detailed enough to be in an actual debugger, but you're just trying to track things down a little bit. Now the required level of detail in terms of logging varies based on what you're trying to do. There are some scenarios where you need lots of detail. If an app is newly deployed, you want to just make sure that things are stable and going well, or you actually have some error that keeps coming up so you want to capture that information. But in general, we don't need a lot of detail because as apps mature and become stable, you just want to capture maybe some light information, not lots and lots of detail, so we need a solution to logging that covers all these different scenarios. Now there are a number of different logging solutions out there, but Java provides a built‑in solution in the java.util.logging package. Now, in terms of working with the log system, we first need to understand the way log system management works. Now the log system is centrally managed, meaning that there is one application‑wide log manager, and it's responsible for managing the log system configuration, as well as managing the objects that do the actual logging for us. Now the log system management is represented by the class LogManager, and since there's only one app‑wide log manager, there's actually only one global instance of the LogManager class. The way we access that is on the LogManager class there's a static method called getLogManager, which will give us back a reference to that application‑wide global instance of the LogManager. Okay, now in the next clip let's take a look at how we actually work with the LogManager and the rest of the log system to do our actual logging.

Making Log Calls
Now when we work with the log system the class we interact with most often is the Logger class, because that's the class that provides the methods we actually use to do our logging. Now remember we said that the manages the objects that do the actual logging, so when we want to get access to a logger, we get to it using the LogManager class. and there's a method on there called getLogger that we use to access the individual logger instances. Now each instance is named, and there's some interesting things about the way logger naming works, and we'll talk about that a little bit later in this module, how the naming is managed. But there is a global logger that we can use to kind of just get started, and the name of that logger is available on the Logger class's static field called GLOBAL_LOGGER_NAME. Let's take a look now at what it's like to work with this in code. Let's set up some code here, and we're just going to stub out a simple application. Now remember, the first thing we need is the LogManager, so we'll declare a variable for that. We then go to the LogManager class and call its static method, getLogManager. So now lm has a reference to the LogManager. So now we need a logger, so we'll declare a variable for that. We go to the LogManager, we call getLogger. Remember now that each logger has a name, so we'll go ahead and use the name for the global logger. And then from there we use the logger, call its log method and we want to write the entries out. Now each entry has a level, which we'll talk a little bit more about the next clip, and then we provide the message. So we just write out the message My first log message as an informational message. And then from now I can just keep using the logger, .log, and write each one of my entries out. Now conceptually, this is how we work with the logging system. But the way we've done things here is that the LogManager reference lm and the logger reference are scoped within our Main method, which means that each time we want to write stuff out to the logger we have to repeat this process to get to the LogManager and get to the logger. So in practice, we generally use a slightly different technique. Let's look at some more code here. Let's go ahead and stub it out again. But what we do is that we start out with a static reference for the logger and we declare that the class level We then go to our LogManager, call GetLogManager, and then directly against the return value we then call getLogger and the name of our logger. So now our logger reference is at the class level and static so it can be used anywhere. So as we want to go ahead and write entries out, we can just go ahead and use that logger, call .log on it, and write the information out. And we can use that in any method inside the class. So now in the next clip, let's take a look at the idea of the levels that are used with each of our log entries.

Log Levels
As we've talked about, when we're running information to our logs, the exact amount of detail we need to log will vary from time to time, depending on the situation. So we need a way to control that. The way we do it is by using logging levels. So basically, each log entry we write is associated with level, and so it's actually included with log call, and then each logger has a capture level. Now the logger class has a method called setLevel that allows us to set that capture level. And then basically, once we've set that level, the logger will ignore any entry that falls below that capture level. So now the idea of falling above or below a capture level is tied to the fact that each level has a numeric value. Now there are seven basic log levels, plus two special levels intended just for the logger. Now, In addition of these, you can also define custom levels, but in general, you're not going to do that. If you're dealing with a complex subsystem that may need specialized error handling, you may add it there, but in general, you're just going to deal with the built in ones. Let's see what this is like. So, if we look at the logger levels, now at the very top is what's called a SEVERE. Right, and that's when you have just a serious failure, like this is a real error. And so that has a numeric value of 1000. Then we have the idea of a WARNING, which is, you know, to give a warning to potential problem, it has a numeric value of 900. Then we have the INFO level, which is just general information. We have the CONFIG level, and the idea is to capture configuration information, like what kind of CPU am I running on? How much memory is there? How much disc space is there? That sort of thing. And then we get down to the FINE level, which would be just generalized developer information that you want to capture. Then FINER, which we consider detailed developer information. That would be someone who's kind of really down deep in the ideas of working with a particular system or subsystem. And then to have just one more level is the FINEST level, which is just very specialized information. So let's see this in code. Let's say we stub out a little application here. We'll go ahead and get a reference to our logger, and then what we'll do, of course, is we'll take our logger and we'll set the level, and we'll set that level to INFO. So now what that means is, if we take a look at our levels, that if I set the logger level to INFO, I'm going to capture every log entry that has a level of INFO or greater. So that's anything with an INFO, WARNING, or SEVERE. All right, so I go back to my code. So if I have a log that says level.SEVERE, I will capture that. I have one with level.INFO, I'll capture that, because both INFO and SEVERE are greater than or equal to INFO. But an entry with FINE or FINEST, would both be ignored. So these would not make it into the logs. And this idea of checking the level is actually a very inexpensive check. The system checks that very early on and doesn't do any work once it determines that the level is outside the range of interest. So now let's say we go back to our logger levels, and let's say, this time we set our logger level to FINE. Well we'll capture everything with a log level of FINE or greater. Right, so if we look at our code again here, you stub it out, grab our logger. Well, now we set it to FINE. Well, of course, we'll capture SEVERE and we'll capture INFO, as we did before, but now we'll pick up FINE. But we would still exclude FINEST. Now we mentioned that there's also two special logging levels that are meant for the loggers. One of those is what's called ALL. Okay, the ALL level says I want to capture every single thing, whether it's one of the predefined ones or even if someone introduces some specialized ones, we're still going to capture this as well. Then there's also the OFF level, which says, I don't want to capture anything. In the next clip, let's take a look at the methods available for writing information into the logs.

Types of Log Methods
We have a number of different types of logging methods available to us. Some of them do different jobs. Some of them are just for convenience. Now we've seen the simple log method, that's what been using so far throughout this module. There's what's called a convenience method for setting the levels of a message. We have what's called a precise log method, which gives us more precise information or logs. There's convenience methods for that as well. And then there are the parameterized message methods. So let's take a look at these guys. Now first let's look at the simple log method. That's the one we've been using up until now. So I see something like logger.log, level.SEVERE, and Uh Oh! Well what goes into the log file? We get a bunch of information in there. Now of course, we got the timestamp there at the top left, but underneath there we've got the level that we pass as a parameter, as well as the message that we pass as a parameter. But notice we've also got the calling class name and then the method name. Now those are both inferred. We didn't pass those into there, so the system actually looked at the stack frame to determine where you called that from. Now, when it comes to dealing with the levels, there are convenience methods for saying the level. What that does is that we actually identify the level of the message using the method name. And what that means is we only have to pass the message, we don't have to pass the level. If we look at the ones we have available here, there's basically one for each level. So the method severe will log a message with level severe, all right, one for warning, info, and then the rest, right, config, fine, finer, and finest. So the method name identifies the message level. All right, so we look at some code on that. I can simply say logger.severe and pass that message Uh Oh! And I get the same message I got before great. Right, the level was determined by the method name, as opposed to a separate parameter level. We still pass the message here, and then our calling class name and our method name are still inferred. Now, as we've mentioned, the standard log methods infers the calling info, the calling class and the calling method. And that's important because sometimes it gets it wrong. It has to look to stack frames to figure that out. In some cases, that's not necessarily easy for it to do. So there are methods called the precise methods that allow us to specify the class name and method. So the method name is logp, rather just log. And all we do is simply pass a string identifying the class and methods that are making the call. All right, so we look at this guy inside of code here. And so we say logger.logp, and notice that we passed the level, just as we did in the regular log method, but now I pass the class name as a string, the method name as a string, and then whatever we want our message to be. And so now what goes into the log file is, of course, the class name and method names we passed in there. Right, the level and the message, of course, we're already passed, and now we're just adding that additional class and calling method name to make sure we get the right names inside the log file. Now just as there are level convenience methods for the regular log messages, there's also precise convenience methods. And what they do is they simply simplify logging common method actions. All right, so basically it just logs a predefined message. And the two most common ones we use our the entering method, which logs the message ENTRY, and then the exiting method, which logs the message RETURN. Right, pretty straightforward. The thing to remember is that these are always logged at level finer, and you want to keep that in mind because often finer messages don't show up in the logs. All right, so if we take a look at our code here, let's say I've got a method here, doWork, I set that up, and inside of here I want to go ahead and call that entering method. Right, so I say logger.entering. I pass the class name and the method name. That's my only parameters. Let's say I do a log precise here as well. So I have a level.WARNING, so we add the message Empty Function. And then we'll put in an exiting call, so we'll log that. Now, chances are, when I run this code, what's going to show up in my log files is only what was written by the logp, because by default, normally, loggers aren't set to include the finer messages. So what do we have to do? Well, we have to set it to a logging level that will include that. So what I'll do here now is I'll go ahead and just set the level to ALL. So now when I run it, I do get all my messages. I get the entering, which is in the entry call. Then I get the logp call, and then I finally get my exiting call.

Parameterized Message Methods
Now the last method types to look at are the parameterized message methods. And what these really are just specialized versions of some of the messages we've already looked at because basically some of these methods allow us to pass in parameterized values for the messages. So log and logp actually allow us to have explicit substitution indicators in our messages, and they just use a very simple positional substitution concept. It's not that deeply involved string format type of message. It's simply positional substitution where we put curly braces with a zero‑based value inside of it to identify what value we want to substitute in the message. Now remember that entering and exiting don't allow us to specify the messages, but we can still pass in parameter values, but those values simply appear after the default message, and they're just simply space separated. Now the values we pass are always passed as objects so individual values, that's fine, because most things can automatically cast one object, but it can also pass arrays of objects. In that case, it has to be an explicit array, and let's put this in code now. Let's start here. I'll just do a logger.log. And when I set that up, I'll do a Level.INFO. And for my message, I want to say parameter 0 is my favorite. So I'm saying that first part there, {0}, is going to be substituted. So I'll put in a string, Java. So when I go ahead and run this code, what it will log out, of course, it's just Java is my favorite. It substitutes Java where the parameter value is. And I say logger.log, again, Level.INFO. In this case, my message with three substitutions in it, 0, 1, and 2. So now I'm going to pass my values as an array. So I have to create an object array with each of the three values. So if my three values are Wed, the integer value 2, and the string Fri. So now when I run this, I'll get that Wed is 2 days from Fri if the values are substituted. Now looking at the entering and exiting idea. So let's go to a method here called doWork that accepts two parameters, a String left and a String right, and I call that, passing in two values, Jim and Wilson. Now I'm going to go ahead and use the logger.entering. And notice when I enter, I'm obviously going to put my class name and my method name, but I also may want to capture these parameters. So what I'll do then is have an object array that accepts the left and right parameters. So now when I run this code, what gets written out, of course, is the FINER: ENTRY, which is a standard message, followed by the first parameter Jim, space, and then the second parameter, Wilson. Let's say inside my method here, I just concatenate those two values together with a less than and greater than around them. So my result has <JimWilson>. And then when I'm exiting the method, I might want to go ahead, in addition to the class and method name, log my return value. So I just put result in there. So it goes into the log file is the standard message of return, followed by that one value <JimWilson>. Okay, those are our log message types. In the next clip, let's take a look at how we can set up a logger ourselves in code.

Creating/Adding Log Components
As we work with the log system, we think primarily the logger class, but in reality, the log system is divided up into components, with each component handling a specific task of the log process. Now, by doing this, working with the log system is easy to set up for the common things you want to do, but it makes it really flexible to be able to hook things together differently as you need to and it even makes it easy to extend the system, if that's something you need to do. So now if we look at the parts, there are really three core components involved here. Again, the one we're most familiar with is the logger, all right, because that's the one we actually make calls against from our apps to do our log actions. But the log relies on what are called a handler, and the handler is what takes care of actually publishing the log information. In other words, it's the thing it actually writes to the console or writes to a file. A logger has one or more handlers. And then there's what's called the formatter. The formatter is responsible for taking the information that we pass into our log calls and formatting for publication. It may be a simple text message or it might be an XML layout of that information. And each handler has one formatter. So if we take a look at how these all fit together, now within our application, right, we know we interact with the logger, and that's what we make our actual method calls against. When we call one of these log methods on the logger, the Logger class generates an instance of a class called LogRecord that has all the information to be logged. We need the handler to actually publish that. So that LogRecord generated by the logger is then passed into the handler. Remember we said that each handler has a formatter. Well that log record is passed into the formatter, and it's the formatter's responsibility to take the information in that LogRecord and construct a string out of it. Right, again, that could be a XML layout of information or just some simple text description. That string is then passed back to the handler, and then to get it to the outside world, the handler then just passes that string out to it. Again, they could write it to a console window, might be writing to a file, might be sending information out across the network to some listener. And, as we said, each logger can have more than one handler. So we can take another handler instance, and that one LogRecord we passed the first handler and off to the second handler. That handler having its own formatter, taking that information, and then publishing that out to the outside world as it sees fit. So it's easy for us to have a handler, again, that's writing things out to the console, and maybe another one that's logging things into a file. Now we know that the logger supports set level, it allows us to restrict what actually gets logged. Right, and so anything you call into the logger, if it's below the level we set, it just never reaches any further into the system. But it turns out that the handlers can also have set levels. All right, so you can set the level on one handler and set the level on the other handler. These set levels can be more restrictive than the set level calling the logger. Right, if the logger rejects it, it never reaches the handlers at all. But again, the handlers can be a more restrictive. So you can think of something like, we set our logger to record all information and maybe a handler that's outputting to the console also supports all information, but then something that's actually writing out to the file system, maybe you want to catch things that are info or above. So we can have these different levels set inside of there. So the way we tie all this together is we have to create components and add them together. So we create our logger by using the logger class's getLogger static method. Again, remember that loggers have names. And then once we create a logger with the Logger.getLogger method, we can then access it from the LogManager. All right, so in order for a logger to be accessible from the LogManager, it must already exist. The getLogger method on the Logger class can find an existing one or create a new one if it doesn't already exist. Then add our handlers. Well, Java provides a number of building handlers, we'll look at those more closely shortly, and we add that to a logger by calling Logger.addHandler. And then we have our formatters. Again, Java provides some built in formatters. And we add our formatter to our handler by calling Handler.setFormatter. Notice the naming of the methods here. Handler.setFormatter indicates that a handler has one formatter. Logger.addHandler indicates that a logger can have more than one handler. All right, so just to see this in code now, I'm going to stub out kind of a basic application here. We're going to go ahead and declare our logger as static. We'll call our Logger.getLogger, and we'll pass in the name of our logger. So if this doesn't already exist, I'll go ahead and create it. And then from there we can start adding the pieces to it. So we'll declare our handler h, we'll use one of the built‑in handlers, which is a ConsoleHandler, which writes information to the console. We'll have our formatter we call f. We'll use one the built in formatters called SimpleFormatter, which just creates a simple text message of the log information. Then we'll take our handler, call setFormatter on it, passing in the formatter. Call logger.addHandler to add the handler onto the logger. And now we have a complete logger. We have the ability to output it to the console and format it in simple text messages. So we'll go ahead and set its level to record everything at level info or above. And then we can just write our log messages out to it, as we've talked about before. Okay, now the next clip, let's take a look at some of the built in handlers that Java provides.

Built-in Handlers
Now as we mentioned, the logging system provides several built‑in handlers, and all these handlers inherit either directly or indirectly from the Handler class. What that means is that it's relatively easy to write your own custom handler if you need to. But most of the common scenarios we deal with have built‑in handlers available. Now remember that the job of the handler is to get the log information into the outside world somehow. So if we look at each one of these, they just address that in different ways. One is the ConsoleHandler, which we've seen, which just writes to System.err. So if you're doing an unredirected command line, it's just writes it right to the command line window. Often, if you're inside of a development environment, it'll be in your develop environment's output window. We've got the StreamHandler that allows you to create any OutputStream you want and direct it to that. SocketHandler allows you to specify a hostname and a port number, and it'll actually write the log information to that socket. And then we have the FileHandler, and FileHandler writes to one or more files. Now in terms of the ConsoleHandler, StreamHandler, and SocketHandler, they're pretty straightforward. But the FileHandler is actually pretty interesting. Let's take a closer look at that one. As we mentioned, the FileHandler has a couple of output options. It can write to just a single file if you want to, but can also output to a rotating set of files. And this idea of working with a rotating set of files, what it does is it allows us to specify the approximate maximum size in bytes of each of our output files, identify how many files we want to have, and then it was just cycle through them. So basically, as it gets to the end, it will then reuse the oldest one and continue on from there. As we take a look at that, how does that actually work? How can we create this idea of a rotating set of files? We can't just use fixed file naming. So to deal with that, FileHandler provides a substitution pattern that allows us to identify our file naming. And the substitution pattern kind does two core things. One is that it actually makes it simpler to deal with system‑specific issues in terms of things like directory names and directory formats. But the other key thing it does is that it allows us to identify how we want our rotating set of files named. So let's look at the parts of this substitution pattern. So if we look here, the most basic part of the substitution pattern is the slash character. And when you're working with the FileHandler, when we use the slash character, it automatically takes care of whatever the system specifics of your slashes are. So we create a FileHandler with the pattern ./foo .log. When we run that on a UNIX system, well since UNIX systems use a regular slash or what's called a forward slash, it will go ahead and use that same slash. But that same pattern when run on a Windows system will go ahead and convert the slash to a backslash. So it automatically converts the slash to whatever's appropriate for that platform. There's also the %t substitution value, So now if we create a FileHandler using the pattern %t/foo .log, it'll use whatever the configured temp directory is for the system. So in many UNIX systems, that creates a /var/tmp/foo .log. On Windows systems, if you're using a standard configuration, it'll go ahead and use that long temp name associated with the user. So the %t is just substituted for the appropriate temp directory for your system. There's also a %h for the user's home directory. So again we'd do something like %h/foo.log. If we run that on a UNIX system, you'll get a pattern, something like /var/users/jim/foo.log. On Windows, we'll get whatever the configured user directory is, something like C:\Users\Jim\foo.log. So it takes care of those directory names. But the thing that's kind of interesting or the thing that kind of really shows its value is this idea of being able to deal with the rotating log names. If we use the %g, it will go ahead and identify what we call the generation number, kind of which file in the set that it is. So if I create a foo_%g .log, well what that'll do then is that as it goes and creates each file, it'll associate the correct file number in the place of the %g. So we'll get something like foo_0.log. When that gets full, we'll get something like foo_1.log. When that gets full, foo_2.log. And then when 2 gets filled up, we'll actually clear out foo_0.log and start writing into that again. So it just keeps rotating through that set. So now to see what working with the FileHandler looks like in code, let's go ahead and just stub out a basic application here. Go ahead and create our logger as we normally do. I'll go ahead and create our FileHandler here. But before we see the specifics to that, let's go ahead and complete the setup here. We'll go ahead and associate a simple formatter with our FileHandler. And then we'll associate our handler with our logger. So now the key to working with FileHandler is identified in our constructor. So if we look at a constructor here for the FileHandler, we've actually got three parameters. Let's look each one of these starting at the right. On the right‑hand side, we start with that number 4. It says we want a rotating set of four log files. Then the next parameter from right to left is that 1000, which says we want each file to be about 1000 bytes max. And then we have the pattern we're using for the file names. Now the %h says we want to be in user's home directory. Myapp_ says that's literal characters. %g says I want to use the generation number, then .log. So as we run this, the first file we'll get is a C:\Users\Jim\myapp_0.log if I'm running on Windows. The next one is _1.log, _2.log, and then _3.log. Then as 3 fills up, we'll go, back clear out 0, start using that again. As 0 fills up, we'll clear out 1, start writing into that again, and continue that cycle going round and round. So FileHandler just takes care of all these details of working through the set of files and gives a lot of options on how we name them. Okay, in the next clip, let's take a look at working with some of the built‑in formatters.

Built-in Formatters
Now just as the Java log system has built‑in handlers, it also has built‑in formatters. And there are two built‑in formatters, both of which inherit from the Formatter class. Now if the built‑in ones didn't meet your needs, you could inherit from Formatter yourself and return a custom formatter. But most common things we want to do can be done with the built‑in formatters. One is the XMLFormatter, and just as its name implies, it formats the content as XML, and it's a really straightforward layout. It has a root element called log, and then each entry goes under an element called record. Now what's a bit more interesting than XMLFormatter is the SimpleFormatter. And as we've seen, because we've used it a bunch throughout this module, it formats our content as simple text. The thing that makes it interesting is that the formatting that it uses is actually customizable, and it's customizable using the standard string formatting notation that we talked about earlier in the course. So we'll look at the way this works. So if we go over here and we look at one of the standard output messages from the SimpleFormatter. Well the way it produces that output is as if when it formats the message, it calls String.Format, passing in a format string and then the values to be logged. Now the built‑in format string looks like this. Now at first, the format string can look a little daunting. But if we look at it more closely, it's actually doing things we've talked about. Notice that each of the values inside there has a dollar sign preceded by an integer. Like the first one is %1$. Well that means it's using positional notation. If we go through the positions, you notice that date is anywhere 1$ shows up. So if we look here, all that stuff at the beginning the format string that's there is really just a complex formatting to produce a very detailed date notation. They're just kind of really breaking out all the parts of the date that they want to capture there. But then after that, we have source, which is a position 2. Source is just a class and method name. Well, having that %2$s in there simply says we'll format that as string, which produces our source information in the output. Now you notice that after the %2$s, there's a %n, which simply says put a new line, which is what creates the line break. But then our next value after that is logger in our String.Format. Well the default output doesn't include the logger in it. That would just be the name of the logger that produced the output. Now our next value, level, is the fourth position. So if we look at our format string, we've got a string formatting for the fourth position, which produces the level output, which is info. And if we look at the format string, there's a colon, which just puts a little colon out there. And then we have our fifth position, which is the message, which, as that shows up inside of our string, it then produces the message in the output. And then the last position is what's called thrown, and that's the exception information. And that's just associated with any of the log methods that accept an exception as a parameter. We've talked about a whole bunch of different ones throughout this module. Some of the methods we've talked about also will allow you to pass an exception in and log that exception information. So the question is how do we customize the format? And basically what we have to do is set a system property to do that. The name of that property is java.util.logging.SimpleFormatter.format. And one of ways we can set that is by using the ‑D option when we launch the program with the Java command. So let's see what that looks like. Let's say we have our application, and what we want to do when the application runs is capture all the output in a way that we can load it up into a spreadsheet. So comma‑separated values might be a good way to do that. And let's say what we want to do is have the message comma, the source comma, the level, so it looks like the content we have on screen now. Now remembering that the way our content is produced is if we we're using a String.Format under this layout with these parameters. Well the first we want is the message. So we need what's in the fifth position. The next thing we want is the source, so we need to value the second position. And then the last thing we want is the level, so we need the value that's in the fourth position. So the way we do that is that when we get ready to launch our program, we go ahead and run the Java command. ‑D says I want to define a value for a property. We give the property name, equals, and then the format string we want. Well, we first want to have the message, so that's a %5$s, which produces the message in the output. We'll put the literal comma. Then we put the %2$s, which says we want to string for the second value, which is our class and method, the comma. And then finally for the fourth position, which is our log level, followed by %n, which says I want a new line at the end of each one. If we didn't put the %n, each of the values would kind of stack together on the same line. We put in any other options we want and then finally we go ahead and put our program name in. Now one thing I want to note is that all this is being shown on two lines because there's not enough room to show it all on one line. This is just one continuous command line being used to launch the program. But now by launching the program this way, all of our log output will now be produced in that comma‑separated formatting so we can load it into a spreadsheet later. So this idea of setting configuration values tied to the logging system is something we probably should understand a lot better. So in the next clip, let's dig into this idea of configuring the log system.

Log Configuration File
When we're working with the log system, doing application‑based configuration set up gives us a lot of flexibility, but a lot of times we don't need that flexibility. In many cases, we know how we want the log system set up kind of right before we ever start the program. So because of that, the log system allows us to use configuration files to set up the log system. The files we use follow the standard properties file format, and in most cases, we can use the configuration files to completely replace code‑ based configuration. If you have a situation where you want to, you can mix the two together, doing some of the configuration in the configuration file, doing other parts of set up inside your application code. Now in order to use the configuration file, we have to set a system property to identify the file name. The property is there on your screen, java.util.logging.config.file. And then we use the ‑D option to set the property to the name of the file we want to read the information from. Now, the specific value names are going to depend on the classes, but each class documents what values it supports. But for the most part, any code‑based options you want to set are going to be available inside the configuration file. And the way we name the values depends on what kind of class it is. For handlers and formatters, we use the fully‑qualified class name followed by a dot, in other words a period, and the value name. But when it comes to loggers, we use whatever name we've passed to the getLogger method to create the logger, followed by a dot and the value name. Now the best way to see how this kind of works is it gets to compare what we've done in code and then do the same thing in a configuration file. So we get our application here. It's going to stub out an application. And we'll create a new logger, and we'll call it com.pluralsight. And then we'll go and create a ConsoleHandler. So the ConsoleHandler is Level.ALL. Create a simple formatter and then make that the formatter for our ConsoleHandler. Add our ConsoleHandler as a handler to the logger. Set our logger to a Level.ALL, and then once we do that, we're ready to start logging. And then, of course, in this case, if we want to do any kind of customization of the way the simple formatter formats things, when we launch it, we've got to set that java.util.logging.SimpleFormatter.format system property to whatever format we want to use. So now let's take a look at using a configuration file. Let's go ahead and create a file we'll call log.properties, and what we'll do is first, let's set up the ConsoleHandler. So what we'll do here is we'll say that we want to set a value on java.util.logging.ConsoleHandler. We'll set the value level = ALL. Then we'll set another thing on the ConsoleHandler, and we'll say, well, it's formatter is java.util.logging.SimpleFormatter. And then we'll go to our com.pluralsight logger. We'll set its handlers to our ConsoleHandler. Now if we want to give it more than one handler, we could whitespace separate each of the handler names in here if we wanted to. Then we'll also go to our com.pluralsight logger and set its level to ALL. And since we're already here inside of a configuration file, let's go ahead and set up our simple formatter and set its format to be that customized format. So now this log properties file is in place. We want to go out and run our application. We'll launch it with our java command, of course, our ‑D option, and then we'll take our property name, java.util.logging.config.file, point it to our log.properties file, and then give it our application name. So now inside of our application, if we have our code here, we go and stub that out and we create our logger. So we create our logger here with the getLogger call. The system knows we've provided a configuration file for the log system. So basically, what it does is it goes out and looks at our configuration file, our log.properties, Goes through and says, okay, well, I need a ConsoleHandler with a level of ALL. The ConsoleHandler's formatter is a simple formatter. The ConsoleHandler will be the handler for our logger named com.pluralsight. Our logger named com.pluralsight is set to a level of ALL. And our simple formatter is using that custom format. So with all that in place, all we had to do was have our application call getLogger, and when it created the logger, the logger was all set to go. So in most cases, using configuration files is a much simpler and easier way for us to go and set up our logging system. Okay, in the next clip, let's take a look at this idea of the logger names and how the way we name our loggers automatically creates relationships between those loggers.

Making the Most of the Log System: Naming & Hierarchy
Let's look now at the way logger naming works. And although naming may seem like just kind of a simple, arbitrary idea, it turns out that in the log system, naming is a really important part of how things work and actually a really important part of kind of tying together and leveraging everything we've talked about throughout this module. Now, in the log system, the naming actually implies a parent/child relationship. As you go through and you create each of your loggers, the log manager is looking for ways to link those loggers together in a hierarchical mechanism based on each logger's name. So in order to do that, we've got to follow some basic naming guidelines. As you might guess, each logger's naming should somehow follow some kind of hierarchical model. The hierarchical model normally corresponds to the type hierarchy. So just like with package names, we use DOS to separate each level and we generally used the fully‑qualified class name as some mechanism for creating our hierarchy. Alright, so let's see what that looks like. Let's look at a little bit of code here. Let's go ahead and stub out a class, it will be our main class, that main class is our package, com.ps.training. Let's create one logger named com.ps.training, this is the package name, and another logger, the fully‑qualified named the class Main. Now go ahead and stub out another class, which is our Student class, in that same package and create a logger in that, and again, it's the fully‑qualified name of the Student class. Now, just looking at the code, it seems we've created three completely independent loggers, right, one com.ps.training, one com.ps.training.main, and one com.ps.training.student, and there are three separate loggers here, but they're not completely independent. What we've actually done is we have created those three loggers, right, one for student, one for me, and then one for com.ps.training, but because the name for the student logger is actually com.ps.training.student, it's considered a child of the logger com.ps.training. So normally, since Main is in that same com.ps.training naming, it's also a child. The reason that's important, if I come along now and I make a log call against the student logger, it will, of course, log information out to its own handlers. We will then take that information, pass it up to the com.ps.training logger, which then it can also log it out to its handlers. I then come along, make a log call against the com.ps.training.Main logger, it'll log out to any of its own handlers, and again, pass it up to com.ps.training. So com.ps.training has become a kind of centralization point, and this hierarchy can curve recursively so I can create a logger com.ps, that com.ps.training is under, create another one, com.ps.accounting, which is also under com.ps, but separate from com.ps.training. Alright, so now if I come along and make it a log call against student, student logs it out to its handlers, passes it up to com.ps.training, which logs it to its handlers, and then can again pass it up to com.ps and log it to its handlers. Now, looking at this system of the log information flowing up to reach parent, it can seem like it's going to create lots and lots of duplicated log information and done incorrectly, that can happen, but If we understand how to make the most of this hierarchical system, we can actually use this and leverage it to work really effectively for us. What we want to do is focus on capturing important information with the option of getting greater detail if we need it. Fundamentally, the way we do that is by managing our setup primarily on parent loggers, but then make our individual log calls on the child loggers. So how can that actually work? Well, we need to understand both levels and handlers. So we look at our levels. Alright, if we go into the levels, we can see that each logger does not have to have an explicit level set, it's level can actually be null. And if a logger's level is null, it inherits the parent level. So what we'll generally do is primarily set our levels on the parent loggers, and we'll do it at somewhat of a restrictive level like info or warning or severe. And because we've set that level to be somewhat restrictive and that level flows down to the children, were not getting excessive detail. But what we can do is that when we do need more detail from one or more children, we can then set a more detail level on those children. Okay, now, if we look at handlers, it turns out that each logger is not required to have a handler. Now, if a logger does not have a handler, it doesn't log anything, but what it will do is still pass that log information up to its parent. So what, generally, we'll do is we'll add our handlers to the parents that are further up the chain. And remember, those parents will generally have a more restrictive levels, we're just passing the information up to the parents and only logging what's most important, but we can then add handlers to the children if needed, and then those children, remember, can set a more open logging level to capture more information. Alright, so to really put this together, let's take a look at how this kind of all works inside of some code. Let's go here, and again, we'll stub out some application here, this will be our class Main, and what I'll do is I'll go ahead and create that com.ps.training logger and the com.ps.training.Main logger. And we'll, again, get set this up with configuration file. I'm going to start it with a really simple configuration file. We're going to set the handler on com.ps.training to be the console handler and we're going to set com.ps.training.level to info. So other words, that all we've done is set the com.ps.training logger to capture everything info and above and write it out to the console. Alright, so now if we come along here and we do a logger.entering, and notice that we're calling on the com.ps.training.Main logger, so we're calling on the child logger, but we've only configured the parent logger. Remember, the entering log method records information at finer level. Well, basically the com.ps.training logger is set to level info, our main logger doesn't have a level set so it's inheriting that info. So what that means is nothing gets logged. But now we do a logger.log, but this one makes it write out at level info, well, we look at our main logger, it's inheriting the level info, but it doesn't have any handler, so it doesn't log anything, but it passes it up to the com.ps.training logger, which then does capture it. Then we get to our exiting method, well, that's going to work just like entering, right, it's actually records the level fine, and since Main is inheriting the level info, it's not logged. But I also want to some more intense debugging, so this is what we can do is that we're going to keep these same loggers in place, but let's go back to our configuration file, we'll configure com.ps.training just as we did before, but we're going to go ahead and set up a FileHandler to have level all, we'll go ahead and set the parent on FileHandler, and we'll go ahead and set our main logger to use that FileHandler. Notice, though, that we still have not set the level on the main logger, we have it set on FileHandler, but not on the main logger. So that means the main logger is still inheriting the level from com.ps.training. So we make this entering call, which is a level finer, well, main's level is info, so we're still not logged, but now we make that logger.log call with level info, main's level is info, so that gets captured, and we still pass it to our parent so com.ps.training captures it, so it actually went out to our file and to our console. Again, exiting is just like entering so it's not logged because again, it was down to finer level and we're being blocked for everything below info. But now let's make one small change to our configuration file. Let's add one more entry and we'll go ahead and take our main logger and now set its level to all. So now main has its own handler to FileHandler, and it's explicitly set to level all. So Now we call the entering method, which is a finer level call, we'll go ahead and log that to our main logger. We make our log call with level info, we'll go ahead and log it out to our Main, pass that up to our com.ps.training logger and capture it there as well, and then our exiting again because it's finer will go out to our main logger, but not up to the parent logger. Alright, so you see here that this idea of naming is really a key part of kind of tying all these pieces together and creating the hierarchy, and by configuring things primarily at the parent level somewhat restrictive, we normally catch only the most important log entries, but then just change the configuration to get more detailed at a child level, we could capture the details about the children that were interested in.

Summary
Some of the key things you want to remember from this module. Remember that the log system is centrally managed. It means that there is one manager application wide. That manager is represented by the LogManager class. The class we interact with most often is the Logger class. So each logger we create is represented by an instance of the Logger class. And the Logger class is the class that provides most of the methods we use to write information into the log system. Now we rely on levels to indicate the relative importance of each log entry, so each entry is recorded with a specific level. Remember that loggers are set to have a capture level, and a logger will ignore any entry that falls below that capture level. Logger is the class we interact with most often, but remember, the loggers rely on other components. Remember, the handlers are responsible to publish the log information and that a logger can have multiple handlers. Then there are formatters. Formatters are responsible to format the log information for publication. Each handler has one formatter. As we set up and configure the log system, remember we can do it in code, but we can also do it using files where the configuration files give us a lot of flexibility because we externalize configuration from our application. If we're going to get and use files for our configuration, remember, we set the file name to use with a system property. And one of the really important things to remember is that loggers are hierarchical. And that hierarchy is established through each loggers naming. But there's a lot of power that comes from the hierarchy. Remember that loggers will pass their log entries up to their parent loggers, and child loggers can inherit the log levels of their parents. Now remember to get the most out of the log system, we want to leverage this understanding that the log system is hierarchical, so generally, when a manager is set up primarily on parent loggers, but then we make our log calls primarily on child loggers. And what that enables us to do is, for the most part, have just high‑level information recorded of the parents, but when we need to, we can start recording things in more detail down at the child levels. Okay, that wraps up the log system. In our next module, we'll look at how Java handles multithreading and concurrency.

Multithreading and Concurrency
Introduction
Welcome to the next module of the Pluralsight course, Java Fundamentals: The Core Platform. In this module, we'll talk about working with multithreading and concurrency. My name is Jim Wilson. In this module, we'll start by looking at the issue of single threading versus multithreading. We'll then look at some of the foundational types that Java provides for working with threading. We'll look at working with thread pools. Then we'll dig into some of the issues that come up as we run code in concurrent environments. We'll see the facilities that Java provides for simplifying the idea of coordinating method access across threads. We'll look at how to manually manage thread synchronization for those scenarios where we need to do so. And then we'll wrap up our discussion by looking at some of the packages and some of the other types that Java provides from managing concurrency inside of our applications. When we talk about a topic like threading and concurrency, there're two kind of broad categories of viewers that watch a subject like this. There are those who are new to threading, so as they're learning the language, like in this case Java, they're also learning about threading at the same time. There are also those other developers who may be very experienced in dealing with threading in a different environment and now want to understand how to do that same thing inside of Java. The structure of this module addresses both of those needs. If you're someone who's entirely new to threading, so you're learning threading as you're learning Java, you'll find that this module provides the building blocks that you'll need to begin building that understanding of threading and concurrency so you can start using in your applications as you go forward. If you're experienced with threading already, you'll find that this model provides the understanding that you need to take that threading knowledge that you already have and apply that into your Java applications. So whether you're a beginner or your experienced with threading, let's start looking at how threading works in Java, and we'll do that in our next clip.

A Quick Look at the Basics
To get us started, let's clarify a few of the key terms and ideas we'll be using throughout our discussions in this module. The one key term to understand is process. Now process is an instance of a program or application. In other words, it's the thing that gets created when you launch your application. Now process has resources associated with it, things like memory and so forth, and it needs to do its job, and a process has at least one thread. Now a thread, technically speaking, is a sequence of programmed instructions. What that really means is that it's that thing that actually executes your program's code. In order for a thread to do its job, it utilizes process resources. So we'll look at this as a diagram. So we'll go in here and say we launch our application. A process gets created. That process has resources allocated. That process runs over some period of time, and during that period of time, the thread is doing its work. And in standard Java, the process is launched with a single main thread. So if we pick a moment in time, and during that moment in time, the thread is interacting with some known set of process resources. Now if we move into the idea of multithreading, a thread has the ability to create other threads. So our main thread at some point in time may launch another thread, and the main thread may later on launch yet another thread, and one of those threads may launch yet another thread. We're now multithreaded. Our process has multiple threads running inside of it, and at any given moment in time, there are up to four threads running at the same time. Now because these threads are running at the same time, we have the idea of concurrency, those concurrent operations or concurrent execution. So again, if we pick a moment in time, each of those threads are doing their job at that moment in time, but they're all using resources that belong to that single process. Thread 0 is interacting with some aspect of memory, Thread 1 is, Thread 2 is. All that is fine as long as they're not operating on the same resources, but maybe Thread 3 comes along and it needs to use some of the same resources that Thread 2 does. Well, now we've got issues because now we have problems that are related to concurrency, meaning that we need to coordinate the work that these threads do with the resources to make sure that they don't introduce errors. So we'll dig into this idea of concurrency a little bit later in the module and the facilities that Java provides for preventing those errors. But to get us started, we first need to understand how to make our Java programs multithreaded, and that's what we'll begin looking at in our next clip.

The Move to Multithreading
So why is multithreading important? As you might expect, multi‑threaded programming can be much more complicated than single threaded programming, so it must provide some value. And the most fundamental value is that enables more complete usage of our CPU resources. When a thread is running to dual programs work, oftentimes that thread is waiting for non‑CPU things that happen. Right, it's doing things like interacting with storage device, interacting with the network, and so forth. So when that stuff's going on, the thread can't take advantage of the CPU, so our CPUs might be sitting idle. Also, most modern computers today have multiple cores inside of them. What that means is that most modern computers are built to run things in parallel. Pretty much every desktop computer or server computer is multiple core, and a really large percentage of smart devices now have multi‑core CPUs. So devices are built to run things in parallel, and we use multithreading to do that. And so what that really does for us is that when we use multithreading appropriately, the task that we run can actually take less time. And the reason I say less perceived execution time on the slide is that when we say less time we mean less wall clock time. Multithreading programming takes up however many processing cycles it takes to do the job. In fact, in general, multithreaded programming is going to take more CPU cycles to do the work than single threaded programming would. But because it can do that work in parallel, the amount of time it seems a process to take, or seems a task to take, is actually shorter. So with multithreading, we take full advantage of our CPU resources, and because of that, our work gets done more quickly. To help us get a better sense of how multi‑threaded programming will work, let's take a look at a little bit of code here. I've got a really simple class here called Adder. And the job of the Adder class is to simply be given an input file, add up all the numbers inside that file, and then write the result out to another file. So in order to do that, we'll need a couple of fields for the file names. We'll go ahead and have a constructor that accepts those file names. We'll have one method we'll call, doAdd. And again doAdd's job is just to add up the numbers inside of a file and write them out. So we'll go ahead and have a look over here to total up the values of a local variable. Here's a string which will actually represent the input line. Then to do the work, we'll go ahead and open up a BufferedReader over the input file. We'll loop through the file reading one line at a time, and then for each line we'll convert it into an integer, add it to the total. Once we've added up all the lines, we'll go ahead and open up an output file and then write the result out to that file. Now, since we're interacting with the BufferedReaders, we know those guys throw IO exceptions, so our doAdd method declaration needs to show that it throws IOException. Since we're doing this IO work, that means we're dealing with IO devices, storage devices. Interacting with things like disks, and so forth, is a non‑CPU task, or at least it's not CPU focused, it relies on storage devices. So things like opening the files, reading from the files, writing to the files, are all things rely on devices other than the CPU. Those are cases where our thread is not taking advance of CPU resources, but relying on other resources. So there's an opportunity there where multithreading may come in handy Now let's take a look at using this class in code. So I'm going to go ahead and just declare an array containing six file names, file1.txt through files6.txt. Another array containing six output file names. Then what I want to do is simply create a loop to walk through those arrays. For each pass through the loop, I'll create a new instance of our Adder class, passing in an input file and an output file. So I'm going to call adder.doAdd, in other words, do the work to add them up. Now, since doAdd is declared to throw IO exceptions, we need to go ahead and wrap this guy up in a try catch block to deal with that. All right, so that's really simple code. Now, the way this is currently written, this is a single thread of application, right. So if we look at this conceptually, we have our process here, when our process starts up, the main thread does any startup work it needs to do, and then it does the work to use doAdd on file1, and then after that's done, it does the work to add up the contents of file,2. It does that for all the rest of files until it finally gets the file6. And then at the end, it does any clean up work. And all this work was done linearly. So it's done over a relatively long period of time because there's a lot of waiting going on. Remember that during the times we're working on file1, the CPU would be waiting for content to be read from a file, so the CPU is kind of idle. Also, there's probably multiple cores on this device. So we're doing this work one by one when there's really an opportunity to do things in parallel. So to take full advantage of this computer, what we should probably do is rework this from a single threaded application to one that takes advantage of multiple threads. So the way that will look conceptually is that when we start up, our main thread does any startup work, but then it goes ahead and fires off a separate thread to process the contents of file1. It could then go ahead and fire off another thread to process the contents of file2. Do that for all the files inside there until gets to file6. While that work is going on, the main thread is free to do other work, waits for everything to get done. When all six files are done, it goes and does its cleanup work. So we've still done the same amount of processing, but the amount of time that's gone by is much less because we're taking full advantage of the CPU resources of the device. Now the thing is that as we move to multithreading, there's something we need to be aware of. Multithreading is an explicit choice. In other words, we don't get it for free. That means we have to break our problem up into parts that can take advantage of multithreading. And then we need to hand off that work to the different threads to do it. Java provides different levels of abstraction for doing threading. It has some very direct handling available where we actually manually create and coordinate the work of our threads. But it also has some higher level abstractions which simplifies that process of creating and coordinating. We'll take a look at some of these different options throughout the remainder of this module, starting with direct thread handling in our next clip.

Java Threading Foundation
As we'll see, Java provides a variety of different levels of abstraction over the idea of threading. But the most foundational aspects of that provide a very limited abstraction. In other words, the basic threading types in Java are very close to the way threading works in most operating systems. Basically, each thread is started to do a specific task. When that thread finishes that task, the thread terminates. When we're working at this level, we're responsible for any kind of management that has to go on. We're going to be responsible to do any kind of coordination. That's all going to be our responsibility. And the exceptions that occur in a thread are tied to that thread, meaning that each thread is responsible to handle any exceptions that occur on a thread. Now there are two core types that we use when working at this level. One is the runnable interface. The runnable interface represents some tasks to be run on a thread. Has exactly one member, the run method. The other type we use a lot at this level is the thread class. It represents a thread of execution. This class allows you to interact with that thread and effect a thread state. Now simply creating this as a thread class does not start the thread running. The thread doesn't start running until we call that thread's start method. Let's look now at how we can apply this idea of threading to the code we wrote earlier. Remember that we wrote that class earlier called Adder. Remember that it had two fields in it, one for an input file, one for an output file. Had a constructor that accepted those file names. And then we had that method doadd that did the actual work. Remember that it took care of opening up the input file, reading through its contents, adding up everything inside the file, and then writing that total out to the output file. Well, we mentioned that this class was a good candidate for taking advantage of threading, so let's go and update it to do so. Now, in order for this class to indicate that it can be run on an alternate thread, we need to go ahead and implement that runnable interface and implement the method on the interface, which is the run method. So this now indicates that this class understands how to be run on another thread. What we'll do from a run method is the work that we want to do on the other thread, which is simply call our doAdd method. Remember we said though that any work that happens on the threads is now a responsibility of that thread to handle the exceptions that occur. So we're going to have to go ahead and wrap our doAdd and our try‑catch inside the run method. So that simple change of implementing the interface now indicates that our Adder class knows how to be run on an alternate thread. Now let's go to our main application code. Now remember that our application code right now is written to use our Adder class single threaded. Remember that we have the arrays of input files and output files. We have a loop to loop through those files, we go ahead and create the instance of the Adder class. We directly call doAdd on it, and we wrap all that in a try‑catch to handle the exception. This is our single‑threaded implementation. To move this to take advantage of the multithreading capabilities of our Adder class, what we're going to do is that, instead of calling adder.doAdd directly, what we'll do instead is create an instance of our thread class, passing Adder to the constructor. The thread constructor expects an implementation of runnable. Adder implements runnable so we can pass that to the constructor, and then we can call thread.start. And that will now run each instance of the Adder class on a separate thread. So we're looping through each of the six file names, creating a new Thread for each one with a separate adder instance for each one. So each of the six files now are processed on six separate threads. Remember we said, though, that the exception is the responsibility of the thread. So since the background thread is handling the IOException that the adder.doAdd method might throw, we'll get rid of the try‑catch block in our code here, The code that we have written currently will take care of running each of the Adder instances on a separate thread, but there is one potential problem if this is our main application code. So let's take a look at the diagram representing what's going on here. So we have our process. Our main thread starts up, and then what's it do? It starts firing off other threads. So it fires off one thread to handle the first file to work on, fires off another thread to handle the other file work on, and it does that for each of the six files until it has six threads running six Adder instances working on the six different files. Once that's all done, the main thread has no more work to do. So because the main thread has no more work to do, in some instances, the background threads may never get a chance to finish. Because in some instances, once the main thread terminates, the entire process gets cleaned up. So what we want to do is make sure that all of our background work gets done. So what we want to do is take our process, do the same work we were doing before, go ahead and start up, fire off those background threads to do work on all the six different files. But what we want to do is make sure that our main thread waits for the other threads to finish their work and then shuts down. That's a very simple change to our application. So let's go back to our code. Currently, we have a local thread variable for each of the threads that are created. What we're going to do instead now is create an array of threads. So now we have the ability to store references to multiple threads. So then our code here that has the local thread variable, we're going to change that so that each time we create an instance of our Thread, we'll add that reference into the array, we'll of course go ahead and do the start against the references. But now, once those six threads are created, we've got references to each of the thread objects. So what we can do is that after they're all started, we can have another loop that goes through each those thread references and calls join on each of the threads. What that causes to have happen is that this calling thread will block until the other thread finishes. In other words, our main thread, as it calls thread.join to those threads, the main thread will block until the background thread finishes. If the background thread is already finished when we call join, join returns right away. If the background thread is not done running, then our call to join will block until that background thread finishes. This assures that our main thread continues running until all of the background threads are done doing their work. As you can see, when we're working at this level, we're responsible for a lot of the details. So in our next clip, we're going to take a look at some of the types that are available that will abstract some of those threading details from our code.

Thread Pools
In the previous clip, we looked at the Thread class. And the Thread class is a really powerful class because it gave us very direct control over threads, their creation, coordination, startup, shutdown, that sort of thing. But with that kind of control, it presents a challenges. It's that we're responsible to use those capabilities effectively. And if you're not a seasoned threading programmer, it's really easy to misuse threads if you're not familiar with how to do that. And honestly, most of us don't want to be caught up in those details anyway. What we really want to do is just have the advantage and capabilities of threads, but let kind of the details be taken care of for us. And that's where thread pools come in. Thread pools abstract a lot of the threading details away for us. What a thread pool does is it provides a queue for us to go ahead and put tasks into, and then the thread pool will then take tasks from the queue and assign them off to threads in a pool to do the actual work. And the details of actually managing the threads and knowing when work is done and so forth is handled for us by the thread pool. Now there are two core types we're going to look at tied to thread pulls. One is the ExecutorService interface, and that models thread pool behavior. It gives us the ability to submit tasks into the pool, it allows us to request the pool to shut down, and then wait for the pool shut down if we want to. Then there's the Executors class. It provides methods for creating thread pools. So we can create a number of different kinds of thread pools. We can create thread pools that dynamically size, in other words the number of threads inside them will change based on the need. We can create thread pools that have a maximum number of threads inside of them. We can even create pools where you can put tasks and say well don't start this task for another 2 minutes or don't start this task until sometime later, that sort of thing. So these, to understand, let's just take a look at code. So now let's look at the code we had when we finished up at the end of the last clip where we we're actually directly managing the threads ourselves. So we had our six files, and we just assigned those off, each one to a separate thread. Now this is really simple threading code. In fact, most threading code gets much more involved than this. But even code this simple can introduce problems. What if we went from 6 files to suddenly having 1,000 files to process, and there's 1,000 really large files to process. Well on many systems, if we suddenly fire up 1,000 threads all processing large files, we could choke the system down really badly in the sense that the overhead of just managing those threads and trying to coordinate that disk access could make the system run really inefficiently. So this is a great chance for us to use a thread pool. So what we'll do is take all this thread code we have in here now, let's go ahead and take that out. And what we'll do instead is use a thread pool. So we'll declare a variable of type ExecutorService. We'll then go to our Executors class. And we're going to use the newFixedThreadPool method. What this does is create a thread pool that never allows more than three threads at a time to exist. And then once we have that thread pool, we can take our Adder class because remember our Adder class implements the Runnable interface, and we can simply submit instances of our Adder class into the thread pool. The thread pool will then take care of accepting all of that work and assigning them off to threads to do the work, but never more than three of them running at the same time. When we're done with the thread pool, we can ask it to shut down. What shutdown does is it simply says go ahead and finish any work that's already been assigned into the pool, but don't allow any new work to be assigned into the pool. And then if we want to, we can wait for the shutdown. So in this case, we're saying that we're willing to wait up to 60 seconds for the pool to shut down. And we'll go ahead and wrap that in a try‑catch block because these can raise exceptions. And now we're taking advantage of thread pools to do our Adder processing. And again, this will work equally well with 6 files or 6,000 or 60,000 files because the thread pool will take care of limiting how much work happens at one time. So that's graphically what our program was doing. So we had our process, and when our program started running, the main thread in it started running. From our main thread, we created a thread pool, which gave back a reference of type ExecutorService. And then we started submitting work inside of it. So basically, when we submitted the work to the thread pool, it put that work into a queue. So the Adder instance for the first file went into the queue. And then it went ahead and assigns that work off to the thread for us. Now when we submit the next bit of work for the next file, it automatically assigns that to a thread as well. And the next one assigns that to a thread as well because remember we said that up to three of these could happen at the same time. Our pool could have up to three threads inside of it. But now as we go off and we assign the work for the fourth, fifth, and sixth files, those just go into the queue, but they're not being worked on yet. And then once all that work is submitted because we call awaitTermination, our main thread will now block waiting for the work to get done. Now once one of the threads finishes, the next work from the queue inside the ExecutorService can be assigned and have that worked on. Then when another thread finishes, the next thing from the queue could be assigned to that and worked on. And then again, when the thread frees up, the last one can be worked on. Once all that work is done, our awaitTermination returns, and then our main thread can go ahead and finish its job. So you see there that we're able to kind of really focus on what we want it to do, have a task that we want it to be able to be performed in the background. But we simply handed all the work off to the ExecutorService in terms of managing thread assignment, thread lifetime, all that stuff. We got to focus just on assigning the work off to be done. Okay, now in our next clip, let's take a look at how we can use the ExecutorService and then pass results from our background threads back into the Main thread.

Creating a Closer Relationship Between Thread Tasks
So far, all the threading work we've done has been really loosely coupled. What I mean by that is that when the background threads run, none of them care what the other threads are doing, and the main thread doesn't really care about what the background threads are doing, other than the fact that it waits for them to get done. But multithreading isn't always loosely coupled like that. It's very common for us to launch work into the background, then have the thread that launched that work want to get the results of that work that was done. In other words, the main thread launches a background thread to do some work, and then the main thread wants to get those results back. And in terms of getting results back, it's not just getting the actual data values back, it probably wants to know whether the background task succeeded or not. Now we can actually write code to do that, but we would like a simpler solution. So let's think about what it's like to manually deal with these problems. Let's first go if we want to manually get back result from another thread. So our main thread starts up, and then it launches the background thread, and then we know it hangs up there to wait for that background work to get done. If the background thread then wants to return some result back, what we have to do is do the work to take that result, place it someplace where the main thread can get to it, like in an object reference or something like that, then have the main thread explicitly go look for it. When it finds it, it's got it, and it can carry on. So that's our success case. But now let's look at the idea of exceptions. So, again, our main thread starts up, launches the background thread, we want our main thread to hang out and wait for the results, but now that background thread throws an exception. We know that as we've done things so far, the background thread is responsible to handle that exception, but now if the main thread wants to know about that exception, then our background thread has to have the work to store that exception information somewhere so the main thread can go out and get it and then carry on accordingly based on that error. And that's a lot of detail for things we probably want to do a lot. We'd like to simplify this. Let's think about the idea of having our main thread go off and launch a background thread as it waits for it. Well, if that background thread produces a result, why don't we just take that result, hand it to the main thread so once the main thread gets it, it can carry on. Similarly, if we start up the processing in the background and our main thread waits for it, if the background thread throws an exception, let's just pass that exception information right back to the main thread, let it have the try catch in place for it, and proceed accordingly. So we want to move much more to that kind of model, not having to do all the manual work, and Java provides types that allow us to do that, and we're going to look at two of them now. One is the Callable interface. The Callable interface represents a task that can be run on a thread. It's very much like the Runnable interface, except the key difference is when we use the Callable interface we can return results from the background thread, and we can throw exceptions. Now the only member on the Callable interface is the call method. Now that's how the thread actually takes care of returning results. We need a way for a caller to be able to harvest those results. That's where the Future interface comes in. It represents the results of a thread task, and our ExecutorService.submit method has an overload that can return back a future reference. Now Future interface has a method on it called get. Now the get method blocks until the background task completes, but it can also return back the result returned by the Callable interface, and it can throw an exception if the Callable implementation throws an exception. So let's take a look at our code and see how we can implement this and take advantage of these capabilities. Now remember that our Adder class has that method doAdd. And right now the way doAdd is implemented is that we have some local variables to keep track of the totals and get back an input line. We open up an input file, we go ahead and loop through the input file adding up the contents, then we open up in output file and we write out that total. Well, what if we want to actually change our doAdd so that It doesn't just write to a file, but it returns that total back so we can use it? So what we want to do then is instead of this being a void method, we'll have it return an int. And we're not going to worry about writing to an output file, instead we're going to return back that total. So now our doAdd method does the work of tooling up the contents of the file, but then gives the results back in a way that they can be used however we want to use them. So now if we look at how that affects are Adder class. Now right now our Adder class implements the Runnable interface. Now, we're only going to have one file now because it's an input file and we'll have a constructor to go with that, but we've got that doAdd that we just updated to return back the totals that returns the integer. Now we're implemented with the Runnable interface, we have our run method. Remember, we call doAdd inside of there, and we have to put our exception handling in place ourselves. We're doing all of that on the background thread. But now let's take our Adder class, and instead of using the Runnable interface, we'll instead now use the Callable interface. Remember, the Callable interface allows us to return back a result, and we can indicate that type that it returns. We're going to say this is a Callable that returns back an integer. Now remember that an integer is a reference type, and we have to use a reference type. So even though our doAdd returns back an int, a value type, we're going to go ahead and template on integer the reference type equivalent to that. Now one thing we need to do, of course, is now that we're using Callable, instead of our method being called run, it'll be called call, but then it will also return back a value. So the return type here is going to be integer instead of void, and we're also going to indicate that we throw an exception. We're going to throw the IOException. So since we can actually now throw the IOException from the call method, we don't need to have our try catch block inside of here, and now rather than simply calling doAdd, we're going to actually return back doAdd. So now we have our Adder class implemented in a way that can be run on a background thread, but it can return the results back, including any exception it might throw. So let's see how we use this class now. So we're going to go ahead and have our array of input files, we're going to have our ExecutorService just as we did before, and we're using this with a 3‑thread ThreadPool. We'll go ahead and loop through the input files. We have our Adder instances we create, and remember that we were calling ExecutorService.submit to run that back when it was Runnable, but now we're going to move to using Callable. So one of the things we need to do is declare an array to get the results back of that work in the background. So what we're going to do is have an array of type Future, remember Future represents a background task. It's also templated on the return types, so this is going to be a Future that has a background task that returns an integer, and so we add that as an array. And so now, rather than simply calling ExecutorService.submit, what we're going to do is have our results array, that Future array equals ExecutorService.submit. And so what will happen now is that as each task is launched in the background, a reference to the Future implementation representing that task is put into our results array. So now we've got all those tasks running in the background, the ThreadPool is managing all the coordination between them, and so when it becomes time to get our results back, what we'll do is we'll loop through our results array, right, that array of Future. And we're going to call result.get on each one. Now the get blocks until the work is done, but then it can return that work back to us. Now remember that our doAdd method returned an int, our Future and our Callable are on the reference equivalent integer, but we can go ahead and use that locally here as an int if we want to. Remember, Java can generally take care of converting between int and integer for us as it needs to. So now we've got the return value in our value variable, we can do whatever we want to do with that. So that takes care of our success case, but remember that also our exceptions could make it across, so we can put this in a try block. Remember that our background work returns back on IOException. Well, we're not going to get an IOException here, but what we'll get is an ExecutionException, indicating that something happened in the execution of the background task. But inside that catch block we can take the exception and call its getCause method, and that will get the original exception, so that will then give us a reference to the IOException that happened on the background thread, and we can do whatever work we need to with that. We can, of course, also catch other exceptions that would be related to things that were not happening in our background Adder work, but any other exceptions we need to handle. So now, by using the Callable interface and the Future interface, we're now able to take advantage of background threading work, but get those results over to another thread easily. Okay, now in our next clip we're going to take a look at scenarios where we need close coordination between threads so we can synchronize access to objects of interest.

Concurrency Issues
Up until now, the multi‑threading we've been looking at has been relatively independent. What I mean by that is that each thread that we've looked at has been doing a job that's been relatively independent from the job performed by the other threads. Remember, early in this module, we mentioned that as we get into multi‑threading, we sometimes get into concurrency issues, and I said we'd talk about those a little later. Well, we're now at the time where we talk about them. The issue is that concurrency can create challenges because once threads start to share common resources, you have the potential for problems. Now, if those threads are sharing a resource and they're only reading those resources, in other words, they never change them, they only look at what's inside of them, there's really not much issue there. But as soon as threads start to change shared resources, we've got to coordinate that work because if we fail to coordinate that work, we're going to have problems. At a minimum, we can start receiving incorrect results. But things can actually get a lot worse than that, programs can start crashing, kind of just crazy things can start happening. So now, as so often is the case, the best way to understand what I'm talking about here is to look at some code. Let's start with a very simple BankAccount class. It has one field in it, which is the balance. It has a constructor that accepts a starting balance, which is then assigned to the balance. It has a getter method that will return back the value of balance. And it has a deposit method, which accepts an amount and then increases the balance by that amount. Let's go ahead and create a Worker class that will use that bank account, and as the Worker class here implements Runnable, which means it can be run on a thread, it has a member field for the BankAccount, a constructor that accepts the BankAccount and assigns it to the field, and then we have our run method. So instead of our run method, we'll go ahead and say we'll get the starting balance. We'll go ahead and deposit $10 into the account and we'll get the ending balance. Now we're not doing anything with that starting and ending balance here in our code, but that would be great for logging or debugging if we needed it to. And then we'll take those three statements and we'll put them inside of a loop that runs 10 times. So, basically our run method will deposit $10 dollars 10 times. Of course, in order to use our Worker class, we've actually got to run it. So what we'll do then is go ahead and create an instance of our executive service. It has a thread pool with five threads in it. We'll go ahead and create an instance of a BankAccount with a starting balance of $100. We'll go ahead and create an instance of our worker, passing in that account. Then we'll submit the worker into our executive service, right, into the thread pool, and then we'll wait for it to finish. So you notice that we've got five threads in our pool, but right now we're only using one of those threads. So now if we run this code and we start looking at what's going on inside of there, it'll first pass through the loop, right, the Worker class would have an ending bounce of 110 after adding $10 to the starting balance of 100, then 120 after adding $10 to the starting balance of 110. Then, 130, 140, all the way through until it gets to $200. Right, because we started with 100, we added 10 ten times, got to $200. Really straightforward. But now let's make a very small change to this code. All we're going to do is take the code where we create our worker and submit it into the thread pool, let's go ahead and loop through and do that five times. So now we're going to have five worker instances to take advantage of the five threads inside the thread pool. So what's going to happen when we run that? Well, let's think about it. We started out, in our first example, we started out with a bank account with $100 in it, we had 1 thread, inside that's thread we added $10, $10, $10, and kept adding $10 ten times. So once we added $10 ten times to 100, we got 200. Well, now we have five threads. I'm going to start with a bank account with $100, and I'm going to add $10 on 1 thread, $10 on another thread, $10 on another thread, another thread, and finally, we've got $10 being added on 5 threads, and then each of those threads are going to keep adding $10 until each of those 5 threads add $10 ten times. So we started out with $100, we have 5 threads, each add $10 ten times, it would certainly make sense we would end up at the end with $600. And maybe we will. Or maybe we'll end up with $580. Or maybe it's $590. Or maybe it's $550. The reality is, we don't actually know what we're going to get when we run this code. The way we have it currently written it's not safe to work with multi‑threading. Now, maybe we could get a hint about what's going on if we kind of take a look at some logs that go with this code. So we go ahead and take a look at the logs. We're going to log the same information we did before, right, an ending balance, a starting balance. I'm always going to know which worker it is. So you notice here the first pass through, we get an ending balance of 110 after adding $10 to $100 starting balance. That happened on Worker 1. And we get to 120 because Worker 2 added $10 to the 110. We get to 130 because Worker 3 added $10 to the 120. That's going pretty orderly, 140, 150, and things seem to be going really nicely, here, right? Each worker thread is kind of going in order, right? 1, 2, 3, 4, 5. We get to the next pass, notice that suddenly things aren't so orderly. Notice that Worker 5 actually just ran twice in a row. That's okay, because we still went from 150 to 160. Then, we get to Worker 3 running, adding $10 to the 160 so we get to 170. But then we get to Worker 2, who also started with 160 and got to 170. Something is clearly going wrong here. Let's let this code run a little bit more until we get near the end. We get to a point where we've got an ending balance of 510. Then we get from 510 to 520 by Worker 5, and then Worker 1 also goes from 510 to 520. So again, we've seen two workers again increment at the same amount again. If we let this run to completion, when it finishes, we've only gotten to 550. So, even though each thread added $10 ten times, we did it on 5 threads and started with 100, we only got to 550, not to 600. And just a note, I didn't make this log date up. This is the actual log output from the code that I showed you in the previous slides. So let's try and understand what's really going on here. So let's go back to our BankAccount class. It's important to understand that there's more going on here than meets the eye, right? We have that getBalance method that returns the balance, and we have our deposit method. Notice those two methods are independent. The only thing that's going on in the deposit method is a simple += on the amount. In other words, we increase the balance by the amount. I think it's important to remember that even though something might be a single statement in our Java code, that doesn't mean it's actually a single operation for the computer. It turns out that in order to do a += like that, there's actually multiple steps that have to occur. In order to actually increase the balance, we've actually got to read the current value of the memory that's associated with balance, perform the arithmetic to do the addition, and then we have to write that value back. We call this a non‑atomic operation. In other words, it's composed of multiple steps, and those steps do not all happen at one time. Because there's multiple steps that don't all happen at one time, it's possible for changes to happen from another thread while this thread is doing its work. To get a better sense of what I'm talking about, let's go back to this kind of process and threading diagram we've used a lot in this module. So, in our memory, we go ahead and create an instance of our bank account we called account, that contained its balance, we fired up a bunch of threads, and let's focus just on Thread 1 and Thread 5. And let's pick up where our balance was at 510. Let's say Thread 1 reads 510 from the value that's inside of memory. It goes ahead and increments it by 10 to get to the 520, but now before it has a chance to write that 520 back into the memory that's associated with balance, Thread 5 now reads the balance, and what does it find there? Well, it finds 510 there. Now, Thread 1 goes back and takes the 520, writes it back into the balance memory, updating that memory from 510 to 520. Now, Thread 5 continues on with its work. Well, it read the value as 510, so it adds 10 to it to get to 520. It then writes that back to our balance memory, and what it does is it replaces the value that was there. It replaces the 520 that was already there with 520. And now we have an error. Because these two threads were not coordinated, we're now getting wrong information. So what we need to do is update things so that we actually coordinate the work of these threads. So again, create our BankAccount instance with the balance inside of it, we'll fire off those same threads, Thread 1 and Thread 5. We'll again start at a value of 510. As we read that 510 on Thread 1 and we go ahead and increment by 10 to 520, well, if Thread 5 now wants to get access to the balance, it's just going to have to wait. So what we want to do now is have Thread 1 go ahead and write the 520 back into our balance memory to move us from 510 to 520. Once that finishes, Thread 5 is now allowed to read that value, the 520, increment it by 10 to get to 530, and as it writes it back, replaces 520 with 530. Now those threads have coordinated their access to the value in the memory called balance. So the question is, how do we do that in code? And that's we'll take a look at in our next clip.

Coordinating Method Access
As we saw in our last clip, there are times where it's really important that we coordinate concurrency. Now Java provides a few different ways to do that. One tool it provides is something called synchronized methods. Now what synchronized methods do is they coordinate thread access to methods. Now any method could be made synchronized by simply adding the synchronized modifier to that method. And a class can have as many synchronized methods as it needs. Now, method synchronization is not managed at the method level, it's actually managed at the class instance level. And what that means is that if you have an instance of a class and one thread calls into a method that's marked as synchronized, no other thread can call into any method marked as synchronized on that same class instance. So now, as we think about using this idea of synchronized methods, when do we use these? Well, one example that comes to mind pretty quickly is the idea of protecting modification by multiple threads. Right, we saw in our last clip that things got really mucked up pretty good because two threads were trying to modify the same value at the same time. So that's an obvious case. Another case where it's important to utilize synchronize methods is that when we're reading values that might be modified by another thread at the same time we're reading them, it's possible that the value we're reading actually gets corrupted as we're reading it in as another thread is modifying it. There are a few caveats where that's not always necessary. But in general, that's a really good idea. So protect both modification of values, as well as the reading of values that might be modified by another thread. Now you might be thinking that, wow, this synchronization is pretty cool stuff. Why don't I just synchronize every method? And the issue is that this synchronization has a fairly high overhead. It takes a fair bit to go on and actually make all this work. So you really only want to use these synchronized methods in multi‑threading scenarios that require it. Now one thing we want to note here is that constructors are never synchronized because any given object instance is created on exactly one thread. And remember that synchronization occurs at the instance level. All right so there's no way for two threads to create the same instance at the same time. So because of that Java won't even allow us to mark constructors as synchronized. So let's look at that BankAccount class that we were using in the previous clip, and how we make this now thread safe using synchronized methods. Well, we saw our deposit method mess up in that last clip. So let's take our deposit method and all we're going to do here is add in the synchronized modifier. So now deposit is considered a synchronized method. And we said it's also a good idea to protect methods that read values that can be modified by other threads. So we're going to take our getBalance, and we're going to go ahead and mark that as synchronized as well. So now both getBalance and deposit are synchronized. Now what that means is that if one thread is calling in the getBalance, no other thread can call getBalance or deposit. The same way, if one thread is in deposit, no other thread can call deposit or getBalance. Okay and remember that synchronization occurs at the object instance level. Right, so all synchronized methods on the same object instance are protected from multi‑thread access. Remember, though, our constructor is not marked as synchronized because we never mark constructors as synchronized. Now, that one simple change will now make our application run correctly, with no other changes other than marking those methods as synchronized. With this method, synchronize, we can start out with our $100 initial deposit. Start writing $10 on one thread, another thread, another thread, another thread, all the way up to our 5 threads. Have each of those 5 threads keep adding $10, $10, and $10 until each of the 5 threads each adds $10 ten times, and when we get to the end, we will have $600. And we will have $600 every single time we run this because the synchronized methods protect us from the concurrency issues we saw in the last clip. Let's look at the same diagram we've been using throughout this discussion to get a better idea of exactly what's happening with these synchronized methods. So we'll go out here and we'll go ahead and create our bank account instance that has our balance inside of it. We'll go ahead and fire up our two threads that we've been looking at, and we'll start out with that same $510 balance that we've been looking at. So now let's think about Thread 1 goes to go ahead and make a deposit. So as a Thread 1 goes to call in to deposit, before it actually gets to the code body inside of that method deposit, a check is made against the bank account instance to see if it's locked. Every object instance has one lock space on it. So what happens is that the Thread 1 code goes and checks, says nope, there's no lock there. So it goes ahead and it acquires that lock on that object instance. Once it has that lock, the body of our deposit method begins to run, right, we get the value from the balance of $510. We go ahead and increment it to $520. Now at the same time Thread 5 says, okay, I'm going to call into that deposit method. Well that call into the deposit method triggers the check of the lock, it sees that the lock is already held, so Thread 5 now has to block, waiting until it can get in. Thread 1 finishes its job, right, goes out there and writes the $520 back into the account balance, and then when it's all done, it releases the lock. So the process of leaving the deposit method releases that lock. Thread 5 is notified that the lock might be available, so Thread 5 goes out and checks again. Nobody holds the locks so it goes in and acquires the lock. It's now able to continue on, do its work inside the method body of deposit, gets the value, increments it, writes that value back. Once the value is updated and we're all done, we go ahead and release the lock. So the synchronized methods protects us from multi‑threaded access into the messages marked as synchronized inside of an object instance. Now, in the next clip, let's take a look at the scenario where we need to protect code that runs across multiple method calls.

Manual Synchronization
Let's look now at the idea of manually managing synchronization. Now in the last clip, we looked at synchronized methods. And what synchronized methods did for us was they automated concurrency management. And what they were actually doing was whenever we called a method against an instance, if that method was synchronized, that call into the method automatically acquired a lock against the current object instance. Well, it turns out that objects do not have to have synchronized methods to have a lock. All Java objects have locks. And because all Java objects have locks, we can actually manually acquire that lock anytime we need to. When we manually acquire a lock, we're using what are called synchronized statement blocks. And the value of synchronized statement blocks is that any code that has a reference to an object can use a synchronized statement block to acquire a lock against that object. Now let's compare the idea of synchronized methods to manually managing synchronization by using synchronized statement blocks. Let's first look at synchronized methods. So let's consider our BankAccount class, and remember that I had a field called balance along with a constructor and some other members. Let's focus in on the deposit method. Now our deposit method is marked as synchronized, and all we do inside of there is increment the balance by some amount, but because that method is marked as synchronized, its thread safe. So let's say we have a Worker class now, as we saw in the last clip, where it's actually meant to be run on a thread, so it's got a reference to the BankAccount. And our run method, what we want to do is loop through 10 times, calling the deposit method to add $10 inside the loops, so we have $10 10 times. Alright, we know that worked for us, and it was thread safe because that deposit method being synchronized, any time we call that deposit method to acquire a lock against a current object instance, against the account reference. So it means that we were actually locking our account member field each time. It was just happening automatically because of synchronized methods. Well, in synchronized statement blocks, we can get that same result even if a class is not built to be thread safe. So let's look at another version of our BankAccount class. It has the same field inside of it, the balance. We're going to have the same deposit method. The only difference is our deposit method is now not marked as synchronized, in other words, our deposit method is not thread safe in and of itself. We can't safely call into it on the same instance for multiple threads, but we can still make using that class thread safe. We just have to do it explicitly. So we can take our Worker class again. We'll have a reference again in a field to the BankAccount. We'll have a run method. We'll have our for loop that goes through 10 times, and we'll call deposit $10 each. But as this is written now, we know that that is not thread safe. We saw that actually go wrong earlier in this module, but we can make it thread safe. We can wrap it in a synchronized block, but now the synchronized block has to acquire a lock on an object. What we'll do is we'll use the account variable. So synchronize is locking the account variable. Well, that account variable is actually the account field that's a member of our Worker class. So it's the same exact result that we had earlier with synchronized method. We've just done it explicitly. So why bother with synchronized statement blocks if it did the same thing with synchronized statement block we did previously with synchronized method and synchronized method seemed easier? Why do we have these synchronized statement blocks? Well, what it comes down to is that synchronized statement blocks provide flexibility. One thing it allows us to do is use non‑thread safe classes in a thread‑safe way, as we saw just in that last slide, is that even though our updated BankAccount class there did not have synchronized methods, we could still safely use it multithreaded because the synchronized statement block locked access into that account instance. It also makes it easy for us to protect complex blocks of code. If all we have are synchronized methods, that means every time we needed synchronization, we'd always have to write a method to go do it. Synchronized statement blocks allow us to protect code right in the middle of another method, so it allows us to protect blocks of code without having to move them off into their own method. And what it comes down to is that even with synchronized methods, sometimes they just aren't enough. Sometimes we need something more sophisticated than that. In our next clip, let's take a look at some code that demonstrates where synchronized methods may not be quite enough.

Manually Synchronized Code
Let's look now at some code where we have a situation where synchronized methods may not provide quite the protection that we need. So let's go back to our BankAccount class. Again, we'll have a balance field. We'll have a constructor that sets the field. We'll go ahead and have our getBalance method, which is synchronized. We'll have a deposit method that's synchronized. Let's add one more method. Let's go and add a withdrawal method that is also synchronized, and just as the deposit method incremented the balance, the withdrawal method will decrement the balance. And so a very, very basic bank account. Now this is what we consider to be a thread‑safe bank account, right? Getbalance, deposit, and withdrawal are all marked as synchronized. So since we know that that is actually thread safe, we can go ahead and write some code that's multithreaded. So what we'll do here is let's create a TxWorker class. And what this TxWorker will do is will actually be responsible to perform exactly one transaction against a bank account. So it's going to have to have a field for the BankAccount itself. It will have a field that indicates what kind of transaction that is. Is it a withdrawal or is it a deposit? And then it has a field for the amount of that transaction. Have a constructor that sets all those values. And what we want to do then is be able to fire this off on threads, and each instance is responsible, again, to do exactly one transaction against an account. So we'll have our run method. If that txType is withdrawal, it will call the withdrawal method against the account instance, passing in the amount. If the txType is deposit, it will call the deposit method. Now we know this is safe, even if one account has both a withdrawal and a deposit and they were to be run at the exact same time on separate threads, it's still safe because both withdrawal and deposit are synchronized methods. So because that's true, what we can do is then write code that dispatched all that work onto a thread pool. So what we'll do is have an ExecutorService that references a ThreadPool with five threads in it. We'll have some code that goes out and gets a list of all the transactions as instances of this TxWorker class we just created, put that into a worker's array, and then what we can do is just loop through that workers array calling submit against our thread pool, just pushing all that work in there. And basically, five of those will be running at a time inside the pool, and we'll work our way through all of the transactions that have to be done, and we just kind of hang out waiting for that to finish. And so that code is solid. It's good. It works fine. And just to reinforce, it works fine because our TxWorker class, which is being run multithreaded, is calling either withdrawal or deposit, both, which are synchronized. But let's say this code's running great, life is good, and your boss comes up to you and says, you know what? I just came out of a meeting, and the bank wants to run a special. They want to do a promotion. And what they want to do is they want to encourage people to make more deposits. So what they're going to do is they're going to create a promotion so that if anybody makes a deposit into their account and that balance is over $500 after the deposit, the bank is going to give a 10% bonus for the amount over $500. So in other words, if someone makes a deposit that causes the account to now be worth $600, well, $600 is $100 dollars over $500. We're going to give a 10% bonus, so $10. So the bank will put $10 into the account, and they want to start that promotion tomorrow. So what do we do as developers? Well, we go, hey, I understand Java. I'm a good developer. I can make that happen for you, and so we'll write some code to make that happen. So what we'll do is we'll create a new class instance that can do the work to do this promotion. So we're going to create a class called TxPromoWorker that extends our TxWorker class, that existing TxWorker class we have. So because of inheritance, it has access to the fields that are in the TxWorker, so we just need to create a constructor that calls our super class constructor. And so now all we need to do is update our run method with this kind of new rule inside of it. Well, with the new rules, withdrawal still works the same if the txType is withdrawal, we're just going to call the withdrawal method. But if it's deposit, we now have to do some additional work. We have to make the actual deposit. And then remember, the promo says that we're going to do something special if there's more than $500 in the account after the deposit. So what we do is add some code that says we'll get the balance of the account, and if it's over $500, we're going to do that special work. Well, the special work is to pay a bonus, right? So what we're going to do is now, again, get the balance back. Find out how much of that is over $500. So subtract 500 from it, and then we multiply it by 0.1 to get 10% because that's the bonus amount that the bank will then deposit in on the account holder's behalf. Alright, so we're going ahead and basically paying that bonus. And so this is our new kind of worker class. We'll call it our TxPromoWorker class because it has that extra logic now for when deposits are being made. And we're thinking that, well, jeez, withdrawal, deposit, and getBalance are all synchronized methods, so this should be good. So all I need to do now is go to the code that actually submits work into our thread pool. And instead of getting an instance of TxWorker classes, what we'll do instead is get back instances of our TxPromoWorker class. Because it inherits from TxWorker, it can still be going into our TxWorker array and can then go into all that code we have in place already. And it seems like life should be good there, right? But let's take a look now at exactly what might happen in this scenario. So we've got the same process kind of diagram we've been using throughout this module. So we've got a couple of threads running. And say on one of the threads, it now picks up a TxPromoWorker instance that has a deposit of $150 that references some account, and that account currently has a balance of $450. Now, since it's a deposit, we call into that deposit method. The deposit method, because it's synchronized, checks to see if the account is currently locked. It's not, so it goes ahead and grabs that lock. Now that it has the lock, it will go ahead and do the deposit of 150. So we add 150 to 450. We now end up with $600. So the deposit method exits because it's synchronized. The lock is automatically released. Now the code to check to see if the balance is over 500 is our get call. So our getBalance call occurs. It's synchronized. It checks for the lock. There is no lock. It acquires the lock. It looks at the balance and says, is that balance greater than 500? It is, 600 is greater than 500, which means we want to again run our code to pay the bonus. So as get method finishes, it releases the lock. Now before the code for managing deposit runs any further, another thread picks up a withdrawal TxPromoWorker instance that points to that same account. The withdrawal method starts to run. It checks the lock on the account. The account does not have a lock, so this thread now grabs the lock, and it holds the lock. So now, as the thread managing the deposit goes to do the next getBalance call to figure out how much greater than 500 it is, it sees that the account is already locked by another thread. So what it has to do is it has to hang out and wait. So now the withdrawal processes a $300 withdrawal, takes our 600, subtracts 300 from it, leaving a new balance of 300. As it finishes, it releases that lock, which now allows the thread processing the deposit to run. So it wakes up. It checks for the lock to do the getBalance call. There's no lock there, grabs the lock. Once it grabs the lock, it gets the current balance, which is 300, and it subtracts 500 from 300. Well, if I subtract 500 from 300, I get negative 200. Then when I take 10% of that, I get negative $20. So now that getBalance call finishes. We release the lock. We now do the call into our deposit method to deposit that bonus amount. The deposit method acquires the lock. Once it has the lock, it takes the negative $20 and attempts to add it to the $300. Well, when I add a negative $20 to $300 dollars, what do I get? I get $280. So a promotion that was supposed to add money to people's accounts is actually taking money out of those people's accounts. And I guarantee you, your boss is going to get calls on that, which means you're going to get calls about that. So we need to write our code in a way to allow all those method calls to happen together. So let's see how we can fix up this TxPromoWorker class to now be properly thread safe. So let's look at just the run method in our TxPromoWorker class. So we'll have our run method. Again, when a transaction type is withdrawal, it's no big deal. We still do a withdrawal. We have a transaction type of deposit. Now what's the work we want to do? We want to do the initial deposit. We would check if the balance is greater than 500. If it is greater than 500, we're going to find out how much greater than 500 it is. Get 10% of that, which is then our bonus, and then deposit the bonus. But we want all four of these method calls, the first deposit, first getBalance call, the second getBalance call, and the second deposit to all happen in a safe single block of work. So what we can do is we can wrap that in the synchronized statement block and locking the account. So now we're grabbing the account lock before we start any of this work and then running all of those method calls in that one block. So let's see what that looks like in our diagram. So we have our diagram. We spin up our threads. One thread picks up the deposit of $150. That references our bank account, which still has the $450 balance as our starting balance. But now the first thing we do is open up our synchronized block. That synchronized block then goes out, checks the account instance to see if there's a lock on it. There's not, so it acquires that lock. So now the synchronized block is holding the lock. So now we try to do the initial deposit. That initial deposit checks the account lock. And you may go, well, it's already locked. But here's the cool thing about the way these locks work. Object instances are not just locked. They are locked, and that locked is associated with a particular thread. Because the deposit method is being called on the same thread that already holds the lock, it's allowed to proceed. So what happens now is that the initial deposit will occur, so that code will run. So our $150 is then applied to the 450 to give us the balance of 600. Our deposit method leaves. We're still in the synchronized block, so that synchronized block lock is still in effect. We do the initial get that checks the lock. It says the lock is held by this thread, so I'm still allowed to run. Get takes a look at balance, which is 600, 600 is greater than 500. The get method exits. So now we have the other thread pick up the work, which is the withdrawal work, which points to that same account instance. Well, as that attempts to acquire the lock, that lock is already held by another thread because that other thread is in that synchronized block. So now the withdrawal work has to wait. So now we go back to our deposit processing thread, the get checks the lock and says the lock is held by my thread, so I'm still allowed to run. So that get then checks the balance, takes the 600, subtracts 500 from 600, gives it $100, 10% of that is then $10. So we've got that amount. The get exits. Now the bonus deposit runs. Again, checks the lock, the lock's held by the current thread. So that code's allowed to run. So then it takes $10, applies it to the balance. So our balance goes from 600 to $610. The deposit method leaves. Then we exit the synchronized block, which releases the account lock. That allows the thread processing withdrawal to wake up. As we go into the withdrawal method, it checks the account locks. There's no lock held. It acquires the lock. Withdrawal then takes the $300 withdrawal, applies that to the balance. Our balance goes from 610 down to 310, and now we've properly processed both a deposit and withdrawal and properly paid the bonus on the deposit. So the synchronized block allows to protect multiple method calls where synchronized methods only protect the body of that method. Okay, on the next clip, we're going to take a look at some of the other options Java provides for synchronizing code across threads.

More Concurrency-related Types
To wrap up our discussion of threading and concurrency, let's take a look at some of the other types Java provides that helps us out with concurrency. First let's look at some of the collections and what the issues are there. Now one of the things we need to look at is how do we safely access collections when we're working on a concurrency, and then there's the issue of blocking collections. So let's first look at this idea of concurrency safe collection access. Java provides what are called synchronized collection wrappers, and the issue is that most collections are not thread safe. So what that means is if you do something to create a list or a map, and you start modifying that on multiple threads at the same time, at some point you will corrupt that list or map. So we need a way to work with that in a thread‑safe way. Now we could write all that code manually, but we don't have to do that. Java provides what are called thread‑safe wrappers for collections. So the Collection class has a series of static methods that allows us to create these thread‑safe wrappers, methods like synchronized list, or synchronized map, and so forth. And what'll happen is that we create the list or the map as we normally do, but when we pass it into these static methods, what we get back is a wrapper that is thread safe. So what that means is that all the actual collection work occurs in the original collection, but as long as you access the collection through the thread‑safe wrappers, the wrappers will make sure that all the necessary thread coordination occurs. So we don't have to worry about those kinds of details. And since we work with collections so often, it's really helpful to be able to use those thread‑safe wrappers when we need them. Now the other side of the issue is blocking collections, and these address something called the producer and consumer model. Alright, a producer and consumer model is this idea that you have one or more threads that are producing some kind of content that needs to be worked on, so maybe they're reading stuff from a file and putting them inside of an object, something like that, and then one or more other threads that consume that content, so in other words, they have to do the actual work. And as long as producers stay ahead of consumers, life is fine, but if a consumer comes back for work and there's no work there, then the consumer has to wait for that work to be available. Well to help us with that, Java provides blocking queues. What it allows us to do is have the producer put content into the queue as it normally does, the consumer can read content from the queue, as it normally does, but if the consumer comes back and there's no content there, the consumer will block until there's some content available. Then as soon as there's content available, the consumer wakes up and then can carry on. And there's a few of these available, there's a LinkedBlockingQueue, which just uses a link list as a queue. There's also a PriorityBlockingQueue, which allows us to put a priority algorithm in place so things come out of the queue based on some priority order, as opposed to the order they go in there. And there's still so much more. There's a couple of key packages that provide other types that we might want to use with concurrency. Now one of packages is java.util.concurrent, and that contains most of the general types for working in concurrent situations. And honestly, it has many of the types that we've talked about throughout this module, things like the callable interface, things like the runabout interface, things like the executives class. They are all part of that Java.util.concurrent package. But also it has types for more advanced scenarios, things like semaphores, right, semaphroes are a concurrency object allows us to have multiple threads access resources but on some limited level, like we can have up to three threads working at one time, but not more than three, that sort of stuff. And there is just so much more inside of there. So if you're doing a lot of concurrency work, that's a package you'll want to check out. Another important package is the java.util.concurrent.atomic package, and that contains types that provide atomic operations, right, things like atomic integer, alright, atomic Boolean, and with those, there are methods like set and get that are atomic, in other words, the set and get are safe, but also more advanced things like getAndAdd, so you can actually get the current value of an atomic integer, and then add some value to it, and that happens as one atomic operation, meaning that no other thread can get to it until it finishes, or there's a compareAndSet, which says that take a look at the current value, if it matches the value you pass in, then set it to another value, and that all runs atomically, guaranteeing that nothing else gets in between during those operations. So as you can see, Java provides everything we need to write effective, high performing, multi‑threaded concurrent applications.

Summary
To wrap up, here are some of the key things you want to remember from this module. We started out by looking at the Thread class, and that represented a thread of execution. Now it's very similar behavior to the way most operating systems represent threads. And when we use the Thread class, we're really responsible to handle most of the threading details ourselves. So it's a very, kind of a low‑level class. It's what a lot of the other things are built on. And then we had the Runnable interface, which represented a task to run on a thread. And it was very simple. It had one method, which is the run method. Any code we wanted to run on a thread would go inside of that method. But again, it's a fairly foundational implementation in the sense that it can't return results, and the thread is responsible for any exceptions that occur there. So when working with the Thread class in the Runnable face, we're going to have a lot of responsibilities to handle on our own. And then we started looking at some of the types that abstracted some of those details, starting with the ExecutorService, which handles a lot of the thread management details for us, and it works well with thread pools. So we can simply say I want this many threads, put them in a pool, and manage the details of assigning tasks into the threads in that pool. We have the Callable interface. Now it represents a task to be run on a thread just like the Runnable interface does. The key difference is the Callable interface allows us to return results and throw exceptions that can be retrieved back by the thread that called this other thread to do the work. The way the other thread gets the results back is using the Future interface. The Future interface represents the results of some thread task, and it can access any results returned back from that other task, as well as throw an exception containing the exception thrown by the thread task. And then we have the issue of thread synchronization. And as we saw, all Java objects have a lock. Now one way to get access to that lock is by using synchronized methods. When you use a synchronized method, you automatically acquire the lock by calling into a synchronized method, and that method acquires a lock on its current instance. And by using synchronized methods, only one synchronized method on a given object instance can be active at one point in a time. So it actually kind of automates that idea of calling into the method, acquiring the lock, doing the work, and then releasing it. Well we saw we could also manually acquire the lock, and we could do that using synchronized statement blocks, which allowed us to protect a block of code using the lock on an object. And that's available to any code that actually has a reference to the object. And as we saw, there are scenarios where managing synchronization with synchronized methods wasn't easily achievable. So the synchronized statement blocks allow us to take more control over that. Okay, so now in our next module, we'll start looking at runtime type information and reflection.

Runtime Type Information and Reflection
Introduction
Welcome to the next module of the Pluralsight course, Java Fundamentals: The Core Platform. In this module, we talk about working with Runtime Type Information and Reflection. My name is Jim Wilson So throughout this module, we'll talk about the importance of type information and the role reflection plays in giving us access to and using that type information. We'll start out with a discussion of just, in general, what is reflection, what is the role it plays, and why is it important as developers? We'll take a look at how Java actually represents information regarding types. We'll then see how we can get access to the information on any given type reference and the importance a class named Class plays in that process. We'll then see how we can get more detailed information about a type, things like its base class, what interfaces it implements, is it a public class, is it a final class? We'll then see how I get information on the members of a type, what fields does a type have, what methods doesn't have, what are the parameters on those methods? We'll then see how we can actually interact with types used in reflections so that it allows us to actually make method calls on a given object instance, even though we may not have a reference of the appropriate type to access that object. We'll then look at using reflection to create object instances, and as part of that, we'll talk about dynamic type loading. This allows us to have our programs create instances of types that we may not even have known about at the time we wrote our programs. Okay, so let's get started.

Overview
Reflection provides us with really two core capabilities. One is that it gives us the ability to examine types at runtime. That way when our program is running we can actually look at an object and determine information regarding the type of that object. It also gives us the ability to dynamically execute and access members of types. Now, these may sound kind of strange, but something that's really important understand is that as applications get more sophisticated, applications do not always control the types they use. As we build our application, we generally think of being, kind of working in the source code and using our own classes and that sort of thing. But as programs get more complex, that doesn't always remain true, particularly when we're dealing with kind of advanced application designs, or if you're building tools for use by developers or frameworks for use by developers, that tends to be less true. Well, if we don't control the types that we use, what we ought to have to do is then dynamically load those types. And what we mean by dynamically loaded types is that we're actually using types that we did not know about when our program was compiled. All right, so we compile our program at some point time, we're interacting with other types that we don't necessarily know much about that are created at a very different point in time. What this means is that there's no type specific source code available. If I don't know what the types are the my program is going to interact with, I certainly can't write source code that knows about those types. So now, in order to write programs like this, what we need is those capabilities that are provided by reflection, the ability to examine types at runtime and dynamically execute and access the members of those types. Looking at this idea of runtime examination, using reflection, we can fully examine objects at runtime. What that means is that the program can have an object reference, and that reference may be just of type object. Although the class itself could be some other, much more involved type, we'll use a reflection. We can determine the real type of that object, as well as any base types, in other words, what other types it's extending. We can determine what interfaces it implements, and we can determine what its members are, what the method names are, what the fields are, those sort of things. Now having this ability has a variety of uses in our applications. One key one is just the ability to determine a type's capabilities. Otherwise we may write an application that knows how to do a lot of different things. Then when we load in an object, that object may only know how to do a subset of those things. So our application may need to determine which of those capabilities this object knows how to work with. And if you're doing any kind of tools development, there's a number of places this comes in. One is the idea of, building idea of like type inspectors or type browsers. In other words, the ability to have an object reference and just kind of list out what it can do. Many of the modern Java IDEs have that ability where you can click on a class and say, show me it's declaration, and even without the source code, it can show you the entire class and its members. Well it does that with reflection. Or the idea of schema generation, where you may need to create something that's compatible with the Java type. An example of this is a system I worked on as far back as the late 1990's, where we were writing all these applications in Java, but we had to interact with an old storage system that knew nothing about Java. So we had to write code that could, at runtime, create a storage area in the legacy system and take the data from the Java objects and move it into them. So that just give us ability to do these very rich features in our applications. Now the other side of reflection is dynamic execution and access. User reflection, we can access the full capabilities of a type, meaning that we can construct instances of a type that we didn't even know about when wrote our program. We can access fields in that type. We can call methods on that type. Now using that we can do a lot of cool things. There's a couple of kind of standard application patterns we use. One is this idea of configurable application designs, where the specific task that application performs are externally controlled. I built a system where we had to generate messages for transmission between brokerage houses, and we were using a standardized message format that had literally hundreds of different field types. And when we built the application, we only needed to use about 20 of those field types., but we knew we were going to need more over time. So what we did is we built a core application that knew how to construct the overall message and transmit it. But it had no idea how to actually get the data for a particular field or format that field. We then wrote classes that knew how to handle each individual field. And then we could just take a file, feed it into our application, it would load those classes up and build the messages. As we needed new field types supported, all we had to do was write the class for just that one new field, update our control file, and the application now had more capabilities, it could now handle more field types. And kind of a specialization of this idea is something called inversion of control application designs. Version control is this idea where an application provides some fundamental behavior and then classes are added to specialize that behavior. Kind of the generic example for this is the idea that you write an application that knows how to present a user interface to a user. But it doesn't know what the menu should be. It doesn't know what the task should be. Well, you can then write classes that conform to this in version of control design, and that will then provide the menu options that perform the individual tasks. So as we can see, reflection opens us up to a whole new world of application features and capabilities. So in the next clip, let's started digging into that by seeing exactly how Java represents types at runtime.

Type as a Type
Data types are the foundation of any application solution. Whenever we build our programs, we model the things that we have to work with with data types. So if I'm building business solutions, I create types that correspond to that business solution. So if I'm building say a human resources application, I might have a class that represents a person, a class that represents a job. When we're building technical solutions, we use types to model our technical issues. We know that there's a thread class in Java that models a thread of execution. We know there's a runable interface that models the behavior of a class that can be run on a thread. Well if types are the way we model solutions to our issues, Java uses types to model solutions to working with data types. So there's a class called the Class class. And every type inside of our application has a corresponding instance of the Class class. That instance describes that data type in detail. So, in other words, for every type that we have in an application, there is an instance of the Class class that describes that type. Now this may sound a little confusing. So why don't we take a look at some code and kind of see exactly what's happening here? So let's go ahead and create a BankAccount class. Let's go ahead and create a couple fields. We'll have a string field for the account id. We'll have an integer field for the account current balance. We'll have a constructor that accepts just an id, another constructor that accepts an id and a starting balance, and we have some methods, one that acts as the id, one that acts as the balance, one to make a deposit, and one to make a withdrawal. So that's our class description. So now we know that with that class description in place, we can write code that goes ahead and creates an instance of that class, and we can have references that correspond to that class type. The question is is that how do we get from this text‑based description of a class that we've written to actually being able to lay out that class in memory? And that's where the idea of our Class class comes in. So we've got this class we've created, BankAccount. Java needs to model that type BankAccount. Well there is an instance of the Class class that corresponds to the data type BankAccount. And the Class class instance has members that tell us about the BankAccount type. So it has a member that gives us the name of the class. So our BankAccount class's name is BankAccount. The Class class instance has a member that describes all the fields inside of our BankAccount class. So it has a field entry for the id field. It has a field entry for the balance field. It also has one for the constructors. So since we have two constructors, there's two entries in there, one for the constructor that takes just an id and one for the constructor that accepts an id and a balance. And then the same thing for the methods. So we have one for our getId, one for getBalance, one for deposit, and then one for withdrawal. And what that gives us now is an instance of the Class class that provides a detailed description of our BankAccount class, and our Class class is accessible at runtime. With that, we have a model now for actually working with our BankAccount class. So now if we write code that says go ahead and create an instance of our BankAccount class, the Class class instance that describes BankAccount in effect acts as a mold for the memory allowed of that class. So we now have an instance of the BankAccount class in memory with the id field inside of it and the balance inside of it. As the constructor body runs, we go ahead and set the values inside those fields, and we get back that reference, which is assigned into our variable, acct1. But the relationship between the Class class instance describing our type and the type instance itself is not just for creation time. Our BankAccount class instance actually has a member that we can use to reference the Class class instance that describes it. Now let's say we go off and we create another instance of BankAccount. Well, again, our class description goes ahead and acts as a model or a mold for that. So it goes and lays it out. Constructor body runs, goes out and sets the fields, and we get that reference back. And, of course, this other BankAccount instance is going to be able to get back to the class description of it. And it points back to the exact same instance of the Class class that the acct1 bank account instance pointed to. And what this shows us is that no matter how many instances of a particular type we create, they always reference the same exact instance of the Class class that describes it. So now what this tells us is that we can have a reference to any object, even if we don't know what type that object actually is. Because we can get to the Class class instance that describes it, we can find out things about that object's instance. And so in our next clip, let's see how we can get access to that Class class instance reference.

Accessing a Type's Class Instance
We've established that the ability to get information on a type like this is really powerful. The question is, how do we actually get that information? And the way we get the information on the type varies depending on what we have. Now, if we have a reference that points to an instance of a given type, we can get the class descriptor for it by simply calling getClass against the reference. In many cases, we may not actually have a reference to an instance. In some cases, we might just have a string representing the type name, like, say we've read it in from a file or it's been passed in from a command line. Well, if we have the string representing the type name, we can go to the Class class and use its forName static method. As long as we pass in the string as a fully qualified type name, meaning that includes the package name and so forth, we can get back the type information for that type. We can also do it using a type literal. In other words, actually type in the type's name in our source code and then use its class field from there, and that'll give us back that information as well. So let's start out here with a simple method here called showName, and showName accepts a reference to a class describing some type. And all we'll do inside of here is print out the simple name of that type. Now, one thing to notice, the parameter that accepts the Class reference, notice that we've got angle brackets after the word Class. That tells us that the class called Class is actually a generic type, meaning that it can actually have a parameter to specialize the type it operates against. Normally that parameter type when you're talking about the Class class is the type that it represents. So, for example, if we're representing the BankAccount class, it would be class specialized on BankAccount. The thing is that in many cases when we're working with reflection, we don't know the specifics of the type. We don't know what the type is going to be. So in those cases where we don't know what the type is going to be, we simply put a question mark between the angle brackets like we have here. Let's say we have another method now called doWork that accepts a simple object reference, and what we want to do is be able to pass in the information into our showName method to print out the name of the type that corresponds to that reference. So what we can do is we can simply call getClass against the object reference, that gives us the information describing the type, and so we can then just pass that into our showName method. Now we can receive in a reference to any type into our doWork method because the type is object. So let's write some code here that creates an instance of our BankAccount class and passes that reference into our doWork method. Well, we run this code, the account reference is passed into doWork, we then call getClass to get a description of the BankAccount class, that goes into our showName method, which then prints out the name BankAccount. So let's look at the other two scenarios. Let's start out again with that same showName method we had in the previous slide. And what we want to look at first is the idea of having a string representing a type. So what we can do here is simply give the type name as a string. Again, the type name has to be fully qualified, so we're including the package name, com.jwhh.finance in front of .BankAccount, and then we take Class.forName, gives us back the type description for that type. We pass that reference into showName, that'll print out BankAccount. Look at the idea of a type literal. Well, in our source code we can go to the type name BankAccount, just say .class, that gives us back the type descriptor, and then pass that into showName, and that prints out BankAccount as well. Now, notice here in our class.forName and our BankAccount.class, we're putting the question mark inside the angle brackets next to Class. And we said that when we use that question mark, we don't really know what type Class is being used to describe. But if we look at the case of BankAccount.class, well, since we're actually writing BankAccount there, we know the type being described is BankAccount. So we could rewrite that code to actually have BankAccount in the angle brackets. Now, we would still get the same result when we run it, but we're now being more clear in our code what type is being represented. One thing that's really important to understand, the way we access the type information does not change what type information is returned. So if we look at our code where we created an instance of our BankAccount class and then we used getClass to get the type description. Well, then that returned a reference to an instance of our Class class. Well, if instead we look at the case where we actually use the string representation of the type name and call Class.forName, well, that gave us back a type descriptor, and it gave us back the same exact type descriptor that getClass did. Now it's not a similar one, it actually points to the same exact instance of the Class class. Same is true from when we're looking at using type literals. It doesn't matter whether we use Class with a question mark or Class with the type name, both of those point to that exact same Class instance. So it makes it very predictable and very consistent for us to be able to get information on types using whatever we have access to because we get not just similar information, but the exact same information back whenever we're talking about the same type. In the next clip, we're going to take a look at how we can actually start to work with that information.

Accessing Type Information
Now that we know how to get access to a class object describing a type, we've got a lot of control now, because once we have that, every aspect of that type is now nullable, where we can know whether that type has a super class and if so, what it is. Does that type implement some interfaces? What are the modifiers on that type? Things like public, things like final? We could even know the members inside of that type. So let's take a look now at a class that we might define here and then see what it's like when we actually evaluate that information about that class. So I have class here, we'll call it HighVolumeAccount. We'll go ahead and have it extend our BankAccount class. Now our HighVolumeAccount will have two constructors, the ones that correspond to our BankAccount class. It'll have a couple of methods of its own. I have one called readDailyDeposits and readDailyWithdrawals. So the idea here now is this HighVolumeAccount is a bank account, but one that's determined to have a lot of transactions going each day. So it's got methods that enable us to get all the deposits and all the withdrawals back easily. And what we want to do is make it so that high‑volume accounts can be launched off on a thread on their own. So we'll go ahead and put the runnable interface on here, implement the run method, then inside of run method, we'll get all the deposits and make those, we'll get all the withdrawals, and then make those. So now let's see what it's like to actually use reflection to evaluate this class. So let's go ahead and write method here. We'll call it classInfo; it accepts an object reference as a parameter. We're going to pass in a reference to an object. We'll assume that it points to an instance of HighVolumeAccount. So in order to get the type information, we'll call, getClass, and we'll sign it into our local variable here called the Class. And of course, that will point to the type information for high‑volume accounts. So now once we have that though, we can start to interrogate this type. So we'll say we want to know if it extends another class. So we'll call getSuperclass, and it will tell us what class it extends. Now we know this extends BankAccount class, and notice what we get back is actually a reference of type class, which means now we're getting all the class information for the class that we extend. So now we've got all the type information for our base class, right? BankAccount. Alright, so now that we have that, if we wanted to, we could find out what the base class of BankAccount is. We could keep walking all the way up the hierarchy until we get to the very top. Right? Now we know that the only class that does not have a super class is the object class, right? So we keep walking up calling getSuperclass, when we finally get a null back, we know we're at the very top of the inheritance hierarchy. So now, in addition to knowing the classes we extend, we said we can also know what interfaces it implements. Remember that a class can implement as many interfaces as it needs to. So the getInterfaces comes back as an array, but notice that it comes back an array of type class. So what that tells us is that all the information that we can get about classes, we can also get that same information about interfaces. So that if we want to loop through all those interfaces, we can look at them one by one. Now in our case, we know that our class only implements an individual interface. So we get any information on that, our runnable interface, and so we have that there. So what if you needed to handle information on interface types differently than information on class types? Well, there's a method on the Class class called IsInterface that returns true in the case of that type being an interface. Now, as we mentioned, we can also get information on the modifiers applied to a type. Now the way we do that is simply call a method called getModifiers, and what that will return back to us is a single integer value. Now that may seem strange, because we know a class can have more than one modifier on it, right? It can be both public and final, right? That sort of thing? Well, what it is is that each modifier is represented by a separate bit inside of that integer. So what we need to do is have a way to interrogate the contents of that integer that's returned to determine what modifiers are present. Well, there's a class called Modifier that gives us the tools we need to do that. Now the modifier class has a series of static fields that will allow us to do direct bit comparisons. So we can actually do bitwise and/ors to do checks to see if, hey, is the bit representing public turned on? Is the bit representing final turned on? And that's great for cases where you want to do kind of very complex or very intensive processing of the modifiers, but in most cases, we just want to know, hey, is this particular modifier present or not? So the modifier class also provides static helper methods where we can simply pass in that integer value and it'll return back a true or false, telling us whether that modifier is in there. So looking again at our HighVolumeAccount class, we notice that this class has two modifiers on it, right? Both public and final. So now let's write some code to take a look at those modifiers. So we'll create a method here called type modifiers; it accepts an object reference in. Before we can do anything we need to call getClass to get the class information, and now if we want the modifiers, we take the class and we call getModifiers against it. And that returns back that integer containing bits set for all the modifiers that are present. So if we want to work with it directly at the bit level, we can take that integer value, go to the Modifier class and use the static fields in there. So in this case, we're actually doing a bitwise comparison. It's simply and‑ing together these values to say that, hey, if that final bit is turned on, I will get a non‑zero value. So in our case, our type does have final as a modifier so that it would be turned on. But as I mentioned, most of time, we don't need to work at this bit level. We generally just want to know, hey, is it final or not? So the Modifier class also has a method like isFinal where we pass in that integer that was returned from getModifiers, this final return back true or false, and so we could just use it that way. And in my experience, that's the much more common scenario. Alright, so let's say if we want to go through and take a look and see what the visibility of this type is, because remember that when we're dealing with reflection, we don't necessarily know what kind of types are coming in. They might be nested classes, they might be top‑level classes, any of the situations. So we might want to check and see is, hey, is this class marked as private? So we'll just say Modifier.isPrivate, passing in modifiers, that we weren't private. Well, is it protected? Well, nope. Well, is it public? Yes, it is public. So we can go ahead and print that information out. So we see that we can very easily now get information about the class hierarchy, the interfaces, and the modifiers on that type. In the next clip, let's take a look at how we can actually interrogate the members of that type.

Accessing Type Member Information
To allow us to interact with the members of a type, Java provides specific classes for each kind of member. So there's a Field class, a Method class, and a Constructor class. And each of these provides information about their specific kind of member. Now, of course, each of them will provide the name of the member, but then like the field will give us back the field type or a method will tell us the return type of the method, as well as the type of all of its parameters. Now a constructor doesn't have a return type, but it does accept parameter types. As we access the members of a type, we have two general ways of going about getting to the information. We can get access to the members that are declared directly by the type, or we can get access to the members that are declared and inherited by the type. Now if we access the members that are declared directly by the type, we can get the public, protected, and private members. So we have methods like getDeclaredFields or getDeclaredMethods or getDeclaredConstructors. Now if we want to access the members that are both declared and inherited, we will only receive back the public members, and we use the methods like getFields, getMethods, getConstructors. Now if you've seen my course, Java Fundamentals: The Java Language, you may remember one really important thing here. Constructors are never inherited. So what that means is that the method getConstructors can't really show you any inherited constructors. There aren't any. So what it really means is that getConstructors simply shows you the public constructors of the current type. So what it comes down to then is that the only difference between getConstructors and getDeclaredConstructors is that getConstructors is the public constructors, getDeclaredConstructors is all constructors, public, protected, and private. So let's take a look at some code. Let's start by looking at working with some fields. So we have our BankAccount class that we've been working with, and we'll look just at the fields. So there are two fields in there, id and balance. We'll write a method that goes and displays fields from a class, so it accepts an object reference. So as we always do, the first thing we'll do is call getClass to get the class information. So we can call getFields or we can call getDeclaredFields. Now each of these returns an array of Field. So let's create a little method here that accepts a Field array, iterates over it, and prints out the name and type of each field. So if we take the array returned from getFields, that'll be all of the fields that are both declared in the current type, as well as inherited, as long as they're public, well, our BankAccount class doesn't have any public fields, so that's not going to print anything out of all. But now if we take the array returned by getDeclaredFields, that'll only be the fields declared directly by the type, which in our case is BankAccount. But it will include private and protected. So it'll print out both our fields. The id is type string, and the balance is type int. Now let's look at another example that includes inheritance. So we'll take our BankAccount class again. But we'll look this time at the methods. So we've got four methods, getId, getBalance, deposit, and withdrawal. Then we have our class HighVolumeAccount that extends BankAccount that has three of its own methods, readDailyDeposits, readWithdrawals, both of which are private, and then run, which is public. So let's write a method now that writes out the method information. So, again, it accepts an object reference. We'll call getClass to get the class information on an object. We can call getMethods. We can call getDeclaredMethods. This time let's look at getDeclaredMethods first. So we'll say we iterate over the array of Method that's returned from getDeclaredMethods. Now, remember, that's going to be all of the methods declared in the type, including public, private, and protected. So we would see run, which is public, as well as readDailyWithdrawals and readDailyDeposits, both of which were private. Now, in the case of the array returned from getMethods, that's going to be all the methods that are declared in the type and inherited, but only those that are public. So we would see run from the declaring type, which is public. ReadDailyDeposits and readDailyWithdrawals would not be there because they're private. But then we'll go to the public members of BankAccount. So we'll see withdrawal, deposit, getBalance, getId. But it doesn't stop there. We know the BankAccount class did not specifically extend any class. But we know that any class in Java that doesn't explicitly extend a class automatically extends object, which means that the public methods on an object are also going to start showing up. So things like equals, toString, getClass, that sort of thing. There's going to be a whole bunch more beyond that because there's actually quite a few public methods on the object type. Now this illustrates an interesting point and a very common point. There are often times where you may want to walk a type hierarchy but exclude members of a particular class or stop when you reach a particular class. And we can do that easily. Let's write an updated method to walk the methods. So we'll go ahead and call getClass to get to class information for the object reference. We'll call getMethods, which will show all of our inherited methods, those that are public. And we'll iterate over them, and we'll say we want to go ahead and just print out the name. But, remember, we want to exclude those that come from the object type. So what we can actually do is do an if test and ask the method, What is your declaring class? In other words, what class were you declared in? And that'll give us back a reference to the class instance representing the type that we're declared in. Well, we can then compare that to Object.class, which will then give us back a reference to the class instance that describes Object. And, remember, there's exactly one instance of the class describing each type, so we can do a direct equals or not equals comparison because that's a reference equals, and that's safe because there's exactly one instance of the class describing any given type. So now what happens as we walk through this, we'll get the public members of HighVolumeAccount. We'll get the public members of BankAccount. Then when we get to those members that are part of object, they won't show up because they're being excluded by our if statement. Now when we're working with the members of a type, we don't always want to iterate over them. Sometimes, we want to access a specific member, and we can do that using that member's signature. So in the case of a field, we can call getField and simply pass in the name of the field we want, and we'll get the information for that field. Well, in the case of a method, remember that in Java, you can have multiple methods with the same name, but the parameter types have to differ. So when we call getMethod to get a specific method, we have to pass in the method's name along with its parameter types. Constructors are similar. We don't have to worry about the name, but you can have multiple constructors with different parameters, so we can actually pass in the parameter types for the constructors and get that constructor information back. We'll see some examples of using these kinds of calls shortly, just a little bit later in this module. Now one thing we don't want to forget is that members also have modifiers. Members can be public, private, protected. They can be static. They can be synchronized. Well, working with modifiers on members is just like working with them on classes; we simply call getModifiers against the member, and then we use the Modifier class to interpret the modifiers that are returned. Now that we know how to use reflection to get all this information about a type and its members, in the next clip, we're going to take that to the next level. We're going to see how we can actually make method calls interact with fields using reflection.

Interacting with Object Instances
Let's look now at doing even more with reflection. Now up until now we've looked at reflection as really a way to describe types and describe their members. That's a really important part of reflection, but reflection is not limited to just that. Reflection can also be used to perform actions. Using reflection, we can actually access and invoke members on a type. Now let's think about the way we normally program. So we might go off and declare a variable, we'll call it something like acct1 whose type is BankAccount. Then we'll new up an instance of BankAccount and then take that instance and assign it into our acct1 reference. Now once we've done that, that gives us the ability to do things like call getId against that reference, or we call a method on the BankAccount class. Well, why does that work? Well, because we have an object as a valid bank account, therefore it can have getId called on it, and we have a reference, acct1 whose type is BankAccount, so it has the information necessary to call that method. And basically what that really means is that the compiler generated the code necessary to be able to call into that method. But now let's make a small change. Let's keep that exact same instance of BankAccount around, but let's instead have a variable called obj of type object referencing it. Now the BankAccount instance hasn't changed at all, only the reference has changed. But given that, if I try to call obj.getId, that won't work. Now it's important to realize that the object instance didn't change at all, alright, that object instance is still a valid instance of BankAccount and still has the ability to have getId called against it. The problem is that the reference lacks the necessary information on its own to make the method call. But here's something important to consider is that we know that given an object reference at any point we can call getClass and get the Class description of that type, including all of its members. And the description of the members isn't just informational, it's actually useful. So we could take the information for, say, the getId method, take that information and apply it against our object reference, and then since the object being pointed to actually has the getId method call in there, we can actually make the method call, so we're actually using the class information to apply it to the object reference to make the method call against the object. Let's see a really simple case in code of using reflection to make a method call. So what we'll do is go ahead and carry out a method here called callGetId that simply accepts an object reference. And then we'll go ahead and new up an instance of our BankAccount class, and we're going to go ahead and assign it into a reference whose type is BankAccount. I'm going to pass that reference into our method called callGetId. Now, again, we always start by calling getClass to go ahead and get the Class information on the type, and we know that we can actually get information on a method. Now we know we can iterate over all the methods, but as we were finishing up the last clip we mentioned that we could also get references to a particular member by using its signature. So in this case we want a method, and we want the method called getId, so we're going to pass in the name getId. Now the getId method accepts no parameters, and so what we'll do now is we'll get back a reference to a method instance that knows all about a method called getId on the type BankAccount. So what we can now do is take that method information that we just got back, call in the invoke method against the method description, pass in the object reference, and what that will then do is use reflection to now get into that object instance, call its getId method, and then pass back the results of that method. Now, as we're doing all this work in terms of getting the method information and making the invocation, there's a number of exceptions that might occur, so we're going to go ahead and handle those, if we can't find a method, or if there's an issue calling the method. But now once we've got that result back, we can just write that result out as we normally would. So in this case, we would get back a result of 1234, the ID of the BankAccount we just created. Let's look now at another example. Let's create a method called callDeposit that accepts an object reference and an int amount. We'll then new up an instance of our BankAccount class, this time giving it an initial balance of $500. We'll then call this method, callDeposit, passing in a reference for our BankAccount, and then $50. And so now inside of our callDeposit method, we're going to use reflection to go ahead and execute the method Deposit against the BankAccount. So what we'll do, of course, is take our object reference, first thing is to call getClass to get the class information. We know we want to call getMethod to get the method description. Remember that we've got to provide the method signature. Now the signature includes the name, which in this case is deposit, but it also includes the types of its parameters. Now Deposit has a single parameter of type int, so we'll just say int.class, which gives us the type description event. If we had two, three or four parameters here, we would simply comma separate those because the parameter at the end of getMethod is just a variable‑length parameter list of type Class, so it's just a type of each of the parameters. So when getMethod returns, m contains a description of a method called deposit that accepts a single argument of type int on the class BankAccount. So now we can take m and call invoke, passing in our object reference, as well as the parameter values we want to pass into the method call. Now in the case of deposit against one parameter, which is an int, so that passes in the amount. If we had more parameters to pass in, we would just comma separate them, because invoke has a variable in the parameter list of type object, so we can just pass all the parameter values in there. So now we'll go ahead and wrap this in a try catch block so if any exceptions occur we can handle those. But now the key is that once we call invoke passing an amount, we've actually called deposit, passing in $50. And we're calling it against the BankAccount instance referenced by our variable obj, which is the exact same BankAccount instance referenced by our variable acct1, which means that if we then print out the current balance for acct1, we will actually have $550 in there. It doesn't matter if we're using reflection or traditional method calls, they both point into the same object. Now as you can see, reflection gives us some really great runtime capabilities to access the members of a type. One thing to keep in mind is that reflection is slower than traditional compile time access, right? Obviously, with compile time access there's a lot of optimizations that can occur, so reflection opens us up to a lot of great capabilities. The important thing is just use it in scenarios where you need reflection. Anytime you can write just kind of traditional code to get to the members you should do that, but then take advantage of reflection when it gives you capabilities you wouldn't otherwise be able to have in traditional coding. Okay, now in the next clip we're going to see how we can use reflection to actually create new instances of objects.

Instance Creation with Reflection
Throughout this module, we've seen the many different things we can do using reflection. We know how to get information about a type using reflection. We know how to, given an instance of an object, use reflection to call methods and interact with that object. Now let's talk about how we can use reflection to create new instances of objects. Now we know that reflection allows us to get information about the constructors of a type so we can actually take those constructors and execute them. So using the Constructor class, we can call its newInstance method. What I'll do is create a brand new instance of the object and return back a reference to us. Now we know that classes can have constructors with varying numbers of arguments, but far and away the most common kind of constructor to interact with is one that takes no arguments. So because of that, that case is simplified for us. If we want to create a new instance of a type using the no‑arg constructor, we don't need to actually get information on that constructor. Instead, we can simply call the newInstance method against the class that describes that type. Now at first thought, it may seem that the idea of using reflection to create brand new instances of types, it's kind of something you wouldn't use very often. But I would say in my career when doing kind of traditional application building, this is actually the aspect of reflection I use most often. The other things we've talked about I've definitely used at various points when I'm building tools or kind of really complex systems. But there's a number of times where the ability to create new instances of type using reflections has allowed me to build really kind of powerful systems that are easy to manage and maintain. The easiest way to understand it I think is with an example. So what we'll do is just walk to this idea of building what I'll call a flexible work dispatch system. And the ideas is, I want to build a system that has the ability to execute some worker against some target. And what I want to do is, I want to build this in a way that I don't want to have to know what all the worker classes I'm going to interact with are. Instead what I want to do is build this in a way that worker classes can simply be put into the class path of my application. I can be passed the type name of that worker class, and I can make everything else work from there. Now the key to making this all come together is going to be the method that actually starts the work. So what we're going to do is have a method that accepts two arguments. One of those arguments is the name of the type of a worker class, and that's simply just going to be a string name. And then we'll also get the target of that work, and that'll also be a reference to an object. So in other words will get the name of a type that knows how to work on some object. Now, when you build a system like this, you don't want to be in the Wild West. In a sense, you want actually constrain things a bit so things are somewhat predictable. So what we're going to do is put two basic requirements on our worker. Our worker is going to have to have a constructor that accepts the target type. And also it has have a method on it called doWork that accepts no arguments. So what that does is, it gives us the ability to create an instance of the worker, passing it in the target, and then gives us the ability to tell it to start doing its work. So for this example, for the targets of our work, let's use the classes we've been using throughout this module. We'll have our BankAccount class. As you recall, it has several methods on it that allows us to get the ID, the balance, and to make deposits and withdrawals. We also have our HighVolumeAccount class that extends the BankAccount class but also implements Runnable. So it adds a few methods for getting all the deposits and all the withdrawals for the day, then of course the run method for the runnable interface. So what we want to do now is actually build a worker that can actually operate on these targets. As we build our worker class, we could create separate workers for each of these types. Or in this case, why don't we just go ahead and create a single worker, operate on both the types. So what we'll do is, we'll go ahead and create a class here called AccountWorker, have it implement the Runnable interface. What that tells us is that our account worker can do its work out on a separate thread. Now I have a reference for BankAccount, and we'll also have a separate reference inside of it for our high volume accounts. Now, remember we said we have to have a constructor that supports the types that we're going to operate on. So we'll have one constructor for BankAccount, another constructor for HighVolumeAccount, and all these do is simply accept the reference and assign it into the appropriate field reference. So now we'll have our doWork method. That's the thing that actually starts up our work. So, as we said, this guy's going to do his work out on another thread, so we'll go ahead and create a thread instance. But one thing we want to remember is that our HighVolumeAccount already knows how to do its work out on another thread. So what we'll do is, we'll check and see if we got a reference to a high volume account. If we did, we'll simply pass that into our thread constructor. But if we actually just got a regular BankAccount, then the account worker's going to have to do the thread work. So it'll simply pass a reference to itself in there. And in the case of the AccountWorker, the run method will be really simple. It'll go out there and just get whatever the transaction is, it'll get whatever the amount of that transaction is, and then it'll either do the withdraw or the deposit. And then from there, it'll go ahead and just start the work. So now we know what our targets are. We now have a worker class. The next thing to look at is, how do we use reflection to bring all this together? So as I mentioned, the key to making all this work is the method that starts the work. So we'll create a method here called startWork that accepts the two parameters, the name of the type of the worker, and then a reference to the target of that work. So a call to startWork might be something like this where we have an instance of our BankAccount class, we call startWork, we pass in a string identifying the type of the worker. So we're going to assume that our accountWorker class is in the package com.jwhh.utils, so we're giving that fully qualified type name, and then the reference to the target, which is our bank account. Okay, so now, given that information, we can get the information for our worker class by simply calling Class.forName. Allows us to pass in the string name of a type. It will give us back that class description. We can also get the type information on our target by simply calling getClass, so now we have both of those pieces of type information. So given that, we can go to our worker type, call getConstructor, and say, give me back the constructor that accepts that target type. So in this case it would be the constructor that accepts the target type of the BankAccount. So now we've got that constructor. We can take the constructor, call newInstance on it, pass in the constructor argument, which is our target. That gives us back now a brand new instance of our account worker, and that's inside that worker variable. So now we need to go ahead and call the method that does the work. We'll take the type information for the worker, call getMethod, pass in the method name of doWork, get back that method description, and then from there we can simply invoke the method, passing in the reference to our worker. And that's it. That's all of it. Now, want to go ahead and put a try‑catch around this because there's a number of exceptions going to occur as we're doing all the reflections, so forth. But that is all of the work. And we simply get the type information for our worker, we go ahead and construct an instance of that worker, get the information on the method, and then call the method. And this will now work for any worker that conforms to those requirements of having the appropriate constructor and the doWork method. And so we can go ahead and extend this system now by simply adding new classes in and getting the names of those types we want to operate on. So this was a really cool thing we were able to do here. In the next clip, let's find an even simpler way to achieve these kind of results.

Instance Creation with Reflection Revisited
So let's create a new version of that flexible work dispatch system we built in the last clip. Now our core requirements remain the same. Still the idea of a worker operating on a target and the system still needs to be just as extensible as it was before. Alright, so just as easy to add new workers. The method that starts our work is still going to have the same arguments it had before, a string type name and a reference to the target object. The thing that we want to change is the requirements on the worker. By making some simple changes to the requirements on the worker, it will actually be a lot easier for us to implement our solution. So the requirements of our worker are one is that rather than having a constructor that has a particular argument type, we're going to require that the worker have then a no‑argument constructor. We're also going to require that the worker implement an interface called TaskWorker. Now, TaskWorker is not a built‑in interface, it's an interface we're going to define ourselves. It's a very simple interface, it has two methods. It has one called setTarget that accepts a reference to the object that's a target of the work, and it has a method called doWork that says go ahead and start doing the work. So let's take a look at a worker that implements the interface. So it's still going to be our AccountWorker class, still implements Runnable, but it's also going to implement our TaskWorker interface. Now, we're going to have a reference for the BankAccount as a target. And that's the only reference we're going to have. Remember that a HighVolumeAccount inherits from BankAccount anyway. So what we'll do now is put our setTarget method on here, right? The one from TaskWorker. Now, the target it comes in here is of type object, right? So it's not type save. It could be a reference to anything. Now, one thing we could do is that we could actually build this with a generic interface and so forth, but for simplicity of our discussion about reflection, let's just focus on passing the parameter as type object. But we want to make sure that the value that's passed into us is something we can work with. So we want to make sure that it's a reference to a BankAccount or something that inherits from BankAccount. So we can put an if statement in place, put our type name BankAccount.class, that's the class information for BankAccount, and then we can call a method called isInstance and put target inside of there. That isInstance call will only return true if the object reference is a BankAccount or something it inherits from BankAccount. So as long as that's true, we can take the target and assign it into our BankAccount reference as long as we cast it. Now, in terms of good programming technique, if we've received a parameter we can't work with, we should actually go ahead and raise an exception, so the caller knows what went wrong. So now we need our other method, doWork. Now, doWork method is responsible to go ahead and launch the work. Alright, so we'll go ahead and create our new thread instance. What we'll do now though, is that remember, because HighVolumeAccount knows how to be run on a thread already, so what we'll do here is we'll use the isInstance test to see if the BankAccount it's pointed to is actually a HighVolumeAccount. If it is, we'll go and cast BankAccount to HighVolumeAccount and pass that into the thread constructor. Otherwise, we'll pass the reference to our AccountWorker into that constructor, just as we did before. Our run method will be just like it was last time, do the exact same work it did last time, and we can go ahead and start the thread. Now, one thing to note here is that in this case, I'm specifically checking to see if BankAccount points to HighVolumeAccount, and if so, casting it. What we could do here is that where we have HighVolumeAccount for the isInstance test and for the cast, we could actually just put Runnable there. Alright, so that way if we had another BankAccount derived class later that also implemented Runnable, this code would work for that as well. I went ahead and left a HighVolumeAccount in this case, because I want to make it as consistent with what we looked at in the last clip as possible. But just know that we could have just used Runnable there instead of HighVolumeAccount. So with this change to using an interface, how does that change the method that actually dispatches our work? Well, we'll still call it startWork and it still has the same parameters it had before. We're still going to call it just as we did before. Right, so we'll have an instance of our BankAccount class here, and we'll call startWork with our AccountWorker type name and the reference to BankAccount. The first thing we'll do inside of startWork is go ahead and get the type information for the worker. But now what we'll do is that because we're using the no‑argument constructor, we never need to go get the constructor information. Instead what we'll do is simply call newInstance against the type description for our worker. We're going to just cast that to the interface TaskWorker and assign it to a reference of type TaskWorker. That's a key difference from last time, right? The last clip we used object. Well, here we said a requirement is that it implement TaskWorker. So what we're able to do now is that once we create it cast into a TaskWorker and now because we've got a reference of type TaskWorker, the rest of our coding is not reflection based, it's just regular old programming. First thing we'll do is just call setTarget, passing in the target. We're just simply calling the methods defined by the interface, and then we'll call doWork, the method defined by the interface to do the work. Of course, we'll go ahead and wrap this in a try catch block to handle any exceptions that occur. But look what's happening here, is that we used reflection where we needed it. Reflection gave us the ability to create these types that we didn't necessarily know about when we coded up the program. But then by casting it into an interface, we now use just regular programming to do the actual work, and this is really kind of a really good strategy when we're working with reflection. You generally want to use just as much reflection as you need. We need a reflection in order to be able to dynamically create types like this. But by putting a very simple requirement of having it implement an interface, we were able to code in traditional techniques throughout the rest of our application. And this is a very common technique we see when working with systems that dynamically introduce types, right? Situations where you do it dealing with inversion of control or other scenarios where dynamic type creation is really important.

Summary
To wrap up, some of the key things you want to remember, remember that every type is represented by an instance of the class called Class. And there's exactly one instance of the Class class for each type. Now, getting access to a type's Class instance is fairly easy because there are so many different ways to do it. If you've got a reference to a type, you could simply call getClass that gets the information back. If you know the string name of a type, you can actually use the Classes.forName static method to get back that information. And if you got to type literal, you can actually just take the type name, .class, to get the information. With that class information, all aspects of a type become knowable. You can know the super class for that type, you can know what interface it implements, you can know what its fields are, what its methods are, what its constructors are, what are all the parameters that the methods of constructors take, and you can know all its access modifiers; is it a public class, is it a final class, is it an abstract class? One thing that is a little odd, though, is the way working with modifiers goes. Remember that modifier value is returned as a single int value. In other words, all the modifiers are contained in a single int value, and each modifier is represented by a bit in that int value. In order to interpret those values, you use the Modifier class. Now, it provides static fields that will actually let us work directly with the bit values, but more commonly we use the helper methods that let us do just regular logical checks to see if a certain modifier is present. Working with reflection, we can actually interact with objects. Remember that we're not limited to just looking up the information. Using reflection, we can actually access fields in a type, we can invoke its members, like invoke methods, and so forth. And we can use reflection to actually create instance as a type. If we've got information on the constructor, we can actually execute the constructor by calling its newInstance method, but if we want to create a type using its no‑arg constructor, we don't even need to get the constructor information. We can actually just call newInstance directly against the class for that type.

Adding Type Metadata with Annotations
Introduction
Welcome to the next module of the Pluralsight course, Java Fundamentals: The Core Platform. In this module, we talk about adding type metadata with annotations. My name is Jim Wilson. In this module, the first thing we're going to take a look at is the idea of the need for having metadata inside of our types. We'll then see how we can use annotations to add metadata. We'll then see how we can declare custom annotations, and this is really important because first it shows us how to actually declare our own annotations, but also helps in understanding how annotations work even when we're using the built‑in annotations. We'll then see how we can get access to annotations and the information contained within them from within our code. We'll talk about annotation target and retention, specifying what annotation or what a particular annotation could be used with and how accessible that annotation should be. We'll then look at the idea of simplifying the process of setting the values of elements within an annotation. We'll then look at the valid types for use with annotations. And then we'll finish up with this discussion of class cross‑referencing, in other words, using metadata to create relationships between one class and another.

The Need to Express Context and Intent
As developers, whenever we create our programs, we know those programs don't really stand alone. They always fit inside of some larger picture. At a minimum, the program is being run inside of some execution environment and that execution environment is being hosted on some operating system, but they give you much more than that. Well, maybe incorporating certain frameworks that automate the process of saving data inside of a storage system and getting it back out of it, or it may be running instead of some big hosting environment, like a Web environment or some other enterprise level environment. So what that means is that when we build our programs, those programs actually incorporate our assumptions, right, our assumptions about the type system that's being used, our assumption about any tool sets that are being involved, and our assumptions about the execution environment. So what that really means is that when we build our programs, those programs incorporate context and intent. The context we expect them to run in and our intentions for their behavior in that context. Now, the type system solves much of this issue. It allows us to really express those things in many, many cases, but the standard type system isn't quite enough. Now so often the case, the best way to really understand what we're talking about here is a look at some code. So let's first look at a case where the type system does a really good job of expressing the developer's intent. Let's take a class here called our TxWorker class, and this is a class we looked at earlier in the course when we talked about threading. Its job was to perform a single transaction on a bank account. So that information about the bank account, the type of the transaction, and the amount of that transaction. It has a constructor to accept those values. Then it has a method to do the actual transaction work. Our intent is for this class to be able to support multithreading environments, so it can actually be launched off on a separate thread. Now, putting our code instead of a method called run does not express that intent. The way we express that intent, is we have our TxWorker class implement the runnable interface. By implementing that interface, we then express the intent to support a multithreading environment, and then instances of our TxWorker class could be passed off to a thread that the body of the run method run over on that thread. Let's look at another case where the type system doesn't really allow us to express our intent. We'll get the BankAccount class, it's the class that our TxWorker operates on. Now it has a couple fields inside of it, the account ID and the current balance, it has a constructor to accept those values, it has some methods that allows us to interact with the bank account. Now, our BankAccount class does not explicitly extend any other class. And we know that means that it has an implied extension of the Object class. We know the Object class has a method called toString that allows a tight instance to be converted into a string. So what we would like to have happen is that any time our instance of our bank account is converted into a string, we'd like to return back the account ID and the current balance. So we go ahead and we override the toString method. But now we have a situation. On a standard QWERTY keyboard, the I and the O are right next to each other. And if I accidentally call this toStrong instead of toString, I'm not overriding any methods. And we know that in Java, there's no difference in the way we write a method when we're overriding a base class method, than the way we write a method when we're actually declaring that method for the first time in the current type. So I have no way to express my intent to override a base class method, which means this code will compile just fine, and I won't know that I made a simple typo until later when I'm testing the program and when a bank account is converted to a string, rather than seeing the account ID and balance, I instead see the Object class's implementation of toString, which just shows me the type name. So what that means then is that we need a way to extend the type system so we can incorporate context and intent more effectively. Now we often try to incorporate information like this manually. We might write comments in our code. We might write some documentation to express things like that, but that stuff just isn't enough. We need a structured solution to this problem. Because if we have a structured solution for incorporating context and intent, that means that tools can operate on that information. And in our next clip, we'll see the role that annotations play in solving this problem.

Using Annotations
We established in our last clip that it would be useful to somehow incorporate this idea of context or intent into our applications. Well, that's the role played by Java annotations. Annotations are special types that act as metadata. You can apply that metadata to specific targets. You can apply the metadata to a class or to a method. Now annotations have no direct impact on their target. They don't do anything to change their target's behavior. Instead, annotations must be interpreted, so tools or the execution environment or even our own programs can actually look at this metadata and take specific actions based on it. Now the way we get annotations into our code is really simple. Each annotation, of course, has a name. So we simply take the annotation name preceded by an @ symbol, and then place that directly before our target. Now the specific target will vary depending on the annotation. Some annotations can only be applied to classes. Some can only be applied to methods. Some can be applied to classes or methods and many different mixtures of that. We'll talk more about that specific issue of targets a little bit later in this module. So let's see how annotations could help us out with that problem we ran into in the last clip where we mistyped the name of the method we were overriding. So remember that we typed toStrong. We meant to type toString because we wanted to override the toString method we were inheriting from the Object class. While using annotations, there's an annotation called Override, so we can simply put @Override before the method we're declaring that we wish to use to override the base class implementation. Well, during the compilation process, the compiler looks for a variety of annotations to be present. In the case of Override, when it sees it, it takes a look at the signature of the method that follows the annotation. It looks to the super classes to see if there's a method with that signature that can be overridden or if the type is implementing an interface that has a method with that signature. If neither of those is true, the compiler will then generate an error saying that there's no method with that signature to override. Now as we look at annotations in the context of the core Java platform, the primary role of the core Java platform annotations is to provide the types necessary to create annotations. The core platform has only a few annotations of its own, but it provides that foundation so that many of the other tools and environments that are available can then leverage annotations. So a lot of different environments rely on annotations. Java Enterprise Edition makes heavy use of annotations. A number of different tools rely on annotations. A very popular one is the JAXP XML processor. We could even use them in our own code. We'll see shortly how we can do that. The specific annotations that the Java core platform actually provides are primarily focused on compilation. We've already seen the Override annotation. There's another one called Deprecated that could be used to indicate that a certain method or class is no longer a preferred way to do something. There's one called SuppressWarnings that is useful for scenarios where you're doing something that generates compiler warning and you don't want to see that message because you know that's the case, and that's actually your intent. There's a few others that we'll see also a little bit later in this module, but these are the most commonly used ones here. Let's look at some more code here to get a sense of what it's like to work with deprecated and suppressed warnings. So let's say we have a class here called Doer. And there's a method in it called doItThisWay. Then we have another class called MyWorker that has a method called doSomeWork. It takes advantage of the Doer class and calls it doItThisWay method. My MyWorker class also has another method called doDoubleWork that creates two instances of Doer and calls doItThisWay on each of those,. And this code is all working fine. Then let's say the folks who maintain the Doer class realize that there's a better way to do things. So they create this method called doItThisNewWay. And they'd like people to move to doItThisNewWay, but they want to just break all the code that's relying on doItThisWay. Well, what they can do is mark the method doItThisWay as @Deprecated. So now the next time the folks who control the MyWorker class compile this code, they'll now get warning messages indicating that the use of doItThisWay is now deprecated, and then they can take appropriate action. Now, of course, moving to the new method doItThisNewWay would require testing, and maybe they don't have time to do that right now. So maybe they'll schedule that change over for sometime in the near future. Well, what they could do is actually mark the entire class MyWorker with SuppressWarnings deprecation, which says, don't show me deprecated warnings. And then now those warnings will no longer show up in the compilation when they compile the MyWorker class. Suppressing warnings at the entire class level is a very dangerous thing to do because we could accidentally mask other warnings that come up later that we don't even know about. In general, rather than suppressing warnings at the entire class level, it's better to do it as close to the place where you know you want the warnings suppressed as possible. So in this case, we would suppress warnings on these individual methods. That way, if the MyWorker class had other code that's not in these two methods that later developed warning messages about deprecation, they wouldn't accidentally suppress those messages. Okay, so now in the next clip, let's see how we can start declaring our own annotation.

Declaring Annotations
Just as we can have built‑in annotations, we can also create our own custom annotations. What that means then is that we can actually build our own solutions that leverage the concept of metadata. We can actually build our systems to act on metadata that's contained in the types that we offer it on. We have all the same capabilities as the built‑in annotations, so that opens us up to a lot of possibilities. Now I think the best way to kind of really understand what we can do using our own custom annotations is to use an example. So what we'll do is that we'll build on that flexible work dispatch system that we were using at the end of our reflection discussion. Remember, what this guy did was that we had a system to allow us to load in dynamically types we called workers, and those workers had the ability to operate against some target object. Now our requirements were fairly minimal. Where we had our worker types, they had to have a no‑argument constructor, and they had to implement a custom interface of ours called TaskWorker. And, again, remember that's our custom interface, and it had two methods on it. One was setTarget to allow us to pass in the thing to operate on. The other method was called doWork, which basically said, Okay, go ahead and do whatever it is you do. What we want to do now is kind of extend the capabilities of our system. What we want to do is give some threading options now. Now we want to allow workers to create their own thread if they want to. Now, remember, in our reflection discussion, they had to create their own thread. What we want to do now is give them a second option. Our hosting application will now have its own thread pool. So if workers want to, they can run on our thread pool as opposed to creating their own thread. And what it'll do is it will actually use our own custom annotation to allow them to indicate to our application whether they want to create their own thread or leverage the thread pool. Now annotations are kind of an unusual type because annotations are actually a special kind of interface, but their usage is a bit more restricted than interfaces in general. The most notable thing is that you can't explicitly implement an annotation. Now annotations all extend the annotation interface. Now they do that implicitly. You don't explicitly extend it, but they're all considered to extend the annotation interface. The thing that's kind of odd is that as you're working with annotations initially, they don't really feel much like interfaces. They don't really look like them. They don't really seem to act like them at first. We'll see as we dig a little deeper into annotations that interface‑based characteristic starts to rise to the top. We'll see that just a little bit later in this module. So now as we want to go and declare an annotation, we'll find that we declare annotations very similar to interfaces in the sense that we actually use the interface keyword. But we actually precede the @interface keyword with an actual @ symbol. So we're going to go ahead and declare our own annotation. We have, again, the @interface keyword preceded by an @ symbol. And then we give it the name of our annotation. So we're going to call our annotation WorkHandler. Notice that after the annotation name, we have an opening and closing squirrelly bracket. We'll see we can put some content inside of there. Now our annotations can have the same modifiers interfaces can, so we can actually mark this as public. And our annotations can be declared in the same places that interfaces can, so they could be a top‑level annotation, or they could be nested inside of another class or inside of an interface. Now as we mentioned, annotations can actually have content inside of them. That content is called elements, and elements allow us to associate values within an annotation. Now the way you declare an element looks very much like a method. In fact, it looks exactly like a method. So if we want to have a value inside of our annotation indicating whether this should use the thread pool or not, we can call it useThreadPool, and we want to make it Boolean. So we'll declare just like it's a method called useThreadPool that returns back a Boolean. But we'll see that when someone uses our annotation and they want to interact with our elements, they're actually going to do it much more the way that they might interact with a field. They can actually assign values into our element. So let's see what it's like now to use this annotation that we've just created. So what we're going to do is we're going to actually build again on the types we were using at the end of our reflection discussion So what we're going to do is have this AccountWorker class. This is the exact same AccountWorker class we were using at the end of the reflection module. It implements the Runnable interface, and it implements our custom TaskWorker interface. It has a field inside of it of type BankAccount. It has the setTarget method on it, which is required by our TaskWorker interface that allows us to pass in the bank account to work on. It has a doWork method inside of it, where it's going to do the actual work that it's responsible to do. Now inside of there, it goes ahead and creates a thread, starts that thread up, and it also implements the run method that's required by the Runnable interface. So it's pretty clear that this AccountWorker class creates its own thread. So it's not going to want to use our thread pool. So what we'll do then is actually mark it with our @WorkHandler annotation. So notice we just give it the @WorkHandler name preceded by the @ symbol. That's exactly the way we use annotations that were built into the system. But remember that we have an element called useThreadPool, and we want this class to tell us whether it wants to use a thread pool or not. So inside the parentheses, it just simply says, useThreadPool, then equal sign and the value. And so you see, we're actually setting it as if it's a field. So what this does now is actually associates our @WorkHandler annotation with this AccountWorker class, and it has a useThreadPool element with a value of false. So now, of course, the question is, How do we get access to all of this inside of our code? And that's what we're going to take a look at in the next clip.

Accessing Annotations
So we've seen how to declare an annotation, and we even have a type that's using our annotation. The thing we need to understand now is how do we get access to the information associated with that annotation? Remember that any time we want to see information about a type or its members, what we use is reflection. And that holds true for annotations. We use reflection to get information about our annotations. The information for a particular class or its members, each of those implement a method called GetAnnotation. And what we can do is pass in the type information of the annotation we're interested in. And what that will do is give us back a reference to that annotation's interface. Now if the annotation isn't actually associated with the target that we've called getAnnotation against, we'll then get back a null. So we can easily identify whether a type or a particular member is even using an annotation or not. And if it is using the annotation, then we can use the annotation interface to get information about what's contained in that annotation. So let's see now how this affects the example code that were going through. So we've got this method here, our startWork method. Now the startWork method is the same method we were using back in our reflection example. So this is the method that's responsible for creating the worker type and getting the work going. Now remember from the end of our reflection module, basically this was pretty simple code. It's that basically received in the name of the class that was going to be the worker and a reference of the object that was going to be worked on. So what we then did was get the class information for that worker class. In other words, we used a string name and converted into the class instance that describes that class. What we would then do is create an instance of the class, and then we would use our TaskWorker interface methods. We would go ahead and call setTarget to pass in the objects we worked on to the worker, and then we would ask the worker to go off and do the work. And remember that that worker was responsible for taking care of getting its own threading going. Well we've now introduced a change. We're saying now that our dispatch program now also has a thread pool. So we basically had a class‑level variable called pool of type ExecutorService, and that gives us the ability to interact with a thread pool that our dispatch program has actually created. So now remember, we relied on an annotation for a worker to indicate whether it wanted to use a thread pool or not. So what we want to do is get access to that annotation. So the annotation is actually on the worker class. So what we'll do is go to the class information for the worker type. Remember we said we'd call it getAnnotation. And then we pass in the type information for the annotation. So we want the WorkHandler annotation, so we pass in WorkHandler.class. And what that will then do is give us back a reference to our WorkHandler interface. Remember we said that when we declare an annotation, it declares very much like an interface. But when we use it to mark types and members, it didn't look much like an interface. But now we're seeing that we want to actually see the information associated with an annotation, now we're using it like an interface again. So our variable here, wh, is a reference to the WorkHandler interface. So we can then use it just like an interface. So if I want to find out what the value of our useThreadPool element is, remember we declared that element as if it was a method. So we actually call a method called useThreadPool. And that will return back true or false based on what that value was set for in the actual annotation. So if you useThreadPool returns true, remember we want to actually do the work on our thread pool. So we'll call pool.submit. And what we'll do here is that we'll just go ahead and put together an anonymous class that implements the Runnable interface. Is has one method on it called run. And what we'll then do is take our worker.doWork. And what that'll cause to have happen is the worker.doWork will be called within our thread pool. So we're now leveraging our thread pool for that worker. If you used thread pool and it returned back false, then we'll just go ahead and do it the old way. Just call worker.doWork directly, and it's the workers responsibility to take care of the threading. So, as you recall, when we said that if we ask for an annotation and we can't find it, getAnnotation returns back null. And what we'll do here is will go ahead and just throw an exception if we get back a null. And unfortunately, this code right now will actually throw that exception. We can't find the WorkHandler as things are set up right now. Now the interesting thing is is that there's nothing wrong with the code that we've written inside the startWork method, so there must be some other problem. And in the next clip, we'll see exactly how to resolve that problem.

Annotation Target and Retention
So why were we unable to access our annotation? The annotation was applied correctly to the type, and the code to access to annotation was correct. The problem is that the annotation isn't actually available in the runtime right now. But annotations can actually specify their availability. So part of the annotation declaration, we can actually apply an annotation called Retention to our annotation declaration to basically say when do we want our annotation to be available? So basically, if we take our WorkHandler annotation decoration, we simply put @retention before it to say that I want to specify when this annotation is available. Now the way we specify when it's available is by passing in a RetentionPolicy value. Now there are three possible retention policy values. One is the value of source, which says that I only want the annotation to be available within the source file. So if you have retention policy of source, the compiler actually throws away the annotation. So it never even makes it into the class file. Now the retention policy also has a value of class, which says that I want to have the annotation compiled into the class file, but the runtime should discard it, so it never makes it into the runtime. Retention policy class is the default value, which is why we couldn't access our annotation in code because the runtime never loaded it up. But there is one more retention policy value, which is runtime, which says that I want to actually have the annotation loaded up into the runtime. And so once I've done that, then my annotation becomes accessible through reflection. Now as you can imagine, retention policies of source and retention policies of class are primarily really focused on tools builders, things that analyze the source code or things that analyze the contents of class files. But runtime retention policy is useful to any application developer because very often we want to actually, during runtime, take a look at the annotations we have associated with our types. So now if we take a look at our WorkHandler annotation now, all we have to do is mark it with an @Retention beforehand and say RetentionPolicy.runtime. And now this annotation will be available during application runtime. So now the code that we wrote our startWork method, with no changes to it all, will now work properly. When we call workerType.getAnnotation, we will now get back a proper reference to our workHandler annotation. Now this doesn't mean that our WorkHandler annotation is completely perfect. There's still a bit of a problem. Now our code to interact with WorkHandler will work just fine. The problem is that the potential exists for people to misuse our annotation. Now we know that we want our WorkHandler annotation to be applied at the class level exactly as it's shown on the screen right now. But as we've declared our WorkHandler annotation, someone could also apply it to other things. They could apply it to a field. They could apply it to a method. They could given apply it to a local variable. Now the issue is that we've done nothing to specify what are our annotation could be applied to, which means it could be applied to anything that's legal to apply an annotation to. So what we want to do is go ahead and narrow the allowable targets for our annotation. Again, we do that as part of our annotation declaration. And again, we do it using an annotation, the Target annotation. The target annotation accepts an element type value, and that allows you to specify what you can apply it to. And there's a long list of values inside of element type. It's all the things are possible. It could be a type. It can be a constructor. It could be a field. It could be a method. It can be another annotation. So basically, we simply use it by saying Target and saying something like ElementType.CONSTRUCTOR would be used to say that this annotation is valid to be used on constructors. Now we know that there are some cases where annotations actually apply to multiple targets. Think of that suppress warnings example we saw earlier in this module. We could use that on a type, or we could use it on methods. So the way we do that is that we can actually use an array notation to specify the ElementType values we want to use with the Target attribute. So to do something that's valid on both a type and a method, we simply say Target. We use the squirrely brackets at both ends, just like we're initializing an array, and comma‑separate the values. So here we have ElementType.TYPE, ElementType.METHOD enclosed in squirrely brackets. So we want to do that in the case of our WorkHandler annotation, we've got our declaration there, we've already got a retention policy in place. Now we'll just go ahead and add the Target annotation as well, saying ElementType.TYPE. Now notice here that we're actually applying multiple annotations to our our WorkHandler annotation. And it's important to note that the order doesn't matter. Currently, I have Target on top and Retention on bottom. We could switch those and it wouldn't change anything. So now our WorkHandler annotation is all proper. That retention policy is already set up correctly. And now any place that's other than the type, the compiler will complain about the use of WorkHandler. So we couldn't use it in a local variable, it wouldn't allow it on a method, and it wouldn't allow it on a field. So now we've properly set up our WorkHandler annotation. In our next clip, we'll dig a little bit deeper into the capabilities of annotation elements.

A Closer Look at Elements
Let's take a bit closer look now at some of the capabilities the elements provide. The first thing we'll look at are some of the options that are available to simplify the process of setting element values, and these are targeted towards handling common cases. Two things we're going to look at are the idea of an element having a default value and then a shorthand that's available for assigning values to an element. Now we can set an element up to have a default value, and basically we do that using the default keyword. So when we declare the element, we follow it by the default keyword and the value we'd like to use. Giving an element a default does not prevent us from explicitly setting its value. It just means we don't have to set it when we want to use the default. So let's take a look at some code here. So here is our @WorkHandler annotation that we've been working with. We've got that useThreadPool element. And let's say that since we provide a thread pool, we want most @WorkHandler implementations to actually use the thread pool, so we'll give our thread pool a default value of true. So we'll just say default and then true. Now when I go ahead and have a class that uses the annotation, if that class wants to go ahead and explicitly say usedThreadPool = true, it's still completely able to do that. But it could also get useThreadPool with a value of true by simply not providing it at all. So the same exact behavior, the useThreadPool has a value of true. Now if we wanted to have a value of false, then we need to go ahead and explicitly assign it that value of false. Elements have the ability where we can in some cases assign the element a value without actually using the element name. Now there are two criteria that have to be met for that case to work. One is we have to be setting only one element on that annotation, and the element that's being set must have a name of value. So let's take a look at our code again. So we've got that same @WorkHandler annotation we've been working with, and we have a type here, our AccountWorker, that actually uses the @WorkHandler annotation, and it's using the default value for our element useThreadPool. Well, if we take our useThreadPool, and we now change its name to value, now in the case of using the default value, nothing changes here. But now if we want to set it to false, all we have to do is include the word false inside the parentheses after the annotation, and that will then automatically assign that to the element named value. As we've seen, elements are declared to be of a specific type, but it turns out that there's only a very specific subset of types we're allowed to use with elements. Now as you might expect, we are allowed to use any of the primitive types. Throughout our discussion, we've been using Boolean, which is a primitive type for elements. Beyond that, we can use a string. Elements can be any of the enums. Elements can also be an annotation type, meaning that an annotation can have an element whose type is another annotation. Elements can also be class information. It doesn't mean an instance of an object. It means that elements can store type information inside of them. We'll talk more about that one in just a moment. Elements can also be an array. So each element can be an array, but it has to be an array of one of the types that we're showing here. Let's take a closer look now at this idea of an element whose type is class. And to do that, we'll continue walking through the example we've been using throughout this module. So remember that what our example allows us to do is have something to be worked on, in this case, we'll say a BankAccount. Then we can call a method called startWork. We could pass in the thing to be worked on, our BankAccount, and then pass in the string identifying the type of the class that knows how to work on that thing, the BankAccount. And, of course, the power here was that it allowed us to have workers of types we didn't necessarily know about at compile time, so it could read that type of information from a file or from somewhere else. And that's a really powerful concept. But the idea of matching things to be worked on with the types that know how to work on them are not limited to scenarios where you may not know all the types at compile time. There may be lots of cases where you know all your types at compile time, but you still have to somehow match up workers with the things to be worked on. So let's take a look at our BankAccount class here, and we know that we want the AccountWorker class to be the thing that works on it. But we do know about the AccountWorker class at compile time. Well, it'd be nice if we could create that relationship between the BankAccount and the class that works on it right here as part of the metadata in our BankAccount class. And we can do that. We could create an annotation called @ProcessedBy who had an element whose type was class, and then we could pass in class information into that element. So in this case, our BankAccount is identified to have the @ProcessedBy annotation with a value of AccountWorker, the type of information for AccountWorker. With that, we could then have code where we create an instance of our bank account, but maybe we call a different method. We'll call this method startWorkSelfContained, and it accepts only one parameter, which is the thing to be worked on. And what we'll do is rely on metadata to create the relationship between the thing to be worked on, the BankAccount, and the class that knows how to work on it. So now what does that annotation look like? We'll go ahead and declare it as we normally do. We're calling it @ProcessedBy. We'll set the annotation target to be ElementType.TYPE, meaning this annotation is only associated with types. And we'll set its retention to RUNTIME, saying that we want it to be available in the runtime. Remember, if we have to do that, we're going to use reflection to get access to this annotation. The element inside the annotation has to be of type Class, and we'll go ahead and call it value. And with this annotation declaration, we could then have that BankAccount class in place there marked with a @ProcessedBy passing in the AccountWorker class information. So we now have the annotation in place. So we now want to be able to create the instance of BankAccount and pass it into our startWorkSelfContained. So the question is, What does startWorkSelfContained look like? Now we wanted to do exactly the same thing as our old startWork method did. We just want it to use the metadata to create the relationship. So our startWorkSelfContained method accepts one parameter, the thing to be worked on whose type is object. So the first thing we need to do is get the class information for the thing to be worked on. And then once we've got the class information, we can get metadata from that class. So then we take our targetType information called getAnnotation, saying I want the annotation whose type is @ProcessedBy. Then we get back a reference to @ProcessedBy. Well, now we can get to the elements. Remember, our element was called value, So we'll simply call the value method on there, which gives us back the value of that element. Now once we get that back, because our element called value's type was class, we now have the class information for the workerType. What that means now is we can go ahead and create an instance of that workerType. So now we've got an instance of our AccountWorker class. And from here, all the stuff we did inside the startWork method, we can now do here. We can go ahead and set the target for the worker to work on. We can call its doWork method. We can assign it into our thread pool. All those things. But what we've done now is use metadata to create a relationship between one type and another.

Summary
To wrap up, here are some of the key things you'll want to remember from this module. Remember, that programs always incorporate some context and intent. Right, there's always assumptions evolved. Oftentimes, the standard type system is enough to capture that, but it's not always enough. Sometimes we need metadata to fully capture our ideas of context and intent. Annotations act as metadata. Remember that annotations are a special kind of interface. But annotations do not change the behavior of their target. They're only meaningful when they're interpreted, all right, so a tool or a runtime environment or our applications have to actually interpret the annotations to do something with them. Now, in addition to the built in annotations, we can declare our own custom annotations. Now annotations are declared very similar to interfaces. In fact, we use the interface keyword. We just precede the interface keyword by the at symbol. Now when we set up our own annotations, we have to be sure to set the retention to control their availability. Remember that by default, annotations do not load up into the runtime unless we properly set the retention. In addition, we want to set the target on an annotation to narrow its use. By default, an annotation that we declare could be used anywhere it's legal to use an annotation, which is generally not what we want. So we want to go ahead and specify what our desired targets are for our annotation. Remember that annotations are accessed with reflection and doing so is really easy. We simply call the getAnnotation method on the information for whatever the target is that our annotation is associated with. Remember that annotations can optionally have elements. All elements do is give us a way to associate values with an annotation. Now elements are declared as methods, but when it comes to setting them, it's much more like fields, in general we just use an assignment to do so. Remember that we can associate a default value with an element. And remember, there's one special case in naming elements. If an element's name is value, we don't have to include the value name when assigning it, as long as it's the only element value we're setting. Okay, that's it for this module. In our next module, we'll talk about persisting object with serialization.

Persisting Objects with Serialization
Introduction
Welcome to the next module of the Pluralsight course, Java Fundamentals: The Core Platform. In this module, we talk about persisting objects with serialization. My name is Jim Wilson. Now throughout this module, we're going to look at the aspects and issues involved in Java serialization. We'll first take a look at the purpose and capabilities of Java serialization. We'll then see what's involved in making a type support serialization. We'll then see exactly how we serialize an object out to a serialization stream, and then restore that object information back from that serialization stream. We'll then look at how we create class version compatibility, and what we mean by that is that how do we maintain compatibility with a type that may have been serialized when I had a type definition with one set of fields and then later is deserialized back into that type, that type has now added or removed fields. We'll then look at the process of customizing the serialization process. We'll then look at the issue of transient fields, in other words, the issue of having a type that supports serialization, but that type may have specific fields that we want to exclude from serialization. Okay, so let's get started.

Java Serialization Overview
One of the really powerful concepts that's built into Java is the ability to persist objects. And what we mean by that is that we can take an object that exists in the runtime and store that object out to a byte stream. And then we can take that byte stream and completely reproduce that object. And in most cases, taking advantage of this capability requires very little programming because the Java runtime leverages reflection. By using reflection, it can know all the members of your type, and it can get and set the values of that type. Now by default, this capability only operates on instance members because it's really designed around restoring instances of objects, but the ability is highly customizable. So if you needed to incorporate statics, you could do that by customizing it. Now having this ability to persist objects like this opens up a ton of possibilities. One thing is the simple idea of saving state. If you could actually have objects that represent the state of your application, you could save them out to the file system. When the application restarts, you can restore them back and have the state fully reproduced. You can also store your objects inside of a database. And so the idea is that rather than looking at individual fields on a table and manually setting those values in your object each time, you can actually store and retrieve entire objects. If you're working with a relational database management system , it will generally store these objects as a blob. With other systems like object‑oriented database management systems can actually directly store and retrieve objects using serialization. This also gives us the ability to pass objects across address boundaries. So you can actually take an object graph that's in one application space and then pass it over into another application using things like shared memory and so forth. Or you could even pass them across the network. So an object presentation on one machine can actually be passed to another machine and restore it over there. Now this capability is referred to as serialization, and serialization really has two sides to it. On one side is the side of serializing, and that's storing out to the byte stream. And the idea is that you pass in an object that you want to store. But serialization is actually very intelligent that when you pass it an object, it doesn't just store that object. It stores the object and any other object that it points to. That's what we call an object graph. So when you pass in an object, the entire object graph referenced by that object is then passed out to the byte stream and has all the information about the types that are involved there and all their values. So that's the serializing side. The other side is deserializing, and that's the idea that we restore that object graph. So we can start out with the byte stream and then basically just take that byte stream and have the entire object graph completely rebuilt. So when we use the term serialization, we're really including both sides of this, the idea of serializing out to the byte stream and then deserializing from the byte stream. Working with serialization really revolves around three core types. There's the serializable interface, and that's implemented by any type that wants to be serializable. And it simply indicates that that type supports serialization. Now the funny thing is is that the serializable interface has no methods. It's what we call a marker interface. It simply means that if I implement that interface that I have verified that my type is capable of being serialized and deserialized accurately. Now in order to be able to serialize the type, we use a class called ObjectOutputStream, and basically that has the ability to take an object graph and write it out to a stream. Then on the other side, we have ObjectInputStream. It actually has the ability to take the stream of bytes that was serialized and then deserialize that back to the object graph. Okay, so now that we've seen the terminology involved in serialization and the types that are involved, in our next clip, we'll see exactly what's involved in making a type serializable.

Being Serializable
So if we have a type that we want to be serializable, well what do we have to do? We know that one of the key requirements is that we implement the Serializable interface. But now as we mentioned, that interface doesn't have any methods. It's a marker interface, meaning that if we implement that interface, we're saying that we know our type is serializable. But what does that really mean? Well, in general, for a type to be serializable, all of its members need to be serializable. Now for primitive type members, that's not a problem. Those are all serializable by default. But for other members that are not primitive types, in order for them to be serializable, they themselves have to implement the Serializable interface. So let's take a look at some code and see what this is like. So let's take the BankAccount class that we've been using throughout much of this course. Remember, we had two core fields here. We have a balance field, which is an int, and then we have an id field, which is a string. We have a couple constructors along with the other members. So now if I go off and I new up an instance of this BankAccount class, passing in an id value of 1234 and a starting bounce of 500, we know that allocates out the memory for our BankAccount. We have our balance field, which will have an initial value of 500. And then we'll have our id field, which will have an initial value of 1234. Now again, we want our BankAccount to be serializable. Well balance type is int. That's a primitive type. So our balance field is indeed serializable. But now what about the id? The id field is of type String. String is not a primitive type. String is an object. So what that means is that in terms of what the memory looks like for our BankAccount, the 1234 is not actually stored inside of the memory of the BankAccount. Actually, there is separate memory allocated, which is the String object. That's what contains the 1234. Inside of our BankAccount class, it's simply a reference to that instance of the String class. So what that means is that our BankAccount class is a simple object graph. The root of the graph is the BankAccount object. The node of that graph is the 1234, the string. So since our id field is not a primitive type, it's a string, which is an object, that means that we need to verify that that class String is serializable. So what we need to do is go out and check the documentation on the String class. And we'll notice that the documentation of String class says that the String class implements the Serializable interface. So that's saying that that class String is indeed serializable. So that means that our other member id is indeed serializable. So now we know our BankAccount class is serializable because all of its members are serializable. So what we'll simply do now is in our BankAccount class implement that Serializable interface where there are no methods. But now by implementing that, we're indicating that yes, our BankAccount class is itself serializable. Okay, so now in the next clip, let's see what code we need to write in order to serialize and deserialize instances of our BankAccount class.

Serializing/Deserializing an Object
So now we know our BankAccount class is serializable. So let's go ahead and create an instance of the BankAccount class, again we'll give it an Id of 1234 and an initial balance of 500. Let's go ahead and make a deposit of $250, so now our current balance would be $750. Let's say we want to go ahead and serialize this out to a file called account.dat. So we'll have a method we write called saveAccount that accepts a reference to the BankAccount to be serialized and the file name. So saveAccount will have those two parameters, alright, the BankAccount to be serialized and the file name. And now the work of actually serializing your BankAccount will be done by the class ObjectOutputStream, and that can serialize out to any stream. What we'll do is go ahead and create an OutputStream over that file that was passed in. So now when we're done there, we actually get a reference to an ObjectOutputStream that knows how to serialize instances and objects into that file. We'll go ahead and put this in a try with resources. So we close the stream as soon as we're done. We will need the handle IOExceptions because we are dealing with the file system. So now how do we actually serialize the object? Well all we do is call the writeObject method against our ObjectOutputStream, passing in a reference to the object we want to serialize. And so that easily, it writes out the type information for the object being serialized, the value of its members, as well as any type information required for the members that it contains. So it does that for the whole object graft, meaning that anything that our object references, any other objects that those objects reference. So then how do we actually read it back in? Let's go ahead and create a method here called loadAccount that accepts a file name that we want to deserialize from, and it returns back a reference to a BankAccount. We'll create a local variable here that's of type BankAccount, and now we're going to use ObjectInputStream to do the work of deserialization. Again, we'll open up a file stream over that file name, which then give us back a reference to an object input stream that can now deserialize the objects from that file. Again, we'll put this in a try with resources and handle any IOExceptions. So now to actually get the object back out of that stream, we simply call the readObject method against our ObjectInputStream. Now remember that the serialization information contains not just values, but the type information of what's been serialized. Well, it's possible that you try to deserialize a type that's not in your class path. If that were to happen, the readObject would actually throw a ClassNotFoundException. But now in our case, we do have access to all the types, so the readObject actual returns back a reference to the BankAccount class that has all the values that were contained at the time that were serialized. So we can simply return back that BankAccount reference. So that means that we can then call this loadAccount method, passing in the file name, again, this is the same file name that we serialized to in the last slide. That gives us back the reference to the BankAccount in the exact state it was in at the time we serialized it, which means that if we now write out its Id and balance, we'll get out an Id of 1234, and the balance at the time it was serialized, which was $750. And so you see that easily, we were able to capture the state of an object, save it, and then later restore it. But now there is one potential issue here. What if we serialize our BankAccount class with our two fields in it, but then later changed the fields that are inside of our BankAccount class, we actually change the class definition, how does the serialization system handle the scenario of deserializing a type that has changed since it was serialized? And that's what we'll take a look at the next clip.

Class Version Incompatibility
Let's take a look now at how changes to our class definition affect serialization. So if we look at our BankAccount class, we have just the two fields that we've been talking about. Right? The id field and the balance, and our class rotation's pretty simple at this point. We've got a deposit method, which simply increments to balance, and then we have withdrawal method, which simply decrements to balance. So if we look at the code we used earlier to serialize this class where we created an instance of our BankAccount class, we then made a deposit against the account, and then we called that SaveAccount method that we wrote to actually serialize this BankAccount instance. Let's say our application exits and then before we run it next time, we go into the source code and we realize that we want to actually enhance the BankAccount class a little bit. In addition to those two fields that we already have, we also want to start keeping track of the most recent transaction. So we add a field that has the last transaction type, and we also have another field which has the last transaction amount. So we'll store the last kind of transaction and how much that transaction was. So, of course, we're going to need to go ahead and update our deposit method so that in addition to incriminating the balance, we'll also have to store a value for the last transaction type, which we'll use a d for deposit, and the amount of that transaction. Similarly, we'll go ahead and update our withdrawal method so that in addition to decrementing the balance, we'll go ahead and add a last transaction type of w, and then store the corresponding amount. When we run our program now, the BankAccount class is different. So that when we call that method loadAccount that we wrote in the last clip to go ahead and load up an instance of our BankAccount class, we'll actually get an InvalidClassException, because the classes don't match up anymore. Now obviously, the class definition for BankAccount that we're trying to load into is different than the BankAccount class definition that was serialized. Let's see how Java made the determination that there was a difference in the class. Let's look first at the BankAccount classes we initially had that were just the two fields. Well, when we went to go ahead and serialize that field into the stream, what Java did was it calculated something called a serial version unique identifier. And basically, it's a secure hash value that identifies the structure of the class. Well, when it writes that information out to the serialization stream, it includes this serial version unique identifier into the stream content. So then later when we went ahead and we changed our BankAccount class so that in addition to the original two fields, we had the transaction type and transaction amount fields, when we went to deserialize the bank account definition that was in our serialization stream, before actually doing the deserialization, Java calculated that same value for the current bank account definition. It then pulls the value out of the serialization stream, and then it compares those two. If those two values do not match up, Java then throws the InvalidClassException, indicating that the serialized version of the class is not compatible with the current class definition that we have. Now honestly, we need to be able to make changes to our classes over time, and serialization needs to be able to deal with that. So in the next clip, we're going to see how we can make changes to the class and maintain version compatibility.

Creating Class Version Compatibility
As we saw in our last clip, that serial version unique identifier, what we have to call serial version for short, is a really important value. That's what we use to determine compatibility of versions of our type in the serialization system. So two versions of a type definition are only considered compatible if they have the same value for the serial version. As we saw, Java can calculate that value for us at runtime, and the resulting value is affected by a number of factors. The type name factors in, what interfaces are implemented factor in, as well as the members of the type factor in. What that means though is that by letting Java calculate this value for us at runtime, the content of our type determines compatibility between versions. In other words, any change to the content breaks compatibility. Now it turns out though that we can actually specify the serial version as part of our type definition, and by doing that. rather than types content determining compatibility, we as developers get to determine compatibility between different versions of our type. So how do we specify the serial version as part of the type definition? Well, what we do is that we have to add a field to the type. That field's name has to be serialVersionUID. It has to be of type long, it has to be a static final, and in general it should be private, and the reason that it's private is that normally the value of the serialVersionUID is of interest to nothing other than a serialization system. So what we do then is that when we first create the type, we calculate the initial value for our serial version, and we'll do that using a utility called serialver, that we'll look at more in just a second. And then what we'll do is we'll maintain that same serial version value for all future versions of our type. And that's how we maintain compatibility. Now let's take a look at the serialver utility. Now the serialver utility basically performs the same calculation that the Java runtime did when determining the serial version value. The utility is found as part of the JDK in its bin folder, but it's worth noting that many IDEs provide a plugin to do the same things as this utility. Now when it comes to using our serialver utility, it performs its calculation using the class file. In other words, it doesn't use a source file; it actually looks at the class file to determine the serial version value for a type. Now it finds a class file in much the same way as running a Java program. It'll actually search in a local folder for it, or you can provide a class path for it to use. Now when we run the utility, we have the option of passing the class name directly on the command line, and if we do that, it will display the resulting value back to the console. Alternatively, we could run the serialver utility with the ‑show option, and in that case it'll display a simple GUI for us to interact with. So let's see how we calculate this serial version value. So let's take the initial version of our BankAccount class with just the two fields in it, and let's assume it's in a pack; it's called com.jwhh.finance. And so we go ahead and we compile this class, and we put the results, we'll say into a folder called mydir. Well, mydir will then have a sub folder structure corresponding to the package name. So I have a sub folder named com, which has a folder named jwhh, which has a folder named finance, and our BankAccount.class file will then be inside of that folder. So what we could then do is open up command prompt in that mydir folder. We can say serialver. Now, of course, this assumes that the JDK bin folder is in our path. So we go into serialver, and we can say com.jwhh.finance.BankAccount. If we did that, we would then see the resulting calculation just displayed back to the console. So alternatively, we can run serialver and then put ‑show after it. And what that then does is open up a simple GUI. What we would do then is that we would type in the type name inside that full class name field. We then go off and click the Show button, and then that displays the resulting calculation for us. In fact, it shows not just a calculation, it shows the full declaration of that serial version UID field. So now let's take a look at our class again. So we've got our BankAccount class and this is our original version, the one containing just the two fields, right, the id and the balance, and we've calculated out the serial version for it. So we're going to go ahead and add in that field called serialVersionUID. It's type is long, and it's static final, and we'll mark it as private, and then we simply assign it the value that serialver calculates, and that's the only change we have to make to the type. So now we go ahead and serialize an instance of our BankAccount class when it's writing out to the serialization stream. Rather than calculating a new serial version, you'll actually use reflection to grab the value of that serialVersionUID field and write that into the serialization string. So now say our program ends; before we run it again, we want to update our BankAcount class. So in addition to those original two fields, we add the additional fields, a transaction type and the last transaction amount, and we want this version of our BankAccount class to be compatible with the previous version. So we're still going to have our serialVersionUID field, and the value of that field is going to be exactly the same as it was previously. In other words, we're not changing it, and by not changing it, we're declaring the new version of the BankAccount class to be compatible with that previous version. So now what will happen is that as we try to deserialize the content into this BankAccount class, the serialization system will again use reflection to see the serial version of the current class definition. It will then grab the serial version from the serialization stream and compare them. And because they are now equal, the deserialization will now be possible; it will now work. And the serialization system takes care of any changes that might happen. Had we removed any fields from the new definition, than any serialized values of this field would just be discarded. Now in our case, we added additional fields. So these additional fields will simply have whatever the default value for an uninitialized member of their type is. So in the case of like a char field, by default, that just has the null character inside of it. The case of our in field, well, that just has a 0 value inside. So you can see that the serialization system provides a really sensible default behavior, but now what if we had to do extra work to maintain compatibility between new versions of a type and an older version of a type? Well, solving that issue is what we're going to take a look at in the next clip.

The Need for Custom Serialization
As we saw on our last clip, using the serial version unique identifier, we were able to maintain compatibility with a type that may have been serialized when our type had one definition and is now being deserialized into a new, updated definition for that type. And as we saw, the serialization system provided a good default behavior for handling the values of those fields that were not in the original serialized version. But in some cases, that default behavior isn't quite enough. So let's consider our BankAccount class, and let's go back to when we had only two fields in it, the id and the balance. Remember that when we enter these two fields, our deposit method simply incremented the balance of the account, and our withdrawal method simply decremented the balance of the account. So if we created an instance of our BankAccount class with an initial value of $500 in the balance, and we deposit another $250, and then we call that saveAccount method we were earlier in this module to serialize it, we now have that class serialized into our file, account1.dat. And the only fields that are being serialized are the id and the balance. So now I say we go ahead and we update our BankAccount class to have four fields, the id and the balance, as well as that lastTxType and lastTxAmount. Well, with that change, our deposit method, in addition to incrementing the balance, sets our lastTxType to d, and stores the lastTxAmount, and our withdrawal method decrements the balance, sets our lastTxType to w, and then stores that transaction amount. So let's say we create a BankAccount class instance with an initial value of 500, and then we, again, call our saveAccount method to serialize it into a file, account2.dat.. So this version of BankAccount has four fields written to the serialization stream, the id and the balance, as well as the lastTxType and the lastTxAmount. So now that our class has this new version with all four fields in it, if we then go out and call the loadAccount method we wrote earlier to deserialize the content of account2.dat, that's the serialization stream that had all four fields in it, our account2 field would read back all four fields, the id and the balance, as well as the lastTxType and the lastTxAmount. Well, because that BankAccount never had any transactions applied to it, the lastTxType has a default value for a char, which is the null character, and it has a default value for the amount, which is a 0. But now if we go ahead and call loadAccount to read the content of account1.dat, which is the version of BankAccount that only wrote the id and the balance to the serialization stream, well, we'll read back the id and the balance, and the default serialization handling will set the lastTxType and the lastTxAmount to whatever the default is for their types, which means that our lastTxType will have a value of the null character, and our lastTxAmount will have a 0. Now at first, this might seem okay, but imagine now if our application that we're writing has to look at account, display its balance, and show the most recent transaction. So in the case of acct2, it would say, well, there is no most recent transaction because we can see our TxType is null. But now if we try to display the information for acct1, we would show the balance, and we would also say there were no recent transactions because the serialization stream did not contain enough information. Now we know earlier we actually applied a deposit to that account, but that information wasn't captured in the serialization stream. But our application is saying that there are no recent transactions is actually misleading. It would be better for us to say, well, for acct1, we don't know what the recent transactions are, and so let's see how we can address that.

Customizing Serialization
So this is where custom serialization handling comes in. We have the ability to customize the process. So we can actually add our own handling for the serializing process by adding a writeObject method to our type. We can also add our own handling to the deserializing process by adding a method called readObject to the type. Now both these methods are called through reflection by the serialization system. So in most cases, we're going to go ahead and mark them as private because we don't want anyone else calling them. So now in terms of implementing the writeObject method, basically it should just have a void return type, and we'll want to include a throws clause because it's possible during the serialization process to have an IOException. So we'll go ahead and just throw the IOException. Now the writeObject method accepts an ObjectOutputStream. As you may recall, the ObjectOutputStream is a type that we created when we initially initiated the serialization process. So basically, we're getting a reference to the ObjectOutputStream that's doing the serialization of our type. Now ObjectOutputStream has a series of write methods on there. So you can say things like writeInt or writeChar, that sort of thing. And it also has a defaultWriteObject method, which is useful for scenarios where you may want to have your own code run during the serialization process, but you don't want to actually do any special serialization. So let's look now at our BankAccount class. So we've got our four fields in there, and what we'll do is we'll go ahead and add in our own writeObject method. We'll have it throw the IOException. Remember it will receive the ObjectOutputStream and receiving that as a parameter calling out. So what we could do here is say things like out.writeInt to write the balance out or out.writeChar to write things like lastTxType out. What we're going to do is just go ahead and say out.defaultWriteObject, saying I just want the standard default serialization to happen. The thing is, in many cases, we may want to customize the deserialization process, but go ahead and accept the serialization process. So now to go ahead and customize our deserialization process, we're going to go ahead and implement the readObject method. That also has a return type of void. It also needs our throws clause. But in addition to throwing an IOException, we'll also throw a ClassNotFoundException because remember that in the process of deserializing, we may encounter types that may not be in our class path. This will receive a reference to the ObjectInputStream. Again, that's the object we created when we initiated the deserialization process. So again, we'll get a reference to the ObjectInputStream just doing the deserialization. Now it has a series of read methods on it. So just like you can do a writeInt when you write content, you can do a readInt when you read it back in. The thing is using methods like writeInt and readInt, they're positional, meaning that whatever the first thing you wrote needs to be the first thing that you read. But ObjectInputStream also has a method called readFields, and that gives you information about the fields that are actually serialized. And with that information, you can actually access values by the name that they were stored under. Now ObjectInputStream also has a default readObject you can use to do, well just do your normal default deserialization. So now, again, looking at our BankAccount class, we'll provide our readObject method. We'll have our throws. This throws the IOException and the ClassNotFoundException. We're going to receive the ObjectInputStream. And then what we're going to do is we want to actually call the readFields method against it. And what that does is that gives us back a type called ObjectInputStream.GetField. And what we get in this fields variable is information on the serialized fields. So what we can do then is call things like fields.get. And what it will then do is pass in the name of what we want. So what we want to say is give me the value that was serialized for the member called id. And we can then assign that into our id member. Now it actually comes back is an object, which is why we're casting it to a string. So we can then say fields.get for balance, which says give me the value that was serialized for balance, and I'll put that into the balance member. Now we know that for our BankAccount class, no matter what version the class we we're working with, there are always values written for id and balance. But now we're going to call fields.get. I'm going to pass in the lastTxType. Now we know that old versions of BankAccount did not include information for lastTxType. But we know our newer version did. So if there was a value written for lastTxType, we'll actually read that back. But we're also provided a default value. So in cases where we try to read lastTxType from the serialization stream, if there's no value there, we'll actually assign a value u to lastTxType. We'll use that to indicate unknown. In the same way, we can say fields.get, passing in the lastTxAmount. If there was a value serialized for lastTxAmount, we'll get that back. If not, we'll say give it a default value of ‑1. So any BankAccount instances that were serialized without a lastTxAmount, the lastTxAmount will now be ‑1. So now what all this does for us is that now that we have our BankAccount class updated to have all four fields, but now we've customized a serialization process. So if I now call that loadAccount method to deserialize the content in account2.dat, which was the serialization stream that had all four fields in it, acct2 will have the id and balance read back, as well as the lastTxType and lastTxAmount. But since there were no transactions applied to that account, the lastTxType of the null character and lastTxAmount of 0 is accurate. So we could accurately report that this account has never had any transactions applied to it. But now as we read back the BankAccount is then account1.dat, which is the serialization stream that we only wrote an id and balance to. Well because there was no lastTxType and lastTxAmount in that stream, we actually set those values to u for unknown transaction type and an amount of ‑1. So in this case, our application could report the current balance for this account, but basically say we don't have enough information to know what the most recent transactions are. So in that case, we're actually more accurately reporting what's going on. Okay, now the next clip, let's see how we can exclude certain fields from the serialization process.

Transient Fields
There are some scenarios where you may want to type the support serialization, but you may not want all the fields in that type to be part of the serialization. This is useful for scenarios where you have fields in that type that could be derived from other fields and that's helpful because it avoids taking up unnecessary space in the serialization storage. Now this is a case we can actually use the transient keyword to identify the fields that we don't want to be part of the serialization, and only what we'll then do is that when we restore that type, we'll go ahead and set the value of the field marked transient manually. One of the ways we commonly do that is by customizing the serialization. So let's look at an example. So I have a class that we'll call my AccountGroup. The AccountGroup has a map inside of it that can hold bank accounts, so the key will be the id of the bank account, which is a string, then, of course, the value will be the bank count itself, and we'll use this account group for scenarios where maybe a person has multiple bank accounts, want to keep those grouped together or maybe a family has the parents with accounts and children with some accounts. So AccountGroups allow us to keep those together. So one of the things we'll have is a field that tells us the total balance of all the accounts in a group, of course, we'll have a getter for that. Then what we'll do is that each time we add an account to the group, we'll go ahead and take the balance from that particular account, add it into the total balance, and then take the account and added into the map. So now, if we look at our AccountGroup, the only field in it is the accountMap field. Well the accountMap field is a map and we know that the bank accounts inside of that map can be serialized, we've already determined that the String class supports serialization, and if we were look at the documentation on hashMap, that also supports serialization, so that means that the only field in our AccountGroup is serializable. So that means, of course, then we can take our AccountGroup and mark that as Serializable, but we know as this is written, our total balance field can be determined from getting the balances from the accounts contained in the group. So what we'll do then is take our totalBalance field and mark it as transient. So by marking it is transient, what that means is that when we serialize instances of AccountGroup, the value of the totalBalance field won't be written to the serialization stream, and then when we deserialize instances, there will be no value read back for the total balance field. So let's see what it's like now to use our AccountGroup class. What we'll do is we'll start out by creating instances of our BankAccount class that has a balance of $500. We'll create another instance of our BankAccount class that has a balance of $750. We'll then create our AccountGroup and then add both of those accounts into the AccountGroup. So the total balance in our AccountGroup now will be $1250. So what we'll do is we'll call a method called saveGroup that will actually take care of serializing an instance of our AccountGroup into a file called group.dat. Now our saveGroup method will look very much like the serialization we wrote much earlier in this module. So what we'll do is go ahead and open up an ObjectOutputStream over the file, we'll then put a try catch in place to handle the exceptions, and then we simply will take our ObjectOutputStream and call its writeObject passing in the object to serialize and that easily we've now serialized our AccountGroup instance. So now to go ahead and deserialize our AccountGroup instance, we'll create a method here called loadGroup that accepts a filename, returns back the newly loaded AccountGroup instance. We'll have a local variable for the AccountGroup, in this case, we'll go ahead and open up our ObjectInputStream over the filename, we'll handle our exceptions, we have one for the IOException, one for the ClassNotFoundException, and then we'll take our ObjectInputStream, call readObject to read back the AccountGroup, and then we'll simply return that back from the method. So let's go ahead and call our loadGroup method. What that'll do now is give us back the deserialized version of our AccountGroup, so this will be AccountGroup that actually contains the 2 bank accounts we added on the previous slide or that 1 had a balance of $500, the other had a balance of $750. So if we now go ahead and take our AccountGroup and call getTotalBalance and write that out, what do we get? Well, we get back 0 because remember that we've excluded total balance from the serialization process. Alright, looking here at our AccountGroup class because of that transient modifier on totalBalance means it doesn't get serialized out or read back. So we'll need to do here is go ahead and customize our serialization so that we can go ahead and set the value of totalBalance. We don't need to make any changes in terms of how we serialize AccountGroup, it's only the deserializing we need it to handle. So we'll go ahead and add a method readObject that takes that object input stream. Alright, so this is now us providing our own custom deserialization. So what we'll do now is just go ahead and call the default readObject because we wanted to deserialize the type just as it always does and that'll take care of all the details of deserializing the hashMap that corresponds to our accountMap field, but what we want to do now is go ahead and manually set the total balance. Now we can do that by simply looping through the accounts in the accountMap and then getting the balance from each one of those and adding them into the total balance, alright, and that easily now we'd go ahead and had our totalBalance field, which was transient had its value properly set using other values we had access to as part of the deserialization. Now notice that we only have an implementation of readObject. We don't have a implementation of writeObject. Because we don't need to modify the way the actual serializing occurs, there is no reason for us to provide the writeObject because the only thing we would do inside of there is call the default writeObject method. So in cases where you only would be calling the default writeObject method, there is no reason to provide the writeObject implementation. That's worth noting because in our previous clip, we did provide a writeObject that the only thing it did do was call the default writeObject and that was just to demonstrate how you provide both methods, readObject and writeObject. In a case like here like we have with AccountGroup, because we only need to change the way it's deserialized, we only have to provide implementation of readObject. So now if we call loadAccount, deserializing our AccountGroup contained the 2 accounts, right, 1 with $500 balance and 1 with $750 balance, now if we go ahead and write out the total balance from the AccountGroup, now we get the proper value $1250.

Summary
That wraps up our discussion of serialization. So here are some of the key things you want to remember from this module. First, I'll remember that serialization provided a way for object persistence, a way to store and retrieve our objects. We could do things like store them in the files or databases and pull them back, and we could even pass objects between processes or across the network. Now, when it comes to a type being serializable, remember that primitive types are implicitly serializable, but classes must implement the serialized interface. Now remember that interface has no methods on it, it's just a marker interface, but basically by implementing it, our class is saying that it knows how to be properly serialized and deserialized. Now when it comes to the task of serializing and deserializing our types, remember that there were two core classes here. There was the ObjectOutputStream class, which took care of actually using reflection to look at our class instances and writing that content out to a serialization stream, and then there was the ObjectInputStream that could take that serialization stream and then rebuild our objects from that information. Remember, we talked a lot about this idea of this thing called the serial version unique identifier. Remember, that was the thing that was used to determine if different versions of our type were compatible. Now by default, Java will perform a calculation to arrive at that value. But remember though, the result that calculation depends on the content of your type. And so as a result, changes to our type, we tend to break compatibility between versions of that type. But we can also explicitly set our serial version unique identifier. We do that by adding a field called serialVersionUID to our type. And then what we'll generally do is that in the first version of our type to support civilization, we'll calculate that value using utility called serialver, and then once we have that value, we maintain that value across versions and that maintains compatibility across versions. So what happens there is that rather than compatibility between versions of our types being dependent on the types content, we now, as developers, have control of compatibility across versions. And then the last thing we looked at was this issue of customizing the serialization process. Remember that there is a method called writeObject that we could add to our types that would then be called during the process of serializing the object that received a reference to the object output stream that was performing the serialization. We also had the readObject method that the system would call during the deserialization process to give us control and that received the ObjectInputStream that was performing the deserialization. Now remember that both of these methods, writeObject and readObject, the serialization system will use reflection to find, so I'm not tied to one interface, we just add them to our type. If they're present, the serialization system will use them. The last part of customization we looked at was this idea of marking fields as transient and it was a way to exclude a field from the serialization process and that was used when we had values that could be derived from other values so we didn't waste space in the serialization stream, serializing it and deserializing it. And during the deserialization process, generally, what we would do is use custom handling to then go off and set the value of those fields that were marked as transient. So now we've reached the end of our course, Java fundamentals: The Core Platform, and the question always comes up, well, where do we go from here? Well, one of the most important places I would encourage you to look is the Pluralsight Skill Path for Java, and I've got the URL on the screen there, because it includes a great progression of courses that will build your skills as a job developer. It includes this course, it also includes my other course on the Java language, as well as a variety of courses by a variety of authors, like there's a good chance you arrived at this course through the Java Skill Path. But if you haven't already checked it out, I really encourage you that when you finish this course to now go over and take a close look at the courses that are contained in the Java Skill Path. In addition to all the great courses that are in the Pluralsight Java Skill Path, there are also two other courses I think you should take a look at. There is a course specifically on Java collections. Now we talked about Java collections in this course, but the Java Collection course goes much deeper into that topic. Another great course to consider is the course, Applying Concurrency and Multi‑threading to Common Java Patterns. This takes the multi‑threading discussion from this course and builds on it, and it shows you a number of practical ways to apply the abilities of multi‑threading from Java. And finally, I'd just like to thank you so much for joining me throughout our discussion of the capabilities of Java platform. I wish you the absolute best as you head out and start working as a Java developer.